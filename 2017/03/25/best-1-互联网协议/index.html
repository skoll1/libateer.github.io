<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/libateer.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/libateer.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/libateer.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="互联网协议," />





  <link rel="alternate" href="/libateer.github.io/atom.xml" title="李巴特儿de小屋子" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/libateer.github.io/favicon.ico?v=5.1.0" />






<meta name="description" content="###https为什么安全###他是http和ssl/tls的组合密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。

密匙：是在使用密码算法的过程中输入的一段参数，同一个明文在相同的密码算法和不同的密匙计算下回产生不同的密文。密匙才是决定密文是否安全的重要参数，密匙越长，破解的难度越大。根据密">
<meta property="og:type" content="article">
<meta property="og:title" content="互联网协议">
<meta property="og:url" content="https://github.com/skoll1/libateer.github.io/2017/03/25/best-1-互联网协议/index.html">
<meta property="og:site_name" content="李巴特儿de小屋子">
<meta property="og:description" content="###https为什么安全###他是http和ssl/tls的组合密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。

密匙：是在使用密码算法的过程中输入的一段参数，同一个明文在相同的密码算法和不同的密匙计算下回产生不同的密文。密匙才是决定密文是否安全的重要参数，密匙越长，破解的难度越大。根据密">
<meta property="og:updated_time" content="2017-03-30T17:01:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="互联网协议">
<meta name="twitter:description" content="###https为什么安全###他是http和ssl/tls的组合密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。

密匙：是在使用密码算法的过程中输入的一段参数，同一个明文在相同的密码算法和不同的密匙计算下回产生不同的密文。密匙才是决定密文是否安全的重要参数，密匙越长，破解的难度越大。根据密">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/libateer.github.io/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/skoll1/libateer.github.io/2017/03/25/best-1-互联网协议/"/>





  <title> 互联网协议 | 李巴特儿de小屋子 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/libateer.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李巴特儿de小屋子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">...触之不动...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/libateer.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/libateer.github.io/categories/Code" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github"></i> <br />
            
            程序笔记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-person">
          <a href="/libateer.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />
            
            个人日记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-read">
          <a href="/libateer.github.io/categories/Read" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            读书笔记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/libateer.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/skoll1/libateer.github.io/libateer.github.io/2017/03/25/best-1-互联网协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李巴特儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/libateer.github.io/images/libateer.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李巴特儿de小屋子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                互联网协议
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-25T21:00:43+08:00">
                2017-03-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/libateer.github.io/2017/03/25/best-1-互联网协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/25/best-1-互联网协议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>###https为什么安全###<br>他是http和ssl/tls的组合<br>密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。</p>
<ol>
<li>密匙：是在使用密码算法的过程中输入的一段参数，同一个明文在相同的密码算法和不同的密匙计算下回产生不同的密文。密匙才是决定密文是否安全的重要参数，密匙越长，破解的难度越大。根据密匙的使用方法，密码可分为对称加密和公匙加密。</li>
<li>对称密码：加密和解密的使用相同的密匙。关键问题：如何安全的传送密匙。</li>
<li>公匙加密：发送者用加密密匙进行加密，接受者用解密密匙解密。加密密匙是公开的，任何人都可以获取。解密密匙只能自己使用。收的人自己创建锁和钥匙，把箱子给他，把东西放到这个里面，然后发送回来。</li>
<li>消息摘要：消息摘要函数是一种用于判断数据完整性的算法，也称为散列函数或哈希函数，函数返回值叫做散列值，散列值又称为消息摘要或是指纹。这种算法是一个不可逆的算法，因此你没法通过消息摘要反推出消息是什么。所以他也称为单项散列函数，下载软件时如何确定是官方提供的完整版呢，如果中间有人在里面嵌入了病毒，你也不得而知。所以我们可以使用散列函数对消息运算，生成散列值，通常软件提供方会同时提供软件的下载地址和散列的散列值，用户下载后在本地用相同的散列值算法甲酸出散列值，与官方提供的散列值对比，如果相同的，说明软件时完整的，否则就是被别人修改过的。</li>
<li>消息认证：可以解决同事替代消息和消息摘要的情况。</li>
<li>消息认证码是一种可以确保消息完整性并进行认证的技术。消息认证码是一种可以理解为一种与密匙相关的单项散列函数。<br>7.<br>公钥证书</li>
</ol>
<p>公钥密码在数字签名技术里面扮演举足轻重的角色，但是如何保证公钥是合法的呢，如果是遭到中间人攻击，掉包怎么办？这个时候公钥就应该交给一个第三方权威机构来管理，这个机构就是认证机构（Certification Authority）CA，CA 把用户的姓名、组织、邮箱地址等个人信息收集起来，还有此人的公钥，并由 CA 提供数字签名生成公钥证书（Public-Key Certificate）PKC，简称证书。</p>
<ol>
<li>Bob 生成密钥对，私钥自己保管，公钥交给认证机构 Trent。</li>
<li>Trent 经过一系列严格的检查确认公钥是 Bob 本人的</li>
<li>Trent 事先也生成自己的一套密钥对，用自己的私钥对 Bob 的公钥进行数字签名并生成数字证书。证书中包含了 Bob 的公钥。公钥在这里是不需要加密的，因为任何人获取 Bob 的公钥都没事，只要确定是 Bob 的公钥就行。</li>
<li>Alice 获取 Trent 提供的证书。</li>
<li>Alice 用 Trent 提供的公钥对证书进行签名验证，签名验证成功就表示证书中的公钥是 Bob 的。</li>
<li>于是 Alice 就可以用 Bob 提供的公钥对消息加密后发送给 Bob。</li>
<li>Bob 收到密文后，用与之配对的私钥进行解密。</li>
</ol>
<p>###互联网协议入门###</p>
<ol>
<li>互联网的实现，分为好几层，每一层都有特定的功能，互联网的核心，就是一系列协议，总称为互联网协议。她们对电脑如何连接和组网作出了详细的规定。</li>
<li>第一层：实体层，把电脑连接在一起的物理手段。它主要规定了网络的一些电气特性，作用时负责传送0和1的电信号。</li>
<li>链接层：单纯的0和1没有任何意义，必须规定解读方式：多少个信号算一组，确定了0和1的分组。</li>
<li>以太网协议：早期的时候，每家公司都有自己的电信号分组方式。逐渐的，一种叫以太网的协议占据了主导地位。</li>
<li>一组信号构成一个数据包，叫做“帧”，每一帧包含两个部分，标头和数据。标头：发送者，接受者，数据类型。数据：数据包的具体内容。</li>
<li>标头和数据的大小都是有规定的，如果大于他所规定的范围，必须切割分成多个字段进行。</li>
<li>mac地址：就是网卡的地址，数据包的发送地址和接受地址。</li>
<li>广播：定义地址只是第一步，以太网采取了一种很原始的方法，他不是把数据包准确的发送给接收方，而是向本网络的所有计算机都发送，让每台计算机都自己判断，是否接受。</li>
<li>网络层：从上面的情况来看，必须找到一种方法，能够区分哪些MAC地址属于同个子网络，这样才能广播。网络层的诞生就是为了解决这个问题，它引进一套新的地址，使我们能够区分不同的计算机是否属于一个子网络。这套协议就叫做“网络地址”，简称“网址”。从逻辑上，我们先处理网络地址，在处理MAC地址。</li>
<li>IP协议的两个作用：一个是为每一个计算机分配IP地址，另一个是确定是哪些地址在同一个网络下。</li>
<li>arr协议，我们可以得到同一个子网络内的主机的MAC地址，从IP地址转换来，这样就可以把数据包发送到另一个主机之内了。</li>
<li>传输层：有了MAC地址我们就可以在互联网上任意两台电脑上建立通信。接下来的问题是一台计算机上的不同应用都需要用到网络，那么怎么区别发来的一个数据包属于那部分要用的信息呢。</li>
<li>我们需要一个参数来表示数据包属于哪个程序使用。这个参数叫做端口，他其实是每一个使用网卡的程序的编号。每个数据包发送到主机的特定端口，所以不同的程序能去到自己所需的数据。</li>
<li>传输层的功能是：建立端口到端口的通信。相比之下，“网络层”的功能是建立在“主机到主机”通信，只要确定主机和端口，我们就能实现程序之间的交流。</li>
<li>TCP和UDP协议都是为了实现这个目标，只不过TCP协议有确认机制，每一个发出的数据都是要确认，如果一个数据包发出得不到确认，就有必要重新发送一遍了。</li>
<li>应用层：收到数据后的行为。解读实现规定好的格式的数据，TCP协议可以解读EMAIL，WWW，ftp.这是最高的一层直接面对用户。她的数据就放在TCP数据包的“数据部分”。</li>
<li>数据传输的场景：同一个子域，对方的MAC地址，对方的IP地址。非统一个子网络，网管的MAC地址，对方的Ip地址。</li>
<li>动态IP地址：计算机开机时，会自动分配到一个IP地址，不用人为设置，DHCP协议：每一个子网络中，都有一台计算机负责管理本网络的所有IP地址，新加入的计算机加入网络，必须向“DHCP服务器发送一个“DHCP请求”数据包，申请IP地址和相关的网络参数。</li>
<li>上网的人确定四个参数才能用：本机的Ip，子网掩码，网关的IP地址，dns的IP地址。</li>
<li>dns</li>
</ol>
<p>###异步通信开发###</p>
<ol>
<li>http专门用来负责超文本的传输，也就是所谓的web信息传输（网页，图像，不同类型的文件）</li>
<li>http主要由两部分组成：请求和响应。</li>
<li>Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接Keep-Alive: timeout=5, max=100</li>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>客户端请求结构 请求行，请求头部，空行，和请求数据<br>GET /hello.txt HTTP/1.1<br>User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3<br>Host: www.example.com<br>Accept-Language: en, mi</li>
<li>GET /pagead/js/adsbygoogle.js?_=1472721354924 HTTP/1.1<br>Host: pagead2.googlesyndication.com<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0<br>Accept: <em>/</em><br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Accept-Encoding: gzip, deflate<br>Referer: <a href="http://domestic.firefox.sina.com/16/0901/01/R0GJL8D7VI5SUOKN.html" target="_blank" rel="external">http://domestic.firefox.sina.com/16/0901/01/R0GJL8D7VI5SUOKN.html</a><br>Connection: keep-alive</li>
<li>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由 于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址</li>
<li>服务器响应消息 状态行 消息报头 空行 响应正文</li>
<li>HTTP/1.1 200 OK<br>Date: Mon, 27 Jul 2009 12:28:53 GMT<br>Server: Apache Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。<br>Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 实体头指定服务器上保存内容的最后修订时间<br>ETag: “34aa387-d-1568eb00”<br>Accept-Ranges: bytes<br>Content-Length: 51<br>Vary: Accept-Encoding<br>Content-Type: text/plain Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型 Content-Range实体头 </li>
<li>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： </li>
</ol>
<p>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth </p>
<p>例如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围， Content-Length表示实际传送的字节数。</p>
<ol>
<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>
<li>Allow 服务器支持哪些请求方法（如GET、POST等）</li>
<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>
<li>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。</li>
<li>http状态码分类：1 服务器收到信息，需要请求者继续执行操作。 2 成功 操作被成功接受处理 3 重定向 需要进一步的操作完成请求 4客户端错误 请求包含语法错误或无法完成请求 5 服务器错误 服务器在处理请求的过程中发生了错误。</li>
<li>交互的核心是有一个信息处理机制，这个处理机制就是回调函数。该函数时被在服务器端调用的，并负责处理服务端信息相应的信息。 </li>
<li>既然可以通过影藏框架实现动态加载服务器的请求页面，呢为什么不能用js代码开始实现这个功能呢，js标签能够动态的加载外部的js脚本，js脚本文件不仅仅可以被执行，而且可以传输数据，所以我们不妨在访问服务器端的时候使用js文件来附加传递信息。当客户在远程加载脚本文件的时候，这些附加在js脚本文件的响应信息也一并被加载到客户端中，实现异步交互的效果。</li>
</ol>
<p>###图解http协议###</p>
<ol>
<li>http是无状态的协议。超文本传输协议（超文本转移协议），适用于从万维网服务器传输超文本到本地浏览器的传送协议。</li>
<li>http是基于tcp/ip通信协议来传递数据的。由网络层的IP协议和传输层的TCP协议组成，TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址</li>
<li>无连接：限制每次连接只能处理一个请求，服务器处理完就立刻放手，断开连接。</li>
<li>http:媒体独立的，只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过http发送。客户端以及服务器端通过使用适合的MIME-type内容类型。</li>
<li>无状态：协议对事件处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则他必须重传，这样可能导致每次连接传送的数据量增大。另一方面，当服务器不需要之前的信息的时候就变得很快了。</li>
<li>http使用统一的资源标识符来URL来传输数据和建立连接。。</li>
<li>现在使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而http属于他的内部一个子集。</li>
<li>tcp/IP是互联网相关的各类协议族的总称（协议中存在各式各样的内容：包括电缆的规格，ip地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及web页面显示需要处理的步骤）</li>
<li>TCP/IP协议族最重要的一点就是分层（应用层，传输层，网络层，数据链路层）</li>
<li>应用层（ftp&lt;文件传输&gt;,http,dns&lt;域名管理&gt;）–传输层（连接俩台计算机之间的数据传输Tcp&lt;传输控制协议&gt;udp&lt;用户数据报协议&gt;）–网络层（处理在网络上流动的数据包，在众多的选项内选一条传输路线）–数据链路层（处理连接网络的硬件部分，包括控制操作系统，硬件的设备驱动，nic,硬件上的范畴基本上都在链路层的作用范围之内）–物理层</li>
<li>利用tcp/ip协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从应用层往上走。</li>
<li>浏览器现在客户端发出想看某个页面的http请求，接着为了传输方便，在传输层把从应用层收到的数据进行分割，并且会在各个报文上边打上标记序号以及端口号转发给网络层。在网络层（iP）,增加作为通信目的地点的MAC地址发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li>
<li>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接受端在层与层之间传输数据时，每经过一层时会把对应的首部去掉。这种把数据信息包装起来的做法称为封装。（http数据-TCP首部-IP首部—-以太网首部）</li>
<li>负责传输的IP协议：位于网络层层。所有使用网络的系统都会用到IP协议，IP协议的作用是把各种数据包传送给对方，利用IP地址和MAC地址定位实现。IP地址指明了节点被分配的地址，MAC指的是网卡所属的固定地址，IP地址和mac地址来配对，IP地址可以互相变化，但是MAC地址基本上不会改变。</li>
<li>ip间的通信依赖mac地址，通常的同心都是进过多台计算机和网络设备中转才能连接到对方。而在进行中转时，就会利用到另一台计算机的mac地址来搜索下一个中转目标。</li>
<li>在到达通信目标前的中转过程中，那些计算机和路由设备只能获悉很粗略的传输路线。这种机制就是路由选择，就像快递公司一样。无论那台计算机，哪台网络设备，他都无法掌握互联网中的细节。</li>
<li>确保可靠性的TCP协议：位于传输层，提供可靠地字节流服务。将大块的数据分割成以报文段为单位的数据包进行管理。而可靠地传输服务就是指能够把数据准确可靠地传给对方。tcp协议能够确认数据是否最终送达到对方。</li>
<li>为了确保无误的将数据送到目标处，tcp采取了三次握手的策略。TCP把数据包发送出去之后，tcp不会不对数据的去向不管，他一定会确认是否成功送达。握手的过程使用了TCP的标志（flag）-SYN-ACK。</li>
<li>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，在返回一个带有SYN,ACK的数据包表示确认信息。然后发送端在回传一个带ACK标志的数据包，代表握手结束。若是在握手的某个阶段发生中断，tcp协议就会再次以相同的顺序发送相同的数据包。</li>
<li>除了三次握手，tcp协议还有其他各种手段来确保通信的可靠性。</li>
<li>dns位于应用层的协议。他提供域名到IP地址之间的解析服务。dns协议提供通过域名查找IP地址，或者逆向从IP地址反查域名的服务。</li>
<li>用户通常使用主机名字或域名来访问对方的计算机，而不是直接通过ip地址来访问，对于人来说我们一般输入字母比较容易记住，但是对于电脑来说一长串数组就好多了。</li>
<li>他们之间的关系：仔细想一遍</li>
<li>url，uri：与uri（统一资源标识符）相比，我们更加熟悉url(统一资源定位符)。</li>
<li>uri就是由某个协议方案表示的资源定位表示符。协议方案就是指访问资源时所使用的协议类型名称。采用http协议时，协议方案就是http.除此之外，还有ftp,mailto,telnet,file等。</li>
<li>uri用字符串表示识别某一互联网资源，而url表示资源的地点（互联网上所处的位置）url是uri的子集，一部分。</li>
<li><a href="http://(协议方案名)user:pass(登录信息)@www.baidu.com（服务器地址）:80(服务器端口号)dir/index.html?(带层次的文件路径)uid=1(c查询字符串)#ch1(片段标识符)。--完整的绝对uri格式" target="_blank" rel="external">http://(协议方案名)user:pass(登录信息)@www.baidu.com（服务器地址）:80(服务器端口号)dir/index.html?(带层次的文件路径)uid=1(c查询字符串)#ch1(片段标识符)。--完整的绝对uri格式</a></li>
<li>rfc是一些用来指定http协议技术标准的文档，通常，应用程序会遵照由rfc确定的标准实现。可以说，rfc是互联网那个设计的文档。要是不按照这个文档设计，那么就会可能导致无法通信。</li>
<li>http协议：</li>
<li>在应用http协议时，必定一端担任客户端角色，另一端担任服务器端角色。请求必定由客户端发出，返回一定有服务器端返回。首先是从客户端开始通信的，服务器端在没有收到请求之前是不会发送相应的。</li>
<li>http虽然是无状态的协议，但是为了实现期望的保持状态的功能，于是引入了cookie技术，有了cookie在用http协议通信，就可以管理状态了。</li>
<li>get方法用来请求访问一杯url识别的资源。指定的资源经服务器解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像cgl那样的程序，就返回经过执行的输出结果。</li>
<li>post的主要目的不是用来获取响应的主体内容，而是发送信息。</li>
<li>put。delete方法分别是上传和删除信息的两个操作，但是他们都不带验证机制，所以一般的web网站也不会使用delete方法。当配合web应用程序的验证机制，或者遵守rest标准时还是有可能会开放使用的。</li>
<li>options:询问支持的方法。-（返回服务器的支持的方法get,head,post,optioins）</li>
<li>trace:让服务器将之前的请求通信换回给客户端的方法。客户端通过这个方法可以知道发出去的请求是怎样被加工的。想要连接到原服务器目标可能会通过一系列的代理中转，trace方法就是用来确认连接过程中的一系列操作的。（容易引发xst跨站追踪）攻击，通常不会用到。</li>
<li>connect:这个方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl,tls协议把通信内容加密后经网络隧道传输。</li>
<li>head方法用来接收信息的头部</li>
<li>http协议的初始版本中，美进行一次http通信就要断开一次TCP连接。但是现在的网页如果需要传输大量的图片的话，就会浪费无谓的TCP连接和断开，增加通信的开销。</li>
<li>持久连接：只要任意一端没有明确的提出断开连接：那么就保持TCP持久连接状态。（http keep-alive http connection reuse）建立一次TCP连接后进行多次的请求和响应的交互。</li>
<li>持久连接使得多数请求以管线化方式成为可能，从前发送请求需要等待并接收到响应，才能发下一个请求。管线化技术出现后，不用等待响应也可以直接发送下一个请求。当请求一个包含10张图片的htmlweb页面，与挨个连接相比，用持久连接可以让请求更快的结束。而管线化技术择比持久链接还要快。请求越多，时间差就越明显。</li>
<li>cookie通过在请求和响应报文中写入cookie信息来控制客户端的状态。</li>
<li>cookie会根据从服务器端发送的响应报文内的一个set-cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往服务器端发送信息的时候，客户端会自动在请求包头上加上自己的cookie值后发送出去。服务器端发现刻画单发送过来的cookie后。回去检查是从哪一个客户端发送过来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
<li>http通信包括从客户端发往服务器端的请求以及从服务器端返回客户端的响应。</li>
</ol>
<p>###http报文内的http信息###</p>
<ol>
<li>请求报文=报文首部+报文主体（不是必须）</li>
<li>请求报文首部=请求行（请求方法，请求url和http版本）+请求首部字段+通用首部子端+实体首部字段+其他（cookie）</li>
<li>响应报文首部=状态行（响应结果的状态码，原因短语和http版本）+响应首部字段+通用首部字段+实体首部字段+其他</li>
<li>首部字段：表示请求和响应的各种条件和属性的各类首部。</li>
<li>报文是http通信中的基本单位，由8位组字节流组成，通过http通信传输。</li>
<li>实体：作为请求或响应的有效荷载数据被传输，其内容由实体首部和实体主体组成。</li>
<li>通常：报文主体等于实体主体。只有当传输中进行编码操作的时候，实体主体的内容发生变化，才导致他和报文主体产生差异。（当对内容编码的时候，可以有效地提升传输的速率，通过在传输的时候编码，能够有效地处理大量的访问请求。）</li>
<li>常用的内容编码：Gzip,compress,deflate.</li>
<li>在传输大量内容的数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码，分块传输编码会将实体主题分成多个部分。每一块都用16进制来标记块的大小，二十题主体最后的一块使用“0（CR+LF）”来标记。</li>
<li>mime:多用途因特网邮件扩展机制，它允许邮件处理文本，图片，视频等多个不同类型的数据。</li>
<li>为了解决下载过程中遇到网络中断的情况，为了避免重新下载，需要一种可恢复的机制，可以从之前下载中断的地方恢复下载。要实现该功能需要制定下载的实体范围。指定范围发送的请求叫做范围请求。rage bytes 5001/10000</li>
<li>针对范围请求，响应会返回状态码为206的响应报文，另外对于多重范围的范围请求，响应会在首部字段content-type标明multipart/byteranges。如果服务器无法响应范围请求，则会返回状态码200 ok和完整的实体内容。</li>
<li>内容协商机制：同一个网站可能存在多分相同的内容的页面，当浏览器默认语言为英文或中文，访问相同的URL的web页面时，则会显示对应的英语版本或中文版的web页面。</li>
<li>内容协商机制会以响应资源的语言，字符集，编码方式等作为判断的基准。包含在请求报文中的某些首部字段就是判断的基准。accept,accept-charset,accept-encoding,accept-language,content-language;</li>
<li>内容协商机制有以下几种情况：服务器驱动协商，已浏览器为标准，可能不会得到准确的信息。客户端驱动协商（脚本实现PC端或移动端）;透明协商：两个结合。</li>
</ol>
<p>###http首部报文###</p>
<ol>
<li>若http首部字段重复了会怎样？有的会使用第一个，有的会使用第二个。</li>
<li>通用首部字段：cache-control:控制缓存的行为</li>
<li>connection:逐跳首部，连接的管理。</li>
<li>data创建报文的日期时间。</li>
<li>pragma:报文指令。</li>
<li>trailer:报文末端的首部一览。</li>
<li>transfer_Encoding:指定报文主题的传输编码方式</li>
<li>upgrade:升级为其他协议</li>
<li>via；代理服务器的相关信息。</li>
<li>warning:错误统治。</li>
<li></li>
</ol>
<p>###返回结果的http状态码###</p>
<ol>
<li>状态码如200 OK 三位数字和原因短语组成。</li>
<li>1**信息状态码 请求正在处理</li>
<li>2**成功状态码 成功</li>
<li>3**重定向状态码 需要进行附加操作以完成请求</li>
<li>4** 客户端错误状态码 服务器无法处理请求</li>
<li>5** 服务器错误状态码  服务器处理请求出错</li>
<li>常用的状态码 200 成功  204处理成功，但是不给你更新页面，没有资源可以返回  206 只是进行了范围请求，成功了。</li>
<li>301 永久性重定向：请求的资源早已经被分配了新的url，以后应该使用资源现在的url&gt;也就是说，重新保存地址url.  302 临时性重定向 该状态表示请求的资源一杯分配了新的URL,希望用户能够使用新的url访问。  303 在302的基础上，请求方试必须为get  <em>当301，301，303响应状态码返回时，几乎所有的浏览器都会把post改成get，并且删除报文内的主体，并且之后请求会自动再次发送</em>  304：该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是没有满足条件的情况。和重定向没有关系。</li>
<li>400 请求报文内存在语法错误。服务器无法理解这个请求，但是浏览器会像200 OK 一样对待该状态码。 401 该状态码表示发送的请求需要有通过http认证的认证信息。另外若之前已经进行过一次请求，那么第二次返回就表示认证失败。</li>
<li>403 请求的资源没有权限，被服务器拒绝了。  404 服务器上没有请求的资源（也可以在服务器拒绝请求且不想说明理由的时候使用）</li>
<li>500 服务器端在执行请求的时发生了错误（都发生了错误了怎么还会返回信息呢？）  503该状态码表示服务器正在处于超载负荷停机维护，现在无法处理请求。<br>12.状态码和状况不一致，不少返回的状态码响应都是错误的，但是与用户是觉察不到这点的。</li>
</ol>
<p>###与http协作的web服务器###</p>
<ol>
<li>一台web服务器可以搭建多个独立域名的web服务器，也可以作为通信路径上的中转服务器提升传输效率。</li>
<li>http/1.1允许一台http服务器搭建多个web站点。比如提供web托管的供应商，可以用一台服务器为多位客户服务，也可以让每位用户持有的域名运行各自不同的网站，这是因为用了虚拟主机的功能。由于寄存在一个服务器下，当解析之后会有相同的Ip地址，所以在发送http请求时，必须在host首部内完整指定主机名或者域名的URL;</li>
<li>在http通信的时候，还有一些用与数据转发的应用程序，例如代理，网关，隧道。他们可以配合服务器工作。</li>
<li>代理：有转发功能的应用程序，接受由客户端发送的请求并转发给服务器，同时也接受服务器发回的响应并转发给客户端。(通过设置组织内部的代理服务器可以做到针对特定URL的访问控制)</li>
<li>网关：网关是转发其他服务器通信数据的服务器，接受客户发过来的请求，他就像自己拥有资源的服务器一样对请求处理。有事客户端都不会差距自己通信的目标是一个网关。网关可以使通信线路上的服务器提供非http协议服务。利用网管能提高通信的安全性，因为可以在客户端与网关之间的通信路线上加密以确保连接的安全，比如，网关可以连接数据库，使用sql语言查询数据。</li>
<li>隧道：在两个相聚很远的客户端和服务器端之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
<li>使用代理的原因：利用缓存技术，减少网络带宽的流量，组织内部针对特定的网站的访问控制，以获取访问日志为主要目的。</li>
<li>代理的分类：缓存代理》预想将资源的副本缓存保存在代理服务器上。当代理再次收到相同资源的请求的时，就可以不从源服务器那里获取资源获取资源，而是将之前的缓存的资源作为响应返回。</li>
<li>透明代理：转发请求或响应时，不对报文做任何的加工的代理类型被称为透明代理。反之，对报文内容进行加工的代理被称为非透明代理。</li>
<li>服务器端缓存，浏览器缓存：缓存是在本地磁盘内保存的资源副本，利用缓存能减少对源服务器的访问，因此也就节省了通信流量和通信时间。（怎么控制那些是可以缓存的，那些是不可以缓的，下一次请求怎么知道）</li>
</ol>
<p>###浏览器缓存清除###</p>
<ol>
<li><meta http-equiv="pragma" content="no-cache"><br> <meta http-equiv="Cache-Control" content="no-cache, must-revalidate">  <meta http-equiv="expires" content="0"></li>
<li>form表单的临时缓存： <body onload="javascript:document.yourFormName.reset()"></body></li>
<li><p>ajax 请求 $.ajax({<br>  url:’www.haorooms.com’,<br>  dataType:’json’,<br>  data:{},<br>  beforeSend :function(xmlHttp){ </p>
<pre><code>xmlHttp.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;); 
xmlHttp.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
</code></pre><p>  },<br>  success:function(response){</p>
<pre><code>//操作
</code></pre><p>  }<br>  async:false<br>});</p>
<ol>
<li><p>$.ajax({<br>url:’www.haorooms.com’,<br>dataType:’json’,<br>data:{},<br>cache:false,<br>ifModified :true ,</p>
<p>success:function(response){<br>   //操作<br>}<br>async:false<br>});</p>
</li>
<li>方法四：用随机时间，和随机数一样。在 URL 参数后加上 ?timestamp=+ new Date().getTime();</li>
</ol>
</li>
</ol>
<p>###浏览器的9中缓存机制###<br>2.浏览器缓存的种类：缓存协商（last-modified），彻底缓存(cache-control)</p>
<ol>
<li>http缓存是基于http协议的浏览器文件缓存机制。针对文件的重复请求的情况下，浏览器可以根据协议头判断从服务器端请求文件还是本地读取文件，chrome下的frames就是表示的浏览器的http文件级缓存。</li>
<li>协商缓存就是还要去页面问一下页面有没有更新，如果更新了，那么就返回新内容，如果没有，返回304直接使用胡村内容。</li>
<li>彻底缓存是在缓存失效之前不再需要和服务器发生交互，常用的是：Expires，expires是一个绝对时间，由服务器产生：这里容易出现的问题是服务器的时间可能和客户端的时间不一样，那么就用到了cache-control这是一个相对于浏览器的时间。</li>
<li>浏览器缓存的机制：针对重复请求的情况：判断pxpires：如果未过期，直接读取http文件，不发http请求，否则进入下一步。判断是否含有taag，有则带上if-none-mtahc发送请求，未修改返回304，修改返回200，否则进入下一步，判断是否含有last-modified,有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求。</li>
<li>last-modified:标志这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器最后的修改时间/if-modified-since：当资源过期的时候，发现资源具有last-modified声明，则再次向web服务器请求上带上头if-Modified-since，表示请求时间，web服务器收到请求后发现这个东西，泽宇被请求资源的最后修改时间进行对比，如果最后时间较新，说明资源被改过，则响应整片资源内容，</li>
<li>etag:web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。他的值是根据文件的索引，大小，最后修改时间hash得到的。</li>
<li>if-none-match:当资源过期的时候，发现资源有etag声明</li>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
<li>2：websql只有在比较新的chrome上实现：不是h5的一部分，将数据以数据库的形式存在客户端，根据需求去读取。web sql更方便检索，允许sql语句查询，让浏览器实现小型数据库的功能，三个核心方法：openDatabase : 这个方法使用现有数据库或创建新数据库创建数据库对象。transaction : 这个方法允许我们根据情况控制事务提交或回滚。executeSql : 这个方法用于执行真实的SQL查询</li>
<li>3： indexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且可以在这些数据上使用索引进行高性能检索的api。这个是为了存储大量结构化的数据而准备的。</li>
<li>4：cookie:一般网站为了辨别用户身份，进行session跟踪而存储在本地终端上的数据。不同域名之间的cookie是独立的，如果需要设置共享可以再服务器端设置cookie的path和domain来实现共享。</li>
<li>5：localStorage:是html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开的渲染速度，有大小限制，不适合放过多的数据，如果数据太大会删除最先的数据。</li>
<li>6： sessionStorage:浏览器关闭会全部删除，一般项目中不用。</li>
<li>application cache：将大部分的图片资源，js,css等静态资源放在manifest文件配置中。当页面打开时通过manifest文件来读取本地文件或是请求服务器文件。离线访问需要依靠这个来实现。</li>
<li>7：cacheStorage是在ServuceWorker的规范中定义的。cacheStorage可以保存每个serverworker申明的cache对象，</li>
<li>8：falsh缓存。</li>
<li>浏览器缓存类型：强缓存，不会向服务器发送请求，至鸡肉从缓存中读取资源。</li>
<li>协商缓存：向浏览器发送请求，服务器会根据这个请求的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并且带上新的参数统治浏览器从缓存中读取资源。</li>
<li>用户对浏览器缓存的控制：地址栏的访问，链接的跳转是正常用户的行为，将会触发浏览器的缓存机制,F5刷新会设置max-age=0,效果强缓存判断，会进行协商缓存判断；ctrl+f5:跳过强缓存和协商缓存，直接从服务器拉去资源。</li>
<li>web缓存游走于服务器和客户端之间。这个服务器可能是源服务器，数量可能是一个或多个，这个客户端也可能是一个或多个。web缓存就在服务器端和客户端之间搞监控，监控请求，并且把请求输出的内容另存一分。然后，如果下一个请求是相同的url，则直接请求保存的副本，而不是在次麻烦源服务器。</li>
<li>代理服务器缓存，网关缓存。</li>
<li>如何控制缓存和不缓存？</li>
<li>meta标签使用很简单，但是效果一般，如果你的网站托管到ISP或者主机托管商那里，并且他们没有赋予你任何设置http头信息的能力，那你就要注意了。</li>
<li></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/libateer.github.io/tags/互联网协议/" rel="tag"># 互联网协议</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/libateer.github.io/2017/03/22/best-1-this你所不知道/" rel="next" title="this">
                <i class="fa fa-chevron-left"></i> this
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/25/best-1-互联网协议/"
           data-title="互联网协议" data-url="https://github.com/skoll1/libateer.github.io/libateer.github.io/2017/03/25/best-1-互联网协议/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/libateer.github.io/images/libateer.jpg"
               alt="李巴特儿" />
          <p class="site-author-name" itemprop="name">李巴特儿</p>
           
              <p class="site-description motion-element" itemprop="description">每天写一点。。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/libateer.github.io/">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/libateer.github.io/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/libateer.github.io/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/libateer.github.io/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李巴特儿</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/libateer.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/libateer.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/libateer.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/libateer.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libateer.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/libateer.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/libateer.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/libateer.github.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/libateer.github.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/libateer.github.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/libateer.github.io/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/libateer.github.io/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/libateer.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"http://libateer.duoshuo.com"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/libateer.github.io/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/libateer.github.io/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
