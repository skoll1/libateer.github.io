<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李巴特儿de小屋子</title>
  <subtitle>...触之不动...</subtitle>
  <link href="/libateer.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/skoll1/libateer.github.io/"/>
  <updated>2017-03-13T12:38:55.000Z</updated>
  <id>https://github.com/skoll1/libateer.github.io/</id>
  
  <author>
    <name>李巴特儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试html-css-1</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E9%9D%A2%E8%AF%95html-css-1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-面试html-css-1/</id>
    <published>2017-03-13T12:37:07.000Z</published>
    <updated>2017-03-13T12:38:55.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="面试html-css-1" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%9D%A2%E8%AF%95html-css-1/"/>
    
  </entry>
  
  <entry>
    <title>关于图片的一些问题</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-关于图片的一些问题/</id>
    <published>2017-03-13T12:20:55.000Z</published>
    <updated>2017-03-13T12:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>###图片格式###</p>
<ol>
<li>jpg:这种图片一生成就是有损的，他把一些不打算不打算保存的数据抹掉，可支持有损压缩，不支持透明，动画，非矢量。</li>
<li>我们常见的图片格式是不能保存透明信息，系统会默认为白色背景。gif可以保存透明信息，但是gif最多有256种颜色，只能用在对图片要求不高的场景。</li>
<li>png可以支持无损压缩，而且可以很好地保存透明的信息。</li>
<li>jpeg：在拷贝照片的时候看到，一般都是我们先保存jpg,这种图片比较大是因为里面保存了相机里面拍摄的参数，色相，饱和度，对比度。可以直接的打印。</li>
<li>png:网页中用的最多，应为它支持透明，但是不考虑他的大小么？</li>
<li>盒模型溢出问题：用min－Height来解决溢出行为。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###图片格式###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jpg:这种图片一生成就是有损的，他把一些不打算不打算保存的数据抹掉，可支持有损压缩，不支持透明，动画，非矢量。&lt;/li&gt;
&lt;li&gt;我们常见的图片格式是不能保存透明信息，系统会默认为白色背景。gif可以保存透明信息，但是gif
    
    </summary>
    
    
      <category term="关于图片的一些问题" scheme="https://github.com/skoll1/libateer.github.io/tags/%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>页面优化</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-页面优化/</id>
    <published>2017-03-13T06:07:57.000Z</published>
    <updated>2017-03-13T11:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>###dns预加载</p>
<ol>
<li><ol>
<li>用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv="x-dns-prefetch-control" content="on"></li>
</ol>
</li>
<li><link rel="prefetch" href="http://www.example.com/"> <!-- Firefox --> </li>
<li><link rel="prefetch" href="/images/test.jpg">图片都可以</li>
<li><meta http-equiv="x-dns-prefetch-control" content="on"></li>
<li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.itechzero.com&quot;&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.baidu.com&quot;&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.baidu.com&quot;&gt;</code></li>
<li><ol>
<li>尽量减少HTTP请求。合并文件。csssprites(www.csssprites.com)</li>
</ol>
</li>
<li>使用cdn。</li>
<li>设置头文件过期或是静态存储。</li>
<li>Gzip压缩。</li>
<li>把css放在头部。把js放在底部</li>
<li>避免css表达式。</li>
<li>减少dns查询。</li>
<li>一些较为公开的js.css文件可以使用外链的形式。</li>
<li>减少重定向。</li>
<li>删除重复脚本</li>
<li>用get 方法来进行ajax交互。</li>
<li>预加载组建。</li>
<li>减少dom结构，更多的dom复杂的页面结构意味着需要更多的响应时间。</li>
<li>iframe:详细解释</li>
<li>cookie的使用。</li>
<li>js访问DOM是很慢的，尽量减少不用js构建网页结构。</li>
<li>使用事件代理。不要为dom树中的元素附加过多的事件句柄，并且这些被频繁触发。</li>
<li>图片要用多大就用多大的，网页内改变图片大小，它本身的大小是不会变化的。</li>
<li>别替用户做决定。</li>
<li>别让我等。别让我想。（包装好自己的网站，关注用户极其行为，引导用户，）别让我烦。缩短途径就是帮用户偷懒，那就是好的用户体验。</li>
<li>目标信息要醒目而且近，距离越远，越难点击。<br>###初级优化###</li>
<li>减少http请求</li>
<li>使用内容发布网络</li>
<li>添加expires头</li>
<li>Gzip压缩组件</li>
<li>减少dns查询</li>
<li>避免重定向</li>
<li>配置ETAG</li>
<li>使用AJAX缓存。</li>
<li>YSlow规则来重构代码</li>
<li>js代码的3个速度0.1 ,1,10.</li>
<li>webworker</li>
<li>想要开发离线应用，首先需要一种本地缓存和拦截文档的方法。还需要一种储存包括新旧两种文件的方法。d</li>
<li>当web worker不可用的话，使用greats和js定势器，来拆分代码。</li>
<li>拆分初始化加载，知道那些是必须加载的，那些是可以后来加载的。页面初始化，</li>
<li>script的阻塞行为，但浏览器解析dom的时候一但遇到script标签，就会立即下载并执行，与此同对浏览器的文档解析会停止，直到script标签的结束，出现这种阻塞行为一方面是因为浏览器的ui渲染，交互行为都是单线程操作，另一方面是因为script里面的代码可能会影响到后面文档的解析。</li>
<li>优化方案：尽量把脚本放在文档的后边，尽量按照脚本之间的依赖关系放在一个文件中，</li>
<li>延迟脚本：defer属性，可以让文档树全部解析完毕后触发，但不是所有的浏览器都支持这个属性。</li>
<li>动态脚本：用脚本创建script元素，设置src<br>function loadJS(url, callback){<br>var script = document.createElement(‘script’);<br>script.type = ‘text/javascript’;<br>if(script.readyState){  // 兼容IE的旧版本<br>script.onreadystatechange = function(){<br>  if(script.readyState == ‘loaded’ || script.readyState == ‘complete’){<pre><code>script.onreadystatechange = null;
callback();
</code></pre>  }<br>}<br>}<br>else{<br>script.onload = function(){<br>  callback();<br>}<br>}<br>script.src = url;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);<br>}<br>19.<br>loadJS(‘a.js’, function(){<br>loadJS(‘b.js’, function(){<br>loadJS(‘c.js’, function(){<br>  app.init();<br>})<br>})<br>})</li>
<li>xmlhttprequest动态插入；优点是可以：懒加载：也就是下载好了可以不执行，等她需要的时候在用<br>function xhrLoadJS (url, callback){<br>var xhr = new XMLHttpRequest();<br>xhr.open(‘get’, url, true);<br>xhr.onreadystatechange = function(){<br>if(xhr.readyState == 4){<br>  if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<pre><code>var script = document.createElement(&apos;script&apos;);
script.type = &apos;text/script&apos;;
script.text = xhr.responseText;
eval(xhr.responseText);  // 执行代码
document.body.appendChild(script);
callback();
</code></pre>  }<br>}<br>}<br>xhr.send(null);<br>}缺点是不能跨域加载。</li>
<li>js加载与执行：合并多个标签，减少请求次数</li>
<li>xor注入 var xhrObj=getXHRObject();xhrObj.onreadystatechange=function(){if(xhrObj.readyState==4){var }}getXHRObject(){var xhrObj=false;try{xhrObj=new XMLHttpRequest()</li>
<li>scriptdomelement: 创建，地址，加入，三步。允许跨域加载</li>
<li>忙指示器在某些情况下，我们需要忙指示器来告诉用户网页正在加载，其他情况下，最好不现实，鼓励用户和页面互动。</li>
<li>不同决策情况：不同域，无序，scriptdomelement</li>
<li>不同域，保持顺序：script defer，scriptdomelement</li>
<li>同域，无序，无忙指示器。xhreval xhr </li>
<li>无阻塞加载脚本可能出现竞争状态，我们关注依赖外部脚本里东移的标识符的行内脚本来，如果外部的脚本异步加载不考虑行内代码的依赖，那么可能会由于竞争出现为定义标示符的错误。以下就是整合两个代码之间的关系</li>
<li>绝大多数的网页在加载外部脚本的同时也包含使用了外部脚本定义的表示符内的行内脚本，因为行内脚本依赖于外部脚本，那么</li>
<li>在执行行内脚本的时候，必须保证外部脚本已被加载。</li>
<li>异步加载保证执行顺序。把行内代码和依赖行内代码的外部脚本整合起来。</li>
<li>var domscript=document.createElement(‘script’);</li>
<li>domscript.src=”menu.js”;document.getElementsByTagName(‘head’)[0].appendChild(domscript);</li>
<li>domscript.onloadDone=false;</li>
<li>domscript.onload=function(){</li>
<li>domscript.onloadDone=true;</li>
<li>init()</li>
<li>};</li>
<li>domscript.onreadystatechange=function(){</li>
<li>if((“loaded”===domscript.readyState||”complete”===domscript.readyState)&amp;&amp;!Domscript.onloadDone){</li>
<li>domscript.onloadDone=true;</li>
<li>init();</li>
<li>}</li>
<li>}</li>
<li>document.getElementsByTagName(‘head’)[0].appendChild(domscript);</li>
<li>// 单个脚本的情况下。</li>
<li>managed XHR技术是实现多个的方法。</li>
<li>＊行内脚本的的一些小知识点</li>
<li>行内脚本不仅阻塞下载，还阻塞渲染，</li>
<li>异步加载执行行内脚本：</li>
<li>function longCode(){</li>
<li>var tSatrt=Number(new Date());</li>
<li>while((tSatrt+5000)&gt;Number(new Date())){};</li>
<li>}</li>
<li>setTimeout(longCode,0);</li>
<li>在样式表后面的行内脚本会阻塞所有后续资源的下载。</li>
<li><ol>
<li>了解浏览器工作的原理：哪怕只知道个大概，也能知道在什么地方来优化</li>
</ol>
</li>
<li>减少html中元素的元素的数量，用最少量但是必须的html语义化去布局。</li>
<li>减少重绘，在绘制完成之后在动态的更改dom结构或者css样式都会引发浏览器的重绘。</li>
<li>浏览器的重绘：</li>
<li>性能的损耗直接取决于动态修改的范围。如果只是改动一个css的话，那么只是重绘一个元素，如果是在原来的地方加上一个元素的话，那么就是改变所有兄弟元素，会引发大量重绘。</li>
<li>在改变元素的时候，能改多深就改多深，这样越独立，对其他的节点影响越小。</li>
<li>如果要对dom操作的话，尽量合并到一次做完而不是奉承一次一次的做。css是我们改变dom的好伙伴。</li>
<li>浏览器的渲染页面是在渲染一系列的盒子，而且这些盒子里面还包括了许多其他的盒子。所以说我们浏览器的天然渲染模型是“很多盒子套许多盒子”，</li>
<li>完美实现这“盒子套盒子”的方法就是把一个或几个元素抱在一个大盒子里面。</li>
<li>渐进增强：</li>
<li>使用特征检测来显示渐进增强：不能用浏览器版本的检测来判断页面优化，而是要用特征检测：这样你可以检测是否有这个功能，悠久使用他，没有就给用户提供一个有吸引力的替代品。使用modernizr检测文档，开放者源码库</li>
<li>在任何时候都要尽可能的用css来完成交互，因为浏览器天生就可以处理它们，同时css的代码量要比js少很多。</li>
<li>性能准则：</li>
<li>cdn加速服务</li>
<li>页面加载时间，加载时间每延长100ms，销量就涨1%。</li>
<li>减少http请求：了解多少资源是可以一同加载的，（看苹果的网站：页面加载很快，其他资源是一组一组的加载，如何分组是根据浏览器能并行链接几个来决定的。可以把资源文件放置在不同的域名下，这种做法充分利用了浏览器并发）2:合并资源文件，大的文件比小的文件好，把内容尽可能的合并成较少的文件。图片精灵的好处是谁让你只是用了一小部分，但还是增长图片都被缓存好了，这样就不用每一次都去请求图片。</li>
<li>避免空的src和href属性，增加过期头，过期的日期要设置的非常远，那样浏览器就会缓存文件，第二次访问就会很方便。</li>
<li>Gzip压缩所有的文字代码，但不是图片。</li>
<li>避免使用css表达式，移除不用的css语句，不规定图片的宽和高（浏览器每次渲染都要猜，而且猜错的概率很大）浏览器在布局的好时候，会给每一个元素留下特定的位置，如果没有大小的话，只有来猜了。</li>
<li>提高开发效率：响应式网页设计</li>
<li>媒体查询功能:手机横，竖布局都要考虑到。。。我去。。。</li>
<li>自适应图片：img{max-width:40px}</li>
<li>弹性栅格：预先定义好者可以完美适应者鞋栅栏的样式，12个,classOne,classTwo,classThree———.</li>
<li>页面重用机制：</li>
<li><ol>
<li>所有看到的东西都是通过引擎绘制出来的，更新频率取决于开发者指定的FPS，帧数越高，视觉上感觉越流畅，60是满值。在实际运行情况中，性能还取决于JS解析器的效率，制定的FPS帧数可能在低性能解释器中得不到体现，所以这不是开发者所能决定的，说一只能做的是尽可能的优化代码，关注每帧执行逻辑代码带来的CPU消耗，好需要注意每帧调用回吐指令的数量以及CPu的纹理提交速度</li>
</ol>
</li>
<li>基准测试：实时监测当前性能。FPS越高越好。Sprite：渲染节点数量：越低越好</li>
<li>内存优化：对象池：涉及到不断重复使用的对象。在初始化应用的程序期间创建一定的数量的对象并将其存储在一个池中。对一个对象完成操作后，将该对象放回到池中，在需要新对象时可i对其进行检索</li>
<li>h5内嵌框架标签元素，iframe<iframe src="http://www.divcss5.com/" width="400" height="200" scrolling="yes">使用框架不利于网页搜索的优化。</iframe></li>
<li>闭合标签就是标签又开始，有结束</li>
<li>h5可以支持很多标签不闭合</li>
<li>无内容元素：是一种不能包含任何内容的特殊的元素，例如:br,hr,img,link,meta,area,base,col,command,embed,keygen,param,source,track,war,渊源：sgml时期有一种标签叫无尾标签，当一个标签内只有简单的文字的时候，就可以使用无尾标签无须闭合这个标签了。</li>
<li>接下来升级为无标签元素，<br>这样写起来自然，当h5的时候，他们是这样说的：HTML5 的语法完全兼容 HTML4 和 XHTML1，但是不兼容 SGML 中那些晦涩的 HTML4 特性。比如无尾标签（&lt;em/content/）。</li>
<li>自闭合标签到底要不要加／号，</li>
<li>创建按钮的四种方法<input type="button"> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><input type="submit"> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。<button> 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题。其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮.如果只是歌单纯的按钮，触发一些动画动作，那么button,当要把画面数据提交给服务器的submit。</button></li>
<li>button和input:button.在button内部，您可以放置内容，比如文本或图像。这是该元素与实用input元素不同的之处。button与button之间的所有内容都是按钮内容，其中包括可接受的正文内容，文本或者多媒体内容。需要注意的是要始终给她加上type属性，IE的默认类型是button而其他的浏览器着submit。</li>
<li>web安全色216种，</li>
<li>img上title和alt  title是在鼠标悬停上显示的内容，alt是在某种情况无法显示图片的情况下出现的信息。</li>
<li>网页字体用偶数不用奇数</li>
<li>网页元素</li>
<li>meta：位于文档的头部，定义了与文档相关联的元信息，这些元对象是以名称的形式成对定义的。一个页面可以定义多个meta标签，每个标签分别通过对应的name（关联到http头部）和content（把属性关联到一个名称）属性定义键值，来定义不同的原信息。</li>
<li>base指定所有页面中所有链接的基础路径。如果没有base的话，那么页面所有的相对路径将生成绝对路径作为默认的基础路径。</li>
<li>style的type 指定样式类型，浏览器支持的样式只有css一种，所以这个属性只有css一种，media属性置顶使用的媒体，表明文档在什么时候用什么元素定义的样式。</li>
<li>media属性详解：运算符 and,not ,or,</li>
<li>link:link和style 怎么结合起来用啊？link内部也有一些属性，media.</li>
<li>给网站添加logo。&lt;link rel=“shortcut icon” href=“” type=“image/x-icon”&gt;</li>
<li>预先获取资源：等同于让浏览器在空闲时间或预读取一些资源文档，不造成资源浪费。</li>
<li>link rel=“prefetch” href=“页面地址” 怎样控制什么时候开始。。</li>
<li>这是什么书？真是菜啊。。</li>
<li>异步执行脚本。方法：回调函数，事件监听，观察者模式，promise对象。</li>
<li>meta定义页面关键<meta name="“keywords”" content="“”">设置页面描述：<meta name="“description”" content="“输入内容"">都是为了搜索引擎，只是输入的字数限制不同。<meta name="“author”" content="“"">设置作者信息，<meta name="“robots”" content="“可选值”">：可以限制搜索网站方式，也就是把自己藏起来，</li>
<li>语言和文字:<meta http-equiv="“content-language”" content="“Zh-CN”/"></li>
<li>定时跳转页面：&lt;meta http-equiv=“Refresh” content=“10,url=http:www.baidu.com”&gt;也可以刷新网页</li>
<li>设置网页缓存过期的时间。</li>
<li>禁止从缓存中调用。</li>
<li>删除过期的cookie.</li>
<li>网页过渡效果：什么都可以，我去长见识了</li>
<li>标记文字</li>
<li>强调em.外文或科技术语i.重要的文字:strong.表示不正确和较正s.</li>
<li>为文字加下划线u.小号字体small.添上标sub.下标sup.</li>
<li>表示缩写abbr.定义术语<dfn title="“sdfsdf”">jlkjlklkjl</dfn>;</li>
<li>引用其他处的内容<q cite="“http://baidu.com”">sdkls<p></p>;</q></li>
<li>cite引用其他作品的标题。</li>
<li><ruby>漠&lt;&gt;</ruby></li>
<li>显示图像</li>
<li>图像预先加载</li>
<li>图像区域映射 <img><map>&lt;area shape=“circle coords=“0,100,200,30,9”&gt;</map></li>
<li>使用base64:url格式的图片。data取的数据的协定名称。就是代码表示一张图片，但是不能大于32k.高清图片不能显示，不可以裁成小段么？</li>
<li>生成超链接</li>
<li>指向外部的</li>
<li>使用相对url，相对路径和。绝对路径。</li>
<li>生成页面⚓️点</li>
<li>生成图像链接，电子邮件链接mailto</li>
<li>设定浏览环境——self当前页面打开，_blank创建新页面打开。</li>
<li>组织文字内容</li>
<li>pre：可以定义预格式化的文本。被包围在pre中的元素会保留空格和换行符。而文本也会呈现为等宽字体。pre标签的一个常见的应用就是来显示计算机的代码可以显示非格式化的内容。</li>
<li>应用他处内容block quote 他们之间的所有文本都会被从常规的文本中分离出来，经常会在左右两边缩进，而且有时会用斜体，也就是说，块引用有自己的空间。</li>
<li>dialog h5中用于定义对话框或窗口</li>
<li>划分文档结构：标题的使用是十分常见的，页面标题，模块标题，块区标题，各式各样的标题都可以使用h1-h6来实现。</li>
<li>hgroup 给标题分组隐藏起来，那就可以出现多个了。</li>
<li>section:对内容进行块划分，代码层次结构简单。在一个页面里面可以使用多个footer，既可以做页面的整体页脚，也可以做为一个内容区块的结尾。</li>
<li>语义化写代码article大段纯文字   附注栏：aside. </li>
<li>adress在页面输出联系人信息。</li>
<li>details summary 配合起来可以提供一个显示和隐藏文字的小工具。</li>
<li>使用下拉列表：label for=“sd”我最爱的球队 input type=“text” name=“team” id=“team_list”<pre><code>1. datalist id=“team_list&quot;
2. option edg
                        1. option rng但是这个怎么自动生成啊，这只能玩现成的？
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###dns预加载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;用meta信息来告知浏览器, 当前页面要做DNS预解析:&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="页面优化" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-浏览器缓存机制/</id>
    <published>2017-03-13T05:45:16.000Z</published>
    <updated>2017-03-13T05:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>1. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1. &lt;/p&gt;

    
    </summary>
    
    
      <category term="浏览器缓存机制" scheme="https://github.com/skoll1/libateer.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>面试html-css-2</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-%E9%9D%A2%E8%AF%95html-css-2/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-面试html-css-2/</id>
    <published>2017-03-12T08:08:01.000Z</published>
    <updated>2017-03-13T12:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>标准盒模型：外盒尺寸：h+p+b+m  内盒：h+p+b</li>
<li>ie:外盒h+mie 盒子模型的 content 部分包含了 border 和 pading,所以才是h+m</li>
<li>在网页上显示的时候：实际的占据位置和他的实际大小是不一样的，因为margin是看不到的。</li>
<li>在选择的时候，我们要用IE的标准盒子模型。在doctype中声明。如果不这样，那就会按照自己的默认方式去解析。</li>
<li>所以box-sizing:如果值为border-box的话，那就是IE那个样子解析的，如果是content-box的话，就是w3c的解析方式。</li>
<li>原来border一直都是跟随着padding在变，而margin择跟随border变。</li>
<li>Box-sizing统一form元素风格：、box-sizing拯救我们的布局</li>
<li>使用not()选择器来决定表单是否显示边框。为最后一个元素去掉边框。 .nav li:not(:last-child){border:1px solid red;}</li>
<li><p>更简单的垂直居中方式：align-items: center;display: flex;.container {<br>margin: 0 auto;就这几项。<br>}</p>
<ol>
<li>a[href]:not([class]) {<br>color: #008000;<br>text-decoration: underline;<br>}<br>给默认连接添加样式。通过cms系统插入的链接，通常没有class属性，以上样式可以甄别他们，而且不会影响其他样式。</li>
</ol>
</li>
<li>利用负的nth-child来选择元素。使用负的nth-child可以选择1-n个元素。</li>
<li>.container {   height: 0;   padding-bottom: 20%;   position: relative; }</li>
<li>.container div {   border: 2px dashed #ddd;    height: 100%;   left: 0;   position: absolute;   top: 0;   width: 100%; }子元素的div将保持宽高为1：5.</li>
<li><p>.slider {   height: 200px;overflow-y: hidden;width:300px;background-color: red;transition: all 0.3s ease; }<br>.slider:hover {  height: 300px;  overflow-y: scroll;background-color: yellow;}模拟滑块的划动。</p>
</li>
<li><p>img {<br>display: block;<br>font-family: Helvetica, Arial, sans-serif;<br>font-weight: 300;<br>height: auto;<br>line-height: 2;<br>position: relative;<br>text-align: center;<br>width: 100%;<br>}<br>img:before {<br>content: “We’re sorry, the image below is broken :(“;<br>display: block;<br>margin-bottom: 10px;<br>}</p>
</li>
</ol>
<p>img:after {<br>  content: “(url: “ attr(src) “)”;<br>  display: block;<br>  font-size: 12px;<br>}图像没显示的时候的处理方法。</p>
<ol>
<li>当触发select的下拉列表时，为了避免表单元素在移动浏览器（IOS Safari 等等）上的缩放，加上font-size：</li>
</ol>
<p>input[type=”text”],<br>input[type=”number”],<br>select,<br>textarea {<br>  font-size: 16px;<br>}</p>
<p>###icon字体进化###</p>
<ol>
<li>四种字体格式，eot微软，woff,web最佳字体。ttf,mac和微软操作系统最常见的字体。</li>
<li>svg：由w3c指定的开放的标准的图形格式。</li>
<li>可以通过在标签里面添加before来插入小图标。那个输入就在content里面，但是为设么这样做也能实现前面的css控制呢？</li>
<li>node.js优势。高并发，聊天，实时推送。</li>
<li>doctype标签是一种标准通用标记语言的文档类型声明，她的目的是告诉通用标记语言文档解析器应该用什么样的文档类型定义来解析文档。他是将特定的标记通用语言或者XML文档与文档类型定义联系起来的指令。他出现在文件的第一行。只有确定了一个正确的文档类型，超文本标记语言或者可扩展超文本标记语言中的标记和层叠样式标才能生效，甚至对JS脚本都有影响。</li>
<li>严格模式是浏览器根据规范去显示页面；混杂模式是以一种向后兼容的方式去显示，决定浏览器如何渲染网站即浏览器使用哪种规范去解析网页。她的触发是根据doctype是否存在和使用的那种dtd来决定。mozilia ,safair还有一种“几乎标准模式”，除了在处理表格上的方式有一点细微的差异之外。其他都不变。</li>
<li>dtd文档定义类型document type definition 是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。是标准通用标记语言和可扩展语言的一部分</li>
<li>空元素img ,input,br,hr,</li>
<li><ol>
<li>h5不基于sgml，因此不需要对dtd引用，当需要doctype来规范浏览器的行为，让浏览器按照她们的应该的方式运行。</li>
</ol>
</li>
<li>h5基于什么机制实现运行？既然他不基于sgml.沿用了h5的语法，过去的是sgml语法的一个子集，更简洁，更人性化。</li>
<li>link在页面载入时加载css，而@是在网页完全载入以后加载</li>
<li>ink,@import url() .link是xhtml标签，除了加载css时间外，还可以定义rss等其他事件，@只能加载css。</li>
<li><ol>
<li>link是xhtml标签，没有兼容问题，而@低版本浏览器不支持。</li>
</ol>
</li>
<li>link支持js改变dom去改变样式，而@不支持</li>
<li>ie:trident 三叉戟</li>
<li>firfox:gecko 壁虎。</li>
<li>　<a href="download_pdf.php" download="somefile.pdf">下载PDF文件</a></li>
<li><ol>
<li>命名规则：BEM高级别的类。，元素，修饰符代表状态。<br>.site-search{} /<em> 块 </em>/<br>.site-search__field{} /<em> 元素 </em>/<br>.site-search–full{} /<em> 修饰符 </em>/</li>
</ol>
</li>
<li>使用bem的诀窍是，你要知道是什么时候要写成bem格式。因为某些东西确实是位于一个块内的内部，但这并不意味着他就是bem所说的元素。</li>
<li>遵循单一功能，意味着每一个模块内斗应该有一个单一的功能，并且应该由这个类完全分装起来，单一的原则意味着每一段代码，类，模块都只做一件事。当我们提交css文件时，意味着每隔独立的组建，都应该有自己的 css文件。</li>
<li>position 和display margin collapse overflow float这些特性叠加后的会怎样？</li>
<li>1.<br>bfCbox：css布局的对象和基本单位，一个页面就是有很多个box组成的，元素的类型和isplay属性，决定了这个盒子的布局类型。。不同的盒子会参与不同的文档渲染流程，因此，box内的元素会以不同的方式渲染。</li>
<li>bfc布局规则，内部的box会在垂直方向上，一个接一个的放置。box的垂直方向的距离由margin 决定，属于同一个的bfc的两个相邻的box的margin会发生重叠。</li>
<li>bfc就是页面上的一个隔离的独立容器，容器的元素不会影响到外面的雨啊怒，反之亦然。</li>
<li>会生成bfc的元素有这些?根元素， float元素！＝none，position=absolute,fixed，display=inline-block,table-cell,table-caption,flex,inline-flex.over!=visible.每个元素的margin-box左边，与包含块border-box的左边相接触，即使存在浮动也一样。</li>
<li>m是用来隔开元素和元素之间的距离，padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素之间互不相干，padding用来元素与内容之间的间隔，让内容和元素之间由一段呼吸距离。</li>
<li>最根本的区别：是否创造了新的元素：需要在新添加元素加以标示的，就是伪元素，如果在既有元素上添加类名，就是伪类，伪元素表示某个元素的子元素，他们虽然理论上出现，但是实际上并不存在于文档树中。</li>
<li>伪类用一个冒号表示，伪元素用两个表示加以区分。</li>
<li>html只能表示12-16的字体，以上的字体锯齿大到没朋友，16以上的都用图片表示</li>
<li>浮动的历史：包裹特性：bfc块级格式化上下文。</li>
<li>浮动具有破坏性。会让父级元素塌陷。</li>
<li>浮动原来的作用是实现文字环绕。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;标准盒模型：外盒尺寸：h+p+b+m  内盒：h+p+b&lt;/li&gt;
&lt;li&gt;ie:外盒h+mie 盒子模型的 content 部分包含了 border 和 pading,所以才是h+m&lt;/li&gt;
&lt;li&gt;在网页上显示的时候：实际的占据位置和他的实际大小是不一样的
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="面试html-css-2" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%9D%A2%E8%AF%95html-css-2/"/>
    
  </entry>
  
  <entry>
    <title>css-代码案例</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-css-%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-css-代码案例/</id>
    <published>2017-03-12T05:57:05.000Z</published>
    <updated>2017-03-12T06:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>####做页脚效果：让网页的footer始终位于浏览器串口底部###</p>
<ol>
<li><p><code>html, body {
height: 100%;
margin: 0;
}  
.wrapper {
min-height: 100%;
margin-bottom: -50px;
}
//这个不就是那那个margin-bottom改变下一个元素的参考位置么？主要是min-height:100%;
.footer{
height: 50px;
background-color: red;
}</code></p>
</li>
<li><p><code>&lt;div class=&quot;wrapper&quot;&gt;
   content
 &lt;div class=&quot;push&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</code>主要是必须有push结构</p>
</li>
<li><p>方法一的变形：html, body {<br>height: 100%;<br>margin: 0;<br>}<br>.content {<br>min-height: 100%;<br>}<br>.footer {<br>height: 50px;<br>margin-top: -50px<br><code>&lt;div class=&quot;content&quot;&gt;
 &lt;div class=&quot;content-inside&quot;&gt;
   content
 &lt;/div&gt;
&lt;/div&gt;
&lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</code></p>
</li>
</ol>
<ol>
<li><code>*{margin: 0;padding: 0;}
html {
height: 100%;
}
body {
min-height: 100%;
display: flex;
flex-direction: column;
}
.content {
flex: 1;
}
.footer{
background-color: red;
}</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####做页脚效果：让网页的footer始终位于浏览器串口底部###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;html, body {
height: 100%;
margin: 0;
}  
.wrapper {
min-height: 100%;
margin-bo
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="css-代码案例" scheme="https://github.com/skoll1/libateer.github.io/tags/css-%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/11/best-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/11/best-1-面向对象/</id>
    <published>2017-03-11T11:55:48.000Z</published>
    <updated>2017-03-13T04:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>对象的情况和数组很相似，只是他的键值类型是自定义的，也就是我们常说的索引方式不再局限于数字了，可以使用一些更加人性化的键值。也就是我们用数组来表示索引型数组，而用对象表示关联性数组</li>
<li>访问对象的方式/.[]如果我们访问的属性名字是不确定的就必须要用中括号来表示，它允许我们在运行的时候通过相关的变量来实现先关属性的动态属性的存取。</li>
<li>可以使用一些很奇怪的属性名字，但是遇到保留字的情况要加上‘’这个</li>
<li>构造函数的方式来创建对象：也就引出了创建对象的方式：工厂的方式，构造函数方式，原型方式，混合的构造函数，原型方式：function Parent(){<br>this.name=”脚本”;<br>this.age=4;<br>};<br>Parent.prototype.lev=function(){<br>return this.name;<br>};;<br>var x =new Parent();<br>alert(x.lev());</li>
<li>function hero(name){this.name=name};</li>
<li>var hero=new hero(“hah”);</li>
<li>hero.name</li>
<li>实质：创建一个新的对象，使this指向新的对象，</li>
<li>新对象的prototype指向构造函数的prototypr，返回this，所以创建的实例的实质是获得了一个引用实现原型链的继承。</li>
<li>全局变量只不过是全局对象的属性罢了。这就是实质window,document</li>
<li>如果我们定义了一个构造函数又不应new来调用，那么就会返回unefined，如果我们使用###new###来创建对象，那么this就会指向这个该对象。</li>
<li>insatnceof操作符还可以干这个测试某个属性是不是由某个构造函数的的构造属性。function hero(name){this.name=name};</li>
<li>var h=new hero(“xixi”);</li>
<li>var result=h instanceof hero;</li>
<li>result</li>
<li>直接使用=号，当我们拷贝某个对象或是将它传递给某个函数时，旺旺都是传递的某个对象的引用。因此我们在拷贝上做任何的改动，都会影响原对象的值。</li>
<li>内建对象的三种分类：数据封装类函数：，工具类函数。错误对象类函数。</li>
<li>引用类型不在变量中保存对象，所以本例中的object()实际上并不包含独享的，而是一个指向内存中实际对象所在位置的指针。这是对象和原始值得一个基本差别。</li>
<li>就像他们复制拷贝的时候的差别b获取值是a值的一份拷贝，虽然，两个变量的值是相等，但是两个变量保存两不同的基本数据类型值。b只是保存了a复制的一个副本。所以，当b的值改变时，a的值依然是10;<br>下面，两个Boolean变量bl和bl1同样是基本数据类型，同样保存两个不同的基本数据据类型值，bl1保存bl复制的一个副本。而对于对象来说：我们声明了一个引用数据类型变量obj1，并把它赋值给了另外一个引用数据类型变量obj2。当我们obj2添加了一个name属性并赋值”我有名字了”。obj1同样拥有了和obj2一样的name属性。说明这两个引用数据类型变量指向同一个堆内存对象。obj1赋值给obj2，实际只是把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象。</li>
<li>两个对象之间的原型关系类似于继承，每个对象都可以把另一个对象作为他的原型，并继承原型的所有属性。对象通过内部属性[prototype]指定他的原型。每个对象都有这个属性，而他可以是null，通过prototype属性连接成的对象称为原型链</li>
<li>js的值可以在不同的框架之间穿来穿去，当你试图去鉴别一个弱类型的，因为每一个页面都有自己的上下文全局，当把一个数组从一个框架传到另一个框架的时候，instanceOf就无法识别，因为那个数组是来自不同框架之间的Array()，所以就要用Array.isArray()函数了。</li>
<li>函数就是对象，使他区别于其他对象的一个最重要的特点就是函数存在一个被称为[[call]]的内部属性，他不可以被代码访问到，但是定义代码的执行行为。</li>
<li>把那些看起来名字超级Nb的东西搞懂真的很有成就感。</li>
<li>js根据参数的不同类型决定执行的版本就叫做函数重载，但在JS中可以接受任意数量，类型的函数，所以根本不存在重载，但是我们可以根据参数的一些特性来模拟决定函数执行从而模拟其行为。</li>
<li>当一个属性第一次被添加给一个对象时，Js在对象内调用了一个[put]方法，[put]方法会在对象上创建一个新的节点来保存对象，这个操作不仅指定了初始值，而且也定义了一些属性。注意这个创建的是自有属性，所有对他的操作都必须通过该对象才行。【set】方法是将属性的当前值替换为新值。</li>
<li>如果想要删除一个属性必须用delete,其他的都是简单的覆盖</li>
<li>检查对象里面有没有属性的方法；in hasOwnProperty()这个只能检查自有属性，不能检查继承来的;还有一一个就是所有检查的属性必须加上双引号。for(var i in p){console.log(i);}这个也可以。Object.keys(p);返回的是可枚举的属性。</li>
<li>上面的组合：通过组合hasOwnProperty()方法和in操作符，就可以区分该属性是否存在于原型中。for-in循环与hasOwnProperty()方法输出对象的原型属性。使用in操作符判断某个属性是否存在于对象的实例或原型中。使用for-in循环输出对象所有可枚举的实例属性与原型属性</li>
<li>实例属性指的是在构造函数方法中定义的属性，属性和方法都是不一样的引用地址例如。。。原型属性指的是不在构造函数中定义的属性，属性和方法都是一样的引用地址，例如function CreateObject(){}<br>CreateObject.prototype.name=’ZHS’;</li>
<li>对象的访问器属性：包含getter和setter函数。读取访问器属性时，调用getter函数，返回有效的值；在写入访问器属性时，调用setter函数传入新值。它包含了4个特性： </li>
<li>[[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 </li>
<li>[[Enumerable]]：表示能否用for-in循环返回。 </li>
<li>[[Get]]：读取属性时调用的函数，默认undefined。 </li>
<li>[[Set]]：写入属性时调用的函数，默认undefined。</li>
<li>访问器属性甚至包括上面这些都无法直接被定义只能使用函数来修改或访问：var person = {<br> age:100<br>};</li>
</ol>
<p>Object.defineProperty(person,”name”,{<br>    configurable:false,能否删除这个属性，能否修改这个属性，能否把这个属性改为访问器属性。<br>    writable:false,<br>    value:”xiaochang”<br>})</p>
<ol>
<li>另外需要注意的是当configurable设置为false后无法再将其改为true，且除了writable之外，无法修改其它特性。在configurable为true的情况下可多次调用Object.defineProperty( )修改同一属性。</li>
<li>访问器属性：包含getter和setter函数。读取访问器属性时，调用getter函数，返回有效的值；在写入访问器属性时，调用setter函数传入新值。它包含了4个特性： </li>
<li>[[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 </li>
<li>[[Enumerable]]：表示能否用for-in循环返回。 </li>
<li>[[Get]]：读取属性时调用的函数，默认undefined。 </li>
<li>[[Set]]：写入属性时调用的函数，默认undefined。</li>
<li>Object.defineProperties(person,{<br> name:{<pre><code>get:function(){
    return this._name;
}
</code></pre> },<br> age:{<pre><code>set:function(newage){
    this._age = newage;
}
</code></pre> },<br> tel:{<pre><code>get:function(){
    return this._tel;
},
set:function(newtel){
    this._tel= newtel;
}
</code></pre> }<br>});</li>
</ol>
<p>6.</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;对象的情况和数组很相似，只是他的键值类型是自定义的，也就是我们常说的索引方式不再局限于数字了，可以使用一些更加人性化的键值。也就是我们用数组来表示索引型数组，而用对象表示关联性数组&lt;/li&gt;
&lt;li&gt;访问对象的方式/.[]如果我们访问的属性名字是不确定的就必须要
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>css-基础</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-CSS基础/</id>
    <published>2017-03-10T15:30:02.000Z</published>
    <updated>2017-03-11T10:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>小东西：淘宝，搭配，比较-游戏-社交-好的一部分-商品评论</li>
<li>你给我一个目标，我会马上调动我的知识库帮你完成这个，扩展，用某种观点。</li>
<li>字体–font-style:让字体变斜就这个。</li>
<li>font-weight:粗细就看这个</li>
<li>font-stretch:chrome不支持</li>
<li>@font-face{<br> font-family:’iconfont’;<br> src:url(‘’);<br>}引入字体。</li>
<li>font-varight:今年仅针对字母：小型的大写字母。</li>
<li>text-transform:也是和字母有关系，将第一个值变成大写字母，全变成大写，全变成小写。</li>
<li>white-space:和文字空间有关系的。pre:不会合并文字间的空白，超出边界不换行只会显示一行。nowrap:合并文字间空格，只会显示一行。pre-wrap:不合并空格，但是会发生换行碰到边界。pre-line:会合并空格，也会换行。</li>
<li>word-space:单词之间的间距,在这个测试里好像他完全是以空格来区分单词的，不论是汉字还是英文。</li>
<li>letter-space:字符之间的间距</li>
<li>text-indent:文本缩进。</li>
<li>word-break:break-all;word-wrap:break-word;想要节省地方，这么写就对了。</li>
<li>text-align-last:只对最后一行做这个属性设置</li>
<li>text-justify:类似于flex那种对齐方式，但是没什么卵用，好多浏览器不支持。</li>
<li>vertical-align:他的百分比是按照line-height计算的。</li>
<li>vertain—align：起作用的前提是他的元素是inline属性才行。inline-block.table-cell()简单来说就是图片，按钮，文字和单元格。这只是在默认的情况下，当给他设置属性的时候或者使用浮动以后，那就不能显示了。`.test&gt;span{<pre><code>    display: inline-block;width: 210px;vertical-align: middle;
}
.test&gt;img{
    vertical-align: middle;
    width: 300px;
    height: auto;
}`
</code></pre></li>
<li>text-size-adjust:auto;文字根据设备大小自动调整</li>
<li>text-decoration:怎么改下划线加颜色啊。text-decoration-color: #f06d06;这个好像不能显示，只能和color共用一个颜色。</li>
<li>writing-mode:实现文字的排列</li>
<li>只要你是内联元素，你就受到vertain-align和line-height的影响。</li>
<li>行高是字符大小乘百分比。</li>
<li>定位position:staticabsolute,relative,center,fixed;</li>
<li>布局：display:inline,block,flex,inline-felx,table</li>
<li>display:none;彻底消失，原来是位置也腾出来。visibilty:hidden.就是简单的影藏，原来的位置还在。</li>
<li>margin:相邻的margin会发生合并，我们称之为margin折叠。折叠只会发生在block元素。浮动元素的margin不发生任何折叠。根元素，绝对定位的元素也不发生折叠。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;小东西：淘宝，搭配，比较-游戏-社交-好的一部分-商品评论&lt;/li&gt;
&lt;li&gt;你给我一个目标，我会马上调动我的知识库帮你完成这个，扩展，用某种观点。&lt;/li&gt;
&lt;li&gt;字体–font-style:让字体变斜就这个。&lt;/li&gt;
&lt;li&gt;font-weight:粗细
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="css-基础" scheme="https://github.com/skoll1/libateer.github.io/tags/css-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网站代码分析</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-网站代码分析/</id>
    <published>2017-03-10T15:22:43.000Z</published>
    <updated>2017-03-12T06:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>###bootstrap###</p>
<ol>
<li><ol>
<li>书写格式</li>
</ol>
</li>
<li>.btn-default</li>
<li>badge:内联样式，徽章</li>
<li>hover,focus用一个属性</li>
<li>text-size-adjust:文字会根据设备的不同自动调整。</li>
<li>details标签可以和summary配合实现手风琴效果</li>
<li>template声明模板元素；</li>
<li>don：对特殊语或者短语的定义可以用dfn括起来。</li>
<li>mark突出显示的文本。。我去这个属性了</li>
<li>取得名字：navbar</li>
<li>为什么他的代码格式那么简单，嵌套关系也没那么复杂。</li>
<li><blockquote>
<p>这是什么意思,表示从属关系都是这样的来用的。</p>
</blockquote>
</li>
<li>tr.info是指的自己的还是他下面的子元素呢？</li>
<li>下面的子元素都加上他的父元素的名字—-这样就简单多了。还可以表示关系。</li>
<li>一个页面需要的css</li>
<li>margin-right:负值是什么意思？</li>
<li>output输出标签。</li>
<li>自适应品均分配用的是百分比，想分几份就除几。</li>
<li>left,right,margin-left,margin-right.还可以像上面那样加半分比，是位置么？</li>
<li>*.html,body,input,button,select,textarea, a,figure,img,hr,</li>
<li>:focus{border-color,outline,box-shadow,}</li>
<li>::后面加尾类元素-ms-input-placeholder{}-webkit-input-placherholder{}</li>
<li>还是语义化起名字看起来，input-lg/has-success .help-block.就是那种你直接看css都可以知道你的样式是什么样。</li>
<li>到底是要一个一个的看属性呢？还是结合具体问题看实践。两个都来吧？在做东西的时候自己用到的争取都弄明白。。</li>
<li>pre:定义预格式化文本，显示特殊符号。<ol>
<li>appearance：使元素看上去向某个东西：button,icon,window,menu.</li>
<li>orphans:设置或检索对象内容内一定要留在一页范围地段以内的行的最少数量</li>
</ol>
</li>
</ol>
<p>   ###火狐###</p>
<ol>
<li>主体结构：window- browser - html—head-body-script <ol>
<li>head;</li>
<li>body:div-script;</li>
<li>div-header/dir/footer</li>
<li>header-layout-fleft/fright</li>
<li>fleft-logo-top/bottom   div-p-a/span</li>
<li>dir-left-banner/menu</li>
<li>css命名规范：<br>###淘宝###</li>
</ol>
<ul>
<li>div+p+gq</li>
<li>div&gt;p&gt;span+em</li>
<li>ul&gt;li.item$*5</li>
<li>form#search.wide</li>
<li>p.class1.class2.class3</li>
<li>ul&gt;.class</li>
<li>table&gt;.row&gt;.col自动补全结构</li>
<li>a:link</li>
<li>a:mail</li>
<li>link:css</li>
<li>link:favicon</li>
<li>meta:vp</li>
<li>script:src</li>
<li>form:get</li>
<li>inp</li>
<li>input:t</li>
<li>input:time</li>
<li>btn:b</li>
<li>btn:r</li>
<li>btn:s</li>
<li>ol+</li>
<li>ul+</li>
<li>table+</li>
<li>select+</li>
<li>cc:ie6<br>####知乎###</li>
</ul>
<ol>
<li><ol>
<li>首先就是在html那块还加了一堆class.</li>
</ol>
</li>
<li>在head里面也加了一堆页面内的样式。style.</li>
<li>Logo一般都是用a装的。<a href="“/“"></a></li>
<li>可能要转到下一页的都用a标签，</li>
<li>汉字一般用span装。</li>
<li>下面可能出现的东西就要用ul ，li，装了，这些都是，然后a里面的汉字用i标签来装。</li>
<li>图标的东西都要用i</li>
<li>可以表示为列表的都要用ul li</li>
<li>A 可以用来表示，出现一个“新动态”，“加载中”。利用这个来加载新的东西。</li>
<li>Span还可以加小圆点来</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###bootstrap###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;书写格式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;.btn-default&lt;/li&gt;
&lt;li&gt;badge:内联样式，徽章&lt;/li&gt;
&lt;li&gt;hover,focus用一个属性&lt;/li&gt;
&lt;li&gt;te
    
    </summary>
    
    
      <category term=" 网站代码分析" scheme="https://github.com/skoll1/libateer.github.io/tags/%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>自适应页面</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-自适应页面/</id>
    <published>2017-03-10T15:18:38.000Z</published>
    <updated>2017-03-11T11:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>box-sizing:border-box;</li>
<li>background-size:修改背景图片的唯一办法。可以使用多个背景图片，会带来意想不到的效果。</li>
<li>3个角度来考虑设计方案。</li>
<li>web design</li>
<li>meta标签。主要思想。调整列，弹性宽度，紧缩空白空间，调整字体大小，修改导航菜单。隐藏一些内容。</li>
<li>如何创建断点：也就是替换样式表的时候。（打开自适应设计，不断调整窗口大小，发现不美观的时候就可以了）</li>
<li>怎样替换载入样式表么？</li>
<li>media可以识别别的属性限制么？媒体查询支持的其他属性</li>
<li>弹性玩网格：宽度。100%。桌面：max-width:    布局的每一个列都应该用百分比。</li>
<li>HTML源代码的顺序的重要性，因为手机列显示的时候，可能是把float属性改一下。</li>
<li>自适应的图片问题：</li>
<li>只要你没有给每一个设计元素设计精确元素，宽度，高度，和位置，就会发现css定位属性是如此的强大，这些属性可以把蚊子显示在图片上，把LOGO放在网页的任何位置上。</li>
<li>绝对定位可以脱离文档流，以至于网页上的其他元素甚至不知道这个元素的存在。</li>
<li>相对定位：网页上的其他元素不会占用相对定位原来在HTML的位置。</li>
<li>浏览器兼容方法。</li>
<li>.img-wrap img{</li>
<li>max-width: 100%;</li>
<li>height: auto;</li>
<li>/<em>那就是可以实现自己的自适应轮播图了吧</em>/</li>
<li>}</li>
<li>基于cookie以及js的响应式图像。在服务器端根据用户的请求返回特定的图片</li>
<li>自适应视屏：在页面是可以支持百分比的，如果服务器端有类似的视屏那就更好了。</li>
<li>bili没有自适应视屏，只有两个格式，全屏和变小那个，先找到主要的东西展示出来，在小得时候把全部的信息给出来，然后你再自己变大看主要的，在变大的时候还可以加上自己想要展示的小的东西。</li>
<li>video{</li>
<li>max-width: 100%;</li>
<li>height:auto;</li>
<li>}</li>
<li>视屏托管网站比放自己托管更加安全，自己可能受到带宽的货磁盘空间的限制。这是通过iframe实现，如果是应用地址的话，使不得在他的网站打开这个啊。好像没有那个问题啊。</li>
<li><embed height="515" width="700" quality="high" allowfullscreen type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=7382789&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></li>
<li>基于媒体查询的图像图像。在客户端调整选取图像，还是那个服务器的好，但是要是按照一开始的加载的来看的话。</li>
<li><form action=""></form></li>
<li><select name="URL" onchange="location.href=this.form.URL.options[this.form.URL.selectedIndex].value"></select></li>
<li><option value="1.html">1</option></li>
<li><option value="2.html">2</option></li>
<li><option value="3.html">3</option></li>
<li></li>
<li>用这样的的来组织一个小的nav</li>
<li>图像padding还得自适应。</li>
<li>Em</li>
<li>html{</li>
<li>font-size: 12px;</li>
<li>}</li>
<li>p{</li>
<li>font-size: 3rem;</li>
<li>}这个还得用media查询来区分，这样也太菜可呗。</li>
<li>不能再外面的加一个固定的，在里面的加上百分比。</li>
<li>css3d文字</li>
<li>0px 0px 0px #666,</li>
<li>-1px -1px 0px #666,</li>
<li>-2px -2px 0px #666,</li>
<li>-3px -3px 0px #666,</li>
<li>-4px -4px 0px #666,</li>
<li>-5px -5px 0px #666,</li>
<li>-6px -6px 0px #000,</li>
<li>1px 1px 5px #ccc,</li>
<li>2px 2px 5px #ccc,</li>
<li>3px 3px 5px #ccc,</li>
<li>4px 4px 5px #ccc,</li>
<li>5px 5px 5px #ccc,</li>
<li>6px 6px 5px #ccc,</li>
<li>0px 0px 0px #888,</li>
<li>-1px -1px 0px #777,</li>
<li>-2px -2px 1px #666,</li>
<li>-3px -2px 1px #555,</li>
<li>-4px -4px 2px #444,</li>
<li>-5px -5px 3px #333,</li>
<li>-6px -6px 4px #000;就是在最后加个分号。。。</li>
<li><meta name="viewport" content="initial-scale=1 maximum-scale=1 minmum-scale=2"></li>
<li>响应设计始终就是内容优先（相对于那些侧边栏，导航栏）</li>
<li>所有伟大的设计或思想，都会卷土重来。</li>
<li>响应设计需要百分比布局</li>
<li>百分比布局创建的弹性界面，同时使用媒体查询限制元素的变动范围。主要是相对于左右百分比。</li>
<li>响应式设计网站欣赏借鉴？最好就是看写的东西。</li>
<li>目标元素宽度%上下文宽度=百分比宽度  每个元素加完这个，还在内部加margin-left/right 这个还得计算</li>
<li>1：1.61803398874989 黄金比例，网页设计也最好不要四舍五入</li>
<li>界面元素的排列也可以用mar-l//r百分比。但是要注意相对父级元素。</li>
<li>用em代替px，body设置文字大小为100%.其他用相对单位em,改用body,其他也会相应得度。</li>
<li>目标元素尺寸%上下文尺寸元素尺寸=百分比尺寸</li>
<li>h1span</li>
<li>span的文字大小是相对于父级元素文字大小，而他的行高是相对于自己的文字大小的。所有单位是em</li>
<li>图片适应</li>
<li>现代浏览器十分简单：img video embed{max-width:100%};</li>
<li>为特定图片制定特定规则。额外添加特定的规则。额外添加一个新的class，{max-weidth:45%}</li>
<li>为了防止图片变形：让他绝对不能超过max-width:属性</li>
<li>为了页面无限扩张：给最外侧的div加{max-width:1414px;}</li>
<li>刷新页面：live,.js</li>
<li>设置只适应图片</li>
<li>字体设置一定要加font-size</li>
<li>看css 3d.</li>
<li>css 变形 、过度，动画</li>
<li>表单：modernizr:可以按需加载js.</li>
<li>响应式设计：将三种已有的开发技巧（弹性网格布局，弹性图片，媒体查询）</li>
<li>真正响应设计方法不仅仅只是根据视口大小改变网页布局。相反，我们应该首先针对小屏幕进行设计，然后足部增大对屏幕的设计和内容、</li>
<li>他只是一种根据不同设备内容进行完美布局的一种显示机制。相反，如果需要根据不同设备提供特定内容的功能，那就需要一个真正的手机版网站</li>
<li>www.mediaqueri.es</li>
<li>媒体查询能够检测那些属性。视口宽度和屏幕宽度。</li>
<li>移动设备在任何时候都要想到文字输入的困难。</li>
<li>在小屏幕中去除那些不必要的杂乱元素，在大屏幕中突出控件和增强式导航。</li>
<li>要时刻质疑开发过程中是否简化了界面，设计师非常容易陷入增加新设计的误区。</li>
<li>可以先体验些没有被优化的应用来决定自己的下一步操作。</li>
<li>真正的响应式设计不是根据视口来改变网页布局，而是我们首先针对小屏幕进行设计，然后逐步增加对大屏幕的设计和内容。</li>
<li>对于inline元素来说，水平padding产生影响，垂直padding不影响。padding: 41%;<br>display: inline;</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;box-sizing:border-box;&lt;/li&gt;
&lt;li&gt;background-size:修改背景图片的唯一办法。可以使用多个背景图片，会带来意想不到的效果。&lt;/li&gt;
&lt;li&gt;3个角度来考虑设计方案。&lt;/li&gt;
&lt;li&gt;web design&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="自适应页面" scheme="https://github.com/skoll1/libateer.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>战争的逻辑--普鲁士到德国崛起</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-3-%E6%88%98%E4%BA%89%E7%9A%84%E9%80%BB%E8%BE%91-%E6%99%AE%E9%B2%81%E5%A3%AB%E5%88%B0%E5%BE%B7%E5%9B%BD%E5%B4%9B%E8%B5%B7/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-3-战争的逻辑-普鲁士到德国崛起/</id>
    <published>2017-03-10T14:32:27.000Z</published>
    <updated>2017-03-11T08:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>没有什么东西能够够比陆军和海军更加依赖经济前提。一发炮弹是那个时代农民五年的收入<br>2.一旦技术上的进步可以用于军事并且已经用于军事目的，他们便立刻几乎强制的。而且往往是违反指挥官意图而引起作战方式的改变甚至是变革。随着技术武器的出现，将再也不可能出现落后文明对高等文明的征服，也就是说，类似与成吉思汗之类的草莽英雄再也不会回来了。 </li>
<li>对于其他国家来说，是国家拥有一支军队，而对于普鲁士来说，是一支军队拥有一个国家。</li>
<li>民族认同感并不是凭空来的，是在被侵略的时候来的，德国的民族意识觉醒就是在拿破仑的铁蹄下瑟瑟发抖的时候。</li>
<li>在耶拿会站的时候，拿破仑不仅毁灭了一个封建陆军，而且也肃清了封建观念最后的灰烬，但是在这灰烬里确诞生了一个新的民族陆军，终于在莱比西会战中把自己打败了。德意志也将在民族主义下开始统一。</li>
<li>赎罪券：德意志被称为“教皇的奶牛”.</li>
<li>1685年的时候就发现：政治分裂导致的市场狭小，这与资本主义大工业的生产方式是由根本矛盾的。</li>
<li>德国统一是在匹斯麦的领导下的。当代重大问题不是靠演讲和多数会议解决的，而是要通过铁和血才能解决。</li>
<li>嘉斯泰公约只不过是一张遮盖裂缝的糊墙纸。<br>10.普鲁士和奥地利打在一起是普鲁士想要同一德国。但是当时奥地理在联邦里有很大的威信<br>11.他骑在<pre><code>  .-&apos; _..`.
 /  .&apos;_.&apos;.&apos;
| .&apos; (.)`.
;&apos;   ,_   `.
</code></pre>.–.<strong><strong>__</strong></strong>.’    ;  <code>.;-&#39;
|  ./               /
|  |               /</code>..’`-.<em>  <em>__</em></em>, ..’<br>  / | |     | |\ \<br> / /| |     | | \ \<br>/ / | |     | |  \ \<br>/<em>/  |</em>|     |<em>|   \</em>\<br>|<strong>\  |</strong>\    |<strong>\  |</strong>\上看着山脚下数十万的士兵厮杀在一起，在回忆录中他这样写到，当时好像在玩一场扑克牌，把不属于自己的100万塔勒孤注一掷，甚至传言他还携带了一瓶毒药，准备在普军这一场“不得人心的”战争失败之后自杀。</li>
<li>在大败奥地利的时候，他却坚决的与奥地利签订宽大的条约，假如奥地利遭受严重的损失，那可能成为法国或是我们一个敌人的盟友。。要尽可能的防止奥地利造成屈辱的回忆，普鲁士军队进入帝国首都可能会给我们留下美好的回忆，但是对我们的政策并无必要，但是要使奥利利的自尊受损，那么只会给以后的关系增加困难。</li>
<li>他达到政治目的之后便戛然而止，绝不允许所谓的胜利果实妨碍他的政治目的，作为一个成熟的政治家，匹斯麦始终把军事力量当成实现政治目的工具加以运用，更难得可贵的是他对军事力量的克制，使军事力量始终服从与政治需要而不相反。</li>
<li>后勤补给的因素：国内畜力运送，抢劫：温柔的，土匪式的。</li>
<li>中国无法解决四轮车转向的问题，所以很多的时候都是用两个轮子拉。</li>
<li>铁路的作用：第一次世界大战中威廉二世要求德军总参谋改变作战计划这也是不可能的了，所有的军队调动都已经按照运输能力做了最好的调度安排。一旦改变就引起巨大的混乱。</li>
<li>如果有好的机会，我也许会创业，但是如果没有好的机会的话，也许我会成为一个人生最好的掌舵手，帮他认清自己和目标的反向。</li>
<li>火门枪:一分钟一发，100米的射程。而且还是提前的装枪，也就是说一个枪手只有一次的机会。</li>
<li>手枪的出现极大地改变了战争的形态，从此类似于成吉思汗的草莽英雄再也不能出现了，决定战争的不是士兵的勇敢和智慧，而是双方的生产能力，手枪的结构不是复杂，却需要强大的工业作为支撑。</li>
<li>我们的军队一切准备就绪。一直到最后一个士兵的鞋套上的最后一个纽扣。</li>
<li>法兰西第二帝国–法兰西第三共和国</li>
<li>两个爱好一样的人—记录—搜索—聊天—排行榜。</li>
<li>德意志联邦————德意志帝国————此时早已赶走了奥地利（奥地利+匈牙利）。</li>
<li>此前是法国一家独大：一个流传甚广的笑话是这样说的。从此欧洲收了一个女管家，来了一个男主人。</li>
<li>普法战争的演变：从德国对法国的侵略变成法德两国对欧洲霸权的争夺。</li>
<li>从此德国和发过结下了世仇：7.5亿白银。阿尔萨斯和洛林。无法化解的仇，所以尽可能的削弱法国。</li>
<li>德国：不强大到遭人嫉妒，避免俄法结盟。</li>
<li>俄–内陆国家，想要获得出海港口–黑海海峡周围的土地（除了这个，也有一点宗教行为）。–英国遏制俄国–印度：东印度公司一开始是香料（后来价格下降）开始鸦片–利益太大，所以印度成为英国的咽喉。 鸦片–纺织–茶叶</li>
<li>印度的财富滋养了大英帝国：1910年的收入相当于293吨黄金。所以他要控制所有去往英国的航线。</li>
<li>拿破仑时代结束后，欧洲民族主义开始兴起，沙皇俄国趁机叫嚣“泛斯拉夫主义”，企图利用民族主义鼓动这些南部斯拉夫人民从土耳其的统治下独立出来，成为操纵的傀儡，从而实现间接控制黑海海峡的目的</li>
<li>欧洲制度规定只有正妻的儿女才有继承权，情妇永远是违法的，所以才会有女国王。</li>
<li>奥匈帝国：让别人去打仗吧，快乐的奥地利喜欢和别人结婚。可以说是他现在自己早就独自疼得受不了了，根本没有闲工夫去寻找那些吃的东西了。</li>
<li>结果就是由于俄奥两国在巴尔干半岛的争夺最终引爆了第一次世界大战。</li>
<li>土耳其的统治极其残暴，在位的苏丹为了防止自己的儿子和兄弟夺权，会把他们关在一个没有窗户的建筑里，很多皇子都是这样度过一辈子的，当老的苏丹死了，他们之中幸运的一个会被选为国王，完全不懂人情事故，没有受过教育，甚至不知道如何和别人交谈的人就当了这个帝国的国王。</li>
<li>塞尔维亚起义成功–俄国开始以“奥斯曼帝国东正教基督徒的保护着为名”，这样就是可以插手一些国际事务了。</li>
<li>希腊要起义了。—为了减少俄国早巴尔干半岛的影响。最后俄委员会认为，一旦奥斯曼帝国崩溃，那么欧洲列强各国对土耳其瓜分的狂潮，并将导致分脏不均而引发世界大战。</li>
<li>同时英国为了减弱俄国的影响力，决定帮助希腊独立—希腊独立以后，这更加鼓舞了巴尔干各民族争取独立的斗志。</li>
<li>1841年-规定黑韩海峡由国际共同管理，并对各国军舰封闭，这就废除了此前俄国十多年的n</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;没有什么东西能够够比陆军和海军更加依赖经济前提。一发炮弹是那个时代农民五年的收入&lt;br&gt;2.一旦技术上的进步可以用于军事并且已经用于军事目的，他们便立刻几乎强制的。而且往往是违反指挥官意图而引起作战方式的改变甚至是变革。随着技术武器的出现，将再也不可能出现落后文
    
    </summary>
    
    
      <category term="战争的逻辑--普鲁士到德国崛起" scheme="https://github.com/skoll1/libateer.github.io/tags/%E6%88%98%E4%BA%89%E7%9A%84%E9%80%BB%E8%BE%91-%E6%99%AE%E9%B2%81%E5%A3%AB%E5%88%B0%E5%BE%B7%E5%9B%BD%E5%B4%9B%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>js代码书写规范</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-JS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-JS代码规范/</id>
    <published>2017-03-09T15:19:23.000Z</published>
    <updated>2017-03-13T12:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>###腾讯代码规范###</p>
<ol>
<li>项目名字全部小写，中间用下划线分割。</li>
<li>有复数形式的时候要采用复数命名法。scripts</li>
<li>Js文件命名：参照项目名字</li>
<li>html语法：缩进四个空格。嵌套的节点要缩进。属性上都用双引号，属性名都小写，用中划线做分隔符。不要再自动闭合的变迁结尾处做斜线，不要忽略可选的关闭标签。</li>
<li>Lang属性；在HTML标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉他们怎么发音和翻译。</li>
<li>字符编码：通过声明一个明确的字符编码，让浏览器更加轻松，快速的确定适合网页的渲染方式，通常是“UTF-8</li>
<li>meta变迁还可以指定页面用什么版本的IE来渲染；查，不同doctype在不同的浏览器下出发不同的渲染模式</li>
<li>引入css和js的时候不需要指明type,因为他们有默认值。查。这些都可以在w3c官方文档上面查到。</li>
<li>属性顺序：按照特定的顺序保证易读性：class,id,name,data-,/src,for,type,href,value,max-lenght,max,min,pattern/placeholder,title,alt,aria-*,role,reqired,readonly,disabled.</li>
<li>class是为了高可用重复组件设计的，所以尽量放在前面，id更高具体，所以尽量少用，放在第二位。</li>
<li>bolean属性表示不需要声明取值的属性，XHTML需要每个属性声明取值，但是html5并不需要；bloean属性的存在表示取值为true，不存在表示取值为false。（sselected）</li>
<li>在js文件中生成标签会让内容变得更加难查找，更难编辑，性能更差。所以应该尽量避免这种情况的出现</li>
<li>减少标签的数量：在编写代码的时候，要尽量避免多余的父节点；很多时候，都需要通过迭代和重构来使元素变得更少。</li>
<li>在遵循html标准和语义的时候，但是不应该以浪费实用性作为代价。</li>
<li>任何时候都要尽量小的复杂度和尽可能小的标签来解决问题。</li>
<li>css缩进4个空格。</li>
<li>以下几种情况下需要空格：属性值钱，选择器’&gt;’,’+’,’~’前后。</li>
<li>空行：文件最后白留一个空行。属性之间要保留空行。</li>
<li>换行的规则</li>
<li>注释的规则：</li>
<li>引号：最外层要用双引号，url的内容要用引号。属性选择器中的属性值需要引号。<br>li[data-type=”single”] </li>
<li>类名用小写加中划线分割</li>
<li><p>id用驼峰式命名<br>相关的属性声明要按照右边的顺序分组处理，各组之间需要有一个空行。<br>declaration-order{<br>display: block;<br>float: right;</p>
<p>position: absolute;<br>top: 0;<br>right: 0;<br>bottom: 0;<br>left: 0;<br>z-index: 100;</p>
<p>border: 1px solid #e5e5e5;<br>border-radius: 3px;<br>width: 100px;<br>height: 100px;</p>
<p>font: normal 13px “Helvetica Neue”, sans-serif;<br>line-height: 1.5;<br>text-align: center;</p>
<p>color: #333;<br>background-color: #f5f5f5;</p>
<p>opacity: 1;}<br>感觉上面的没必要啊：用chrome的时候之间分出来了，就是那个再次修改的时候比较好找一点。</p>
</li>
<li>颜色16进制用小写，16进制最好简写</li>
<li>属性简写要你特别熟悉属性的正确顺序，而且大多时候都不要写出全部的内容，所以建议分开写，因为那也废不了多少时间《放屁，给不认识的人看的时候好看就看吧。</li>
<li>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，那样做只会让人们更加容易忘记他们。</li>
<li>属性值为0的后面不加任何单位。</li>
<li>无前缀的属性要写在有前缀的属性后面。不要再同个规则里出现重复的属性，如果重复的属性是连续的就没关系。</li>
<li>用 border: 0; 代替 border: none;；</li>
<li>Js</li>
<li>换行的时候，行末必须有运算符：</li>
<li>但是在关键字哦的后面，else,catch,finally的后面就不要换行了。</li>
<li>代码注释和文档注释。。。</li>
<li>在这个里面最外层统一用单引号。</li>
<li>用’===’, ‘!==’代替’==’, ‘!=‘；</li>
<li>for-in里一定要有hasOwnProperty的判断；</li>
<li>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名</li>
</ol>
<p>###百度代码规范###</p>
<ol>
<li></li>
<li>缩进与换行：4个空格为一个缩进层。每行不要超过120个字符；</li>
<li>class命名必须代表相应的模块或不见得内容或功能，不得以样式信息来命名。</li>
<li>禁止为了hack创建无样式的class.</li>
<li>不允许class只是为了让js选择某系元素，class应该具有明确的语义和样式。否则容易导致css的泛滥</li>
<li><p>ie会混淆name和id，所以最好他们之间不一样。<br>7.</p>
<!-- good -->
<input type="text" name="title">
</li>
<li><p>上面这个编辑器会自己解决吧。</p>
</li>
<li>标签使用必须符合严格的嵌套规则</li>
<li>块级元素 一般用来搭建网站架构、布局、承载内容……像这些大体力活都属于块级元素的，它包括以下这些标签： </li>
</ol>
<p>address、blockquote、center、#dir#、div、dl、dt、dd、fieldset、form、h1~h6、hr、isindex、menu、noframes、noscript、ol、p、pre、table、ul </p>
<ol>
<li>内嵌元素 一般用在网站内容之中的某些细节或部位，用以“强调、区分样式、上标、下标、锚点”等等，下面这些标签都属于内嵌元素： </li>
</ol>
<p>a、abbr、acronym、b、bdo、big、br、cite、code、dfn、em、font、i、img、input、kbd、label、q、s、samp、select、small、span、strike、strong、sub、sup、textarea、tt、u、var </p>
<ol>
<li></li>
<li>display: inline; /<em> 转成内嵌元素 </em>/<br>14.<br><div><h1></h1><p></p></div> —— 对<br><a href="”#”"><span></span></a> —— 对 </li>
<li><span><div></div></span> —— 错 </li>
<li><ol>
<li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<br>h1、h2、h3、h4、h5、h6、p、dt </li>
</ol>
</li>
<li>li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明</li>
<li>li 和 div 标签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大滴…… </li>
<li>p - 段落</li>
<li>h1,h2,h3,h4,h5,h6 - 层级标题</li>
<li>strong,em - 强调</li>
<li>ins - 插入</li>
<li>del - 删除</li>
<li>abbr - 缩写</li>
<li>code - 代码标识</li>
<li>cite - 引述来源作品的标题</li>
<li>q - 引用</li>
<li>blockquote - 一段或长篇引用</li>
<li>ul - 无序列表</li>
<li>ol - 有序列表</li>
<li>dl,dt,dd - 定义列表</li>
<li>虽然列的都是常用的。但是没必要记那么多啊，最多就是自己给默认了几个css样式，如果对语义化和seo有差距的话那就另当别论了</li>
<li>布尔类型的属性，不要加属性值。</li>
<li>自定义属性的写法data- 使用前缀有助于区分自定义属性和标准定义的属性。<br>35.<br><meta http-equiv="X-UA-Compatible" content="IE=Edge"><br>启用IE Edge<br>36.<br>引入 CSS 时必须指明 rel=”stylesheet”</li>
</ol>
<p>不需要的是type属性这个是默认的<br>37.<br>添加 width 和 height 属性，以避免页面抖动。</p>
<p>[建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。</p>
<p>强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。</p>
<label><input type="checkbox" name="confirm" value="on"> 我已确认上述条款</label>

<p><label for="username">用户名：</label> <input type="textbox" name="username" id="username"><br>具体选择形式是这个。。</p>
<p>使用 button 元素时必须指明 type 属性值。</p>
<p>解释：</p>
<p>button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。</p>
<p>真的默认是提交我去了了。。。</p>
<ol>
<li>负责主要功能的按钮应该放在相对靠前，以提高访问性。</li>
<li>当使用js进行提交表单的时候，如果条件允许，使用原生的提交功能，当js出错的时候，照样可以提交</li>
<li>在媒体格式的时候，音频要是mp3,Wav,ogg.视屏要是MP4，webm,ogg.</li>
<li>Css</li>
<li>Css文件使用无bom得utf-8格式<br>6.<br>.post,<br>.page,<br>.comment {<br> line-height: 1.5;<br>}<br>main &gt; nav {<br> padding: 10px;<br>}</li>
</ol>
<p>label + input {<br>    margin-left: 5px;<br>}</p>
<p>input:checked ~ button {<br>    background-color: #69C;<br>}<br>article[character=”juliet”] {<br>    voice-family: “Vivien Leigh”, victoria, female;<br>}</p>
<p>#error,<br>不得为id,class选择器添加类型选择器进行限定。<br>选择器的嵌套层级应该不大于3级，位置靠后的限定条件应该尽可能的精确。<br>并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性</p>
<pre><code>* Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等
* Box Model 相关属性包括：border / margin / padding / width / height 等
* Typographic 相关属性包括：font / line-height / text-align / word-wrap 等
* Visual 相关属性包括：background / color / transition / list-style 等
</code></pre><p>将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。</p>
<p>如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。</p>
<p>建议每层包含100个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。</p>
<p>在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647</p>
<p>RGB颜色值必须使用十六进制记号形式 #rrggbb</p>
<p>[强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。</p>
<p>font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。</p>
<p>font-family: “Helvetica Neue”, Arial, “Hiragino Sans GB”, “WenQuanYi Micro Hei”, “Microsoft YaHei”, sans-serif;<br>但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。<br>将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。</p>
<p>当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。</p>
<p>尽可能在浏览器能高效实现的属性上添加过渡和动画。</p>
<pre><code>* transform: translate(npx, npx);
* transform: scale(n);
* transform: rotate(ndeg);
* opacity: 0..1;
</code></pre><p>.box {<br>    transition: transform 1s;<br>}<br>.box:hover {<br>    transform: translate(20px); /<em> move right for 20px </em>/<br>}<br>Media Query 不得单独编排，必须与相关的规则一起定义。</p>
<p>.box {<br>    -webkit-box-sizing: border-box;<br>       -moz-box-sizing: border-box;<br>            box-sizing: border-box;<br>}</p>
<p>Js</p>
<ol>
<li>Js文件使用无BOM的UTF-8编码</li>
<li><ol>
<li>所有看到的东西都是通过引擎绘制出来的，更新频率取决于开发者指定的FPS，帧数越高，视觉上感觉越流畅，60是满值。在实际运行情况中，性能还取决于JS解析器的效率，制定的FPS帧数可能在低性能解释器中得不到体现，所以这不是开发者所能决定的，说一只能做的是尽可能的优化代码，关注每帧执行逻辑代码带来的CPU消耗，好需要注意每帧调用回吐指令的数量以及CPu的纹理提交速度</li>
</ol>
</li>
<li>基准测试：实时监测当前性能。FPS越高越好。Sprite：渲染节点数量：越低越好</li>
<li>内存优化：对象池：涉及到不断重复使用的对象。在初始化应用的程序期间创建一定的数量的对象并将其存储在一个池中。对一个对象完成操作后，将该对象放回到池中，在需要新对象时可i对其进行检索</li>
<li>h5内嵌框架标签元素，iframe<iframe src="http://www.divcss5.com/" width="400" height="200" scrolling="yes">使用框架不利于网页搜索的优化。</iframe></li>
<li>闭合标签就是标签又开始，有结束</li>
<li>h5可以支持很多标签不闭合</li>
<li>无内容元素：是一种不能包含任何内容的特殊的元素，例如:br,hr,img,link,meta,area,base,col,command,embed,keygen,param,source,track,war,渊源：sgml时期有一种标签叫无尾标签，当一个标签内只有简单的文字的时候，就可以使用无尾标签无须闭合这个标签了。</li>
<li>接下来升级为无标签元素，<br>这样写起来自然，当h5的时候，他们是这样说的：HTML5 的语法完全兼容 HTML4 和 XHTML1，但是不兼容 SGML 中那些晦涩的 HTML4 特性。比如无尾标签（&lt;em/content/）。</li>
<li>自闭合标签到底要不要加／号，</li>
<li>创建按钮的四种方法<input type="button"> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><input type="submit"> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。<button> 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题。其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮.如果只是歌单纯的按钮，触发一些动画动作，那么button,当要把画面数据提交给服务器的submit。</button></li>
<li>button和input:button.在button内部，您可以放置内容，比如文本或图像。这是该元素与实用input元素不同的之处。button与button之间的所有内容都是按钮内容，其中包括可接受的正文内容，文本或者多媒体内容。需要注意的是要始终给她加上type属性，IE的默认类型是button而其他的浏览器着submit。</li>
<li>web安全色216种，</li>
<li>img上title和alt  title是在鼠标悬停上显示的内容，alt是在某种情况无法显示图片的情况下出现的信息。</li>
<li>网页字体用偶数不用奇数</li>
<li>网页元素</li>
<li>meta：位于文档的头部，定义了与文档相关联的元信息，这些元对象是以名称的形式成对定义的。一个页面可以定义多个meta标签，每个标签分别通过对应的name（关联到http头部）和content（把属性关联到一个名称）属性定义键值，来定义不同的原信息。</li>
<li>base指定所有页面中所有链接的基础路径。如果没有base的话，那么页面所有的相对路径将生成绝对路径作为默认的基础路径。</li>
<li>style的type 指定样式类型，浏览器支持的样式只有css一种，所以这个属性只有css一种，media属性置顶使用的媒体，表明文档在什么时候用什么元素定义的样式。</li>
<li>media属性详解：运算符 and,not ,or,</li>
<li>link:link和style 怎么结合起来用啊？link内部也有一些属性，media.</li>
<li>给网站添加logo。&lt;link rel=“shortcut icon” href=“” type=“image/x-icon”&gt;</li>
<li>预先获取资源：等同于让浏览器在空闲时间或预读取一些资源文档，不造成资源浪费。</li>
<li>link rel=“prefetch” href=“页面地址” 怎样控制什么时候开始。。</li>
<li>这是什么书？真是菜啊。。</li>
<li>异步执行脚本。方法：回调函数，事件监听，观察者模式，promise对象。</li>
<li>meta定义页面关键<meta name="“keywords”" content="“”">设置页面描述：<meta name="“description”" content="“输入内容"">都是为了搜索引擎，只是输入的字数限制不同。<meta name="“author”" content="“"">设置作者信息，<meta name="“robots”" content="“可选值”">：可以限制搜索网站方式，也就是把自己藏起来，</li>
<li>语言和文字:<meta http-equiv="“content-language”" content="“Zh-CN”/"></li>
<li>定时跳转页面：&lt;meta http-equiv=“Refresh” content=“10,url=http:www.baidu.com”&gt;也可以刷新网页</li>
<li>设置网页缓存过期的时间。</li>
<li>禁止从缓存中调用。</li>
<li>删除过期的cookie.</li>
<li>网页过渡效果：什么都可以，我去长见识了</li>
<li>标记文字</li>
<li>强调em.外文或科技术语i.重要的文字:strong.表示不正确和较正s.</li>
<li>为文字加下划线u.小号字体small.添上标sub.下标sup.</li>
<li>表示缩写abbr.定义术语<dfn title="“sdfsdf”">jlkjlklkjl</dfn>;</li>
<li>引用其他处的内容<q cite="“http://baidu.com”">sdkls<p></p>;</q></li>
<li>cite引用其他作品的标题。</li>
<li><ruby>漠&lt;&gt;</ruby></li>
<li>显示图像</li>
<li>图像预先加载</li>
<li>图像区域映射 <img><map>&lt;area shape=“circle coords=“0,100,200,30,9”&gt;</map></li>
<li>使用base64:url格式的图片。data取的数据的协定名称。就是代码表示一张图片，但是不能大于32k.高清图片不能显示，不可以裁成小段么？</li>
<li>生成超链接</li>
<li>指向外部的</li>
<li>使用相对url，相对路径和。绝对路径。</li>
<li>生成页面⚓️点</li>
<li>生成图像链接，电子邮件链接mailto</li>
<li>设定浏览环境——self当前页面打开，_blank创建新页面打开。</li>
<li>组织文字内容</li>
<li>pre：可以定义预格式化的文本。被包围在pre中的元素会保留空格和换行符。而文本也会呈现为等宽字体。pre标签的一个常见的应用就是来显示计算机的代码可以显示非格式化的内容。</li>
<li>应用他处内容block quote 他们之间的所有文本都会被从常规的文本中分离出来，经常会在左右两边缩进，而且有时会用斜体，也就是说，块引用有自己的空间。</li>
<li>dialog h5中用于定义对话框或窗口</li>
<li>划分文档结构：标题的使用是十分常见的，页面标题，模块标题，块区标题，各式各样的标题都可以使用h1-h6来实现。</li>
<li>hgroup 给标题分组隐藏起来，那就可以出现多个了。</li>
<li>section:对内容进行块划分，代码层次结构简单。在一个页面里面可以使用多个footer，既可以做页面的整体页脚，也可以做为一个内容区块的结尾。</li>
<li>语义化写代码article大段纯文字   附注栏：aside. </li>
<li>adress在页面输出联系人信息。</li>
<li>details summary 配合起来可以提供一个显示和隐藏文字的小工具。</li>
<li>使用下拉列表：label for=“sd”我最爱的球队 input type=“text” name=“team” id=“team_list”<pre><code>1. datalist id=“team_list&quot;
2. option edg
                        1. option rng但是这个怎么自动生成啊，这只能玩现成的？
</code></pre><ol>
<li><ol>
<li>使用局部变量。只要使用超过一次，最好都设置为局部变量。</li>
</ol>
</li>
</ol>
</li>
<li>高效的数据读取，4字面量值，变量，数组元素，对象属性。真正的差异在于从数组或对象中读取数据。存取这些数据结构中的某个值，需要通过索引或属性值来查询数据存储的位置。</li>
<li>在数据存储的过程中，将函数使用超过一次的对象属性或数组元素存储为局部变量是一种好方法。</li>
<li>流控制：在每个环节上选择浅淡的语句能够极大的提高脚本的运行速度。</li>
<li>// 条件判断</li>
<li>if(value==9){</li>
<li>return 9;</li>
<li>}else if(value==8){</li>
<li>return 8</li>
<li>}</li>
<li>// 把最常用到的条件摆到前面，而不是按照顺序一个一个的来排练。 </li>
<li>if(value&lt;6){</li>
<li>if(value&lt;3){</li>
<li>if(value==0){</li>
<li>return 0;</li>
<li>}else if(value==1){</li>
<li>return 1;</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>//这样式将条件拆分为几个分支，确保执行任意一次都不会超过4次条件判断。</li>
<li>// 当有大量的条件判断时，推荐使用switch而不是if而且可以参照第一种用法。</li>
<li>// 数组查询方法，超过10个条件需要判断，</li>
<li>var result=[result0,result2,1,2,3,,4,]</li>
<li>return return[value];</li>
<li>// 循环问题</li>
<li>// 反复比较计数变量和数组的长度。</li>
<li>// 保存var length=arr.length;</li>
<li>var values=[1,2,3,4,4];</li>
<li>var length=values.length;</li>
<li>for(var i=length;i–){</li>
<li>process(values[i]);</li>
<li>}</li>
<li>// 结束条件与0做比较，大大减少时间的浪费。</li>
<li>// 处理大量数组的展开循环方法</li>
<li>var item=Math.floor(values.length/8);</li>
<li>var leftover=values.length%8;</li>
<li>var i=0;</li>
<li>if(leftover&gt;0){</li>
<li>do{process(values[i++]);</li>
<li>}while(–leftover&gt;0);</li>
<li>}</li>
<li>do{</li>
<li>process(values[i++]);</li>
<li>process(values[i++]);<br>}while(–item&gt;0);<br>// 字符串优化<br>// 频繁的在后台创建和销毁字符串是很费时间的，加法是在字符在1000以内所有浏览器都能在1毫秒之内完成，此时优化已经没有意义了<br>// 裁剪字符串；<br>function trim(text){<br>return text.replace(/^\s+|\s+$/g,””);<br>}<br>// 提花你开头或结尾的空白元素。<br>function trim(text){<br>text=text.raplace(/^\s+/,””);<br>for(var i=text.length-1;i&gt;=0;i–){<br>if(/\s/.text.(text.charAt(i))){<pre><code>text=text.substring(0,i+1);
break;
</code></pre>}<br>return text;<br>}<br>}<br>// 大量最快。<br>// js是单线程语言，那意味着一段时间呗只能执行一个操作，这意味着在执行js时所有的用户交互都会被打断，所以可能会出现页面冻结<br>// 脚本失控的原因，过多的dom交互，什么是dom交互.<br>// 过多的循环，过多的递归。<br>// 解决办法：使用定时器挂起。<br>window.onload=function(){<br>setTimeout(function(){<br>// 被延迟的脚本1<br>setTimeout(function(){<pre><code>// 被延迟的脚本2
</code></pre>}，100)<br>}，100)<br>}<br>// 超越gzip的压缩<br>// 有些头文件的请求会被修改，主要是web代理和pc安全软件，通过移除accept-encoding头的技术来窃听。<br>// 设计目标：最小化未压缩的文件的尺寸。使用事件委托：当有多个元素需要执行相同的事件时，可以把这个事件的处理程序绑定到<br>// 她的父级元素上面，但这个元素在字元素出发的时候，会冒泡到父元素上面。2使用相对url3移除空白。4移除属性的引号<br>// 避免行内样式，5为JS设置别名var $=document.getElementById;<br>// 直接检测是否支持Gzip。来为她设置这个属性。</li>
</ol>
<p>// 图像优化：<br>// 使用图片优化技术2:选择合适的格式,jpeg保存照片，GIF保存动画，其他所有动画都用png来保存，但是尽量使用png8。<br>// 对于超过10KB的图像，采用渐进jpeg编码。使用csssprite.不要在页面内对图片大小缩放。<br>划分主域：htttp瀑布图。</p>
<ol>
<li>最大链接限制的是url上的主机名，而不是解析出来的IP地址。只要为新域建立一条cname纪录。仅仅是以一个域名的别名，即使域名是来自一个服务器，那么浏览器依旧会给每个主机打开最大链接数。</li>
<li>css选择符，避免使用通配原则，不要限定id 选择符，不要限定类选择符，让规则越具体越好，不要使用后代选择符，依靠继承。</li>
<li>避免使用的选择符：决定优化的部分是在哪些可能匹配大量元素的关键选择符上面。</li>
<li>css选择符</li>
<li>性能工具：数据包嗅探器，性能分析器：YSlow                                   </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###腾讯代码规范###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目名字全部小写，中间用下划线分割。&lt;/li&gt;
&lt;li&gt;有复数形式的时候要采用复数命名法。scripts&lt;/li&gt;
&lt;li&gt;Js文件命名：参照项目名字&lt;/li&gt;
&lt;li&gt;html语法：缩进四个空格。嵌套的节点要缩进。属性上
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="代码规范-风格书写" scheme="https://github.com/skoll1/libateer.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-%E9%A3%8E%E6%A0%BC%E4%B9%A6%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>js新特性(主要是5版本)</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-新特性/</id>
    <published>2017-03-09T15:06:25.000Z</published>
    <updated>2017-03-09T15:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>保留字可以做为属性键了，在对象中，点操作符后面可以使用保留字作为非引用属性键。</li>
<li>对象字面量和数组字面量中最后的逗号是合法的。。忠于。</li>
<li>多行字符串：如果在行尾使用反斜杠转移字符，字符串变量可以跨多行。</li>
<li>我被他那一章给骗了，东西全有之前。。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;保留字可以做为属性键了，在对象中，点操作符后面可以使用保留字作为非引用属性键。&lt;/li&gt;
&lt;li&gt;对象字面量和数组字面量中最后的逗号是合法的。。忠于。&lt;/li&gt;
&lt;li&gt;多行字符串：如果在行尾使用反斜杠转移字符，字符串变量可以跨多行。&lt;/li&gt;
&lt;li&gt;我被他那
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>JS和unicode</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-unicode/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-unicode/</id>
    <published>2017-03-09T13:53:34.000Z</published>
    <updated>2017-03-09T14:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>字符和字形：字符相当于拼音，字形就是汉字。字形是语言的基本单位。</li>
<li>雕文：雕文表示字形的具体显示方式。有时，一个字形也可能会有不同的显示方法。这都取决与他的上下文以及其他的一些因素。<br>3.码位：unicode通过一种叫码位的数字来表示字符。马尾的十六进制范围从0X0到0X10ffff.</li>
<li>码元：</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;字符和字形：字符相当于拼音，字形就是汉字。字形是语言的基本单位。&lt;/li&gt;
&lt;li&gt;雕文：雕文表示字形的具体显示方式。有时，一个字形也可能会有不同的显示方法。这都取决与他的上下文以及其他的一些因素。&lt;br&gt;3.码位：unicode通过一种叫码位的数字来表示字符。
    
    </summary>
    
    
      <category term="js和unicode" scheme="https://github.com/skoll1/libateer.github.io/tags/js%E5%92%8Cunicode/"/>
    
  </entry>
  
  <entry>
    <title>移动设计-互动精髓</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-移动设计/</id>
    <published>2017-03-09T13:22:10.000Z</published>
    <updated>2017-03-09T13:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>设计师不应该仅仅是专注于项目的创新而不理会新技术的发展，移动社交的精髓是应用会在恰当的时候想用户呈现信息，用户能对其快速感知，并只需作出非常简单的反馈。用户的要求是有活力的，他会要求自己的应用和自己的操作系统融合在一起。</li>
<li>交互设计的主要驱动力在交互工具的发展</li>
<li>你因该设计界面有一定的容错性，避免用户陷入困境，因为计算机执行的代码是准确无误的，但是人无视完美的，所以要注意一下几点：预防数据的丢失，提高操作结果的预见性，允许用户犯错后重试。反复确认按钮，</li>
<li>一句话：用户永远都是对的。</li>
<li>合理的设计程序，及时在不同的界面，操作系统和设备尺寸上面有所不同，用户的体验也是一致的，高效的。交互设计师需要清楚的知道界面和软件之间的差距，从本质上讲，客户花费了酬劳就是要你根据自己的专业知识进行合理的设计决策，从而提供愉悦的，直观的使用体验。</li>
<li>在移动网站阶段，要常访问此类门户网站。</li>
<li>最好先弄秦楚谁是你的而主要客户。针对你的开发项目。你的目标用户可能是特定年龄，性别，有特定爱好的人群。从而从用户的视角去考虑，能够理解问题并找出潜在的痛点。</li>
<li>界面要简单易懂，易于学习，交互方式要明确，直观。</li>
<li>移动应用和传统应用之间不是替代关系，而是互补关系。</li>
<li>尽管你希望自己的应用能解决你想像到的所有问题，但是任何成功的程序都是解决用户的一个问题，并把这个做到最好。</li>
<li>年龄，他们所用的设备。</li>
<li>手机独有的交互设计：移动定位。用户不需要花费时间输入地址和邮件，他可以和容易的找到附近自己需要的东西。</li>
<li>大众化的分格更容易被人接受，让你的设计摆脱地域的限制。</li>
<li>如果你没法提供更多的语言来，那么最好提供更多的图，一图胜千言，好的图有很大意义上的通用性。</li>
<li>简约设计在任何时间，任何东西都是适用的。</li>
<li>谷歌的使命字面意思是整合全球信息，使人人尽享并受益。这一指导思想推进了计算机科学史的重大进步，如果你的应用有个目标或使命。并且比谷歌的文字多，那么你有必要坐下来在换一个更加简洁的目标。</li>
<li>下载量最大的日历，计算机或记事本应用，这类应用时最常见的，可以看他们的应用操作是如何设计的，他们是竞争最激烈的。</li>
<li>如果只是一小撮人在用某个功能的话，那么最好把它藏起来。一旦你的应用发布的话，那么就意味着你哦很难去掉某个功能，那些使用高级功能的人也是最爱惹事的人。</li>
<li>跟随业界领袖的脚步、</li>
<li>a/b测试，设计两种不同的网页设计，看用户喜欢那个就用哪个？</li>
<li>了解用户把时间花在了哪，因为客户永远不知道他们自己喜欢或不喜欢某项引用的原因。数据分析会让你知道这些东西。</li>
<li>维护工作日志，做一个个人的资料库，记录自己的工作遇到的情况。</li>
<li>评估自己的工作。</li>
<li>亚马逊网站</li>
<li>cnn news</li>
<li>flipboard</li>
<li>wolfram|alpha</li>
<li>移动设备任何时候都是要考虑文字输入是个大问题。</li>
<li>手势于鼠标的区别。</li>
<li>在小屏幕中去除不必要的杂乱元素，在大屏幕上突出其控件和增强式导航。</li>
<li>要时刻质疑开发中能否简化界面，设计师非常容易陷入添加功能的的误区。</li>
<li>可以先体验一些没有被优化过的网页，在看现在这些区别。</li>
<li>优雅降级。</li>
<li>减少界面冲突。</li>
<li>在现实世界中，你只有一次机会给别人留下第一印象，在数字世界也是如此。</li>
<li>在这个页面浏览的时候想用到别的程序怎么办？</li>
<li>搭配—比赛—游戏—领券—社交—好的一部分—评论—改进的地方。</li>
<li>你给我一件东西，我会立刻把他的全部额外功能都现出来。扩展，用现在的思想。</li>
<li>用户不是电脑极客；</li>
<li>80、20 80的客户只会用到20的功能，但是为什么游戏的时候我们会用到其他的所有地方呢？</li>
<li>按钮：$(function(){</li>
<li>$(‘input[type=”submit”]’).click(function(){</li>
<li>$(this).animate({</li>
<li>opacity:0.1</li>
<li>},8).animate({</li>
<li>opacity:0.9</li>
<li>},226).animate({</li>
<li>opacity:0.5</li>
<li>},86);</li>
<li>$(‘input[type=”submit”]’).removeClass(‘partial-fade’).animate({</li>
<li>opacity:1</li>
<li>},86);</li>
<li>// 这什么垃圾特效。。。</li>
<li>})</li>
<li>});</li>
<li>input[type=’submit’]{</li>
<li>color:white;</li>
<li>padding: 5px;</li>
<li>width: 68px;</li>
<li>height: 28px;</li>
<li>border-radius: 5px;</li>
<li>border: 1px;</li>
<li>font-weight: bold;</li>
<li>border:1px groove #7a7a7a;</li>
<li>background: linear-gradient(to bottom,#0f97ff 0%,#97d2ff 8%,#0076d1 63%,#005494 100%);</li>
<li>}</li>
<li>input[type=”submit”]:hover{</li>
<li>border:2px groove #7a7a7a;</li>
<li>}</li>
<li>input[type=’submit’].partial-fade{</li>
<li>border-top:1px solid #cff;</li>
<li>border-right:1px solid #ccf;</li>
<li>border-left:1px solid #ccf;</li>
<li>border-bottom: 1px solid #6cF;</li>
<li>box-shadow: 0 0 8px 0px #0f97ff ,inset 0 0 20px rgba(37,141,220,1);</li>
<li>Mask-image：实现字体遮罩。</li>
<li>响应式布局的实现：</li>
<li>Float:max-width:350px float:left;当装不下的时候自动去下一行。</li>
<li>基于相对内编剧的布局控制：comment:padding:0 0 0 10%.给想要排列的所有顺序盒子加上这个东西 </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;设计师不应该仅仅是专注于项目的创新而不理会新技术的发展，移动社交的精髓是应用会在恰当的时候想用户呈现信息，用户能对其快速感知，并只需作出非常简单的反馈。用户的要求是有活力的，他会要求自己的应用和自己的操作系统融合在一起。&lt;/li&gt;
&lt;li&gt;交互设计的主要驱动力在
    
    </summary>
    
    
      <category term="移动设计-互动精髓" scheme="https://github.com/skoll1/libateer.github.io/tags/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E4%BA%92%E5%8A%A8%E7%B2%BE%E9%AB%93/"/>
    
  </entry>
  
  <entry>
    <title>weui-移动开发</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-weui/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-weui/</id>
    <published>2017-03-09T13:19:26.000Z</published>
    <updated>2017-03-11T11:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首先最上面有一个错误提示的东西开始都是藏起来的，藏得最深的。</li>
<li>他的样式注意啊：position:fixed;top:0;left:0;right:0;自动撑满页面。连宽高都没有就可以填出来颜色为什么？还用padding调整大小。</li>
<li>然后他最大的所有的容器也是用了position:absolute;top:0,left:0;right:0;bottom:0;这个是可以撑满整个页面的么？那这个absolute的用处是什么？</li>
<li>还有就是所有如果想要自己重新调整他的顺序的话，就要调整display。</li>
<li>Overflow：hidden;</li>
<li>在body里面添加公共样式，如字体，颜色。</li>
<li>正式看到了用opacity来实现出现和消失的效果。原来是自己做过这个。</li>
<li>用padding来调整里面的位置。甚至是变相改变盒子的大小。</li>
<li>好像什么里面都可以加img标签。p ,a ,h1,</li>
<li>他这个里面的字体好像没变化，都是加上px。还是不知道是不一开做了兼容。</li>
<li>只要是大量重复的东西都是用列表做成的。偏偏li里面还什么都能包。</li>
<li>这个里面变化都要加css的transition.现在还没发现是哪块需要这个过渡。。</li>
<li>.flex{</li>
<li>height: 100px;</li>
<li>border:1px solid red;</li>
<li></li>
<li>/<em> display: -webkit-box; </em>/</li>
<li>/<em> display: -webkit-flex; </em>/</li>
<li></li>
<li>/<em> display: -moz-box; </em>/</li>
<li>/<em> display: -moz-flex; </em>/</li>
<li></li>
<li>/<em> display: -ms-flexbox; </em>/</li>
<li></li>
<li>display: flex;</li>
<li></li>
<li>/<em> 水平居中</em>/</li>
<li>/<em> -webkit-box-align: center; </em>/</li>
<li>/<em> -moz-box-align: center; </em>/</li>
<li>-ms-flex-align:center;/<em> IE 10 </em>/</li>
<li></li>
<li>/<em> -webkit-justify-content: center; </em>/</li>
<li>/<em> -moz-justify-content: center; </em>/</li>
<li>/<em> justify-content: center; </em>/</li>
<li>/<em> IE 11+,Firefox 22+,Chrome 29+,Opera 12.1</em>/</li>
<li></li>
<li>/<em> 垂直居中 </em>/</li>
<li>-webkit-box-pack: center;</li>
<li>-moz-box-pack: center;</li>
<li>-ms-flex-pack:center;/<em> IE 10 </em>/</li>
<li></li>
<li>-webkit-align-items: center;</li>
<li>-moz-align-items: center;</li>
<li>align-items: center;</li>
<li>}</li>
<li>.flex&gt;div{</li>
<li>background-color:red;</li>
<li>padding:5px 10px;</li>
<li>}</li>
<li></li>
<li></li>
<li><body></body></li>
<li><div class="flex"></div></li>
<li><div>test</div></li>
<li><div>haha</div></li>
<li>水平这个简单，垂直居中怎么搞？下面明天。这个就是做遮罩的时候容易找到中间的东西，还必须是个正方形的时候才行。</li>
<li>结构：li&gt;div|div(div&gt;a|a|a|a|a &gt;(div&gt;p,div,div)下面的div是隐藏起来的一开始)</li>
<li>.jian{</li>
<li>display: inline-block;</li>
<li>height: 6px;</li>
<li>width: 6px;</li>
<li>border-width: 2px 2px 0 0;</li>
<li>border-color:red;</li>
<li>border-style: solid;</li>
<li>position: relative;</li>
<li>-webkit-transform:matrix(0.71,0.71,-0.71,-0.71,0,0);</li>
<li>transform: matrix(0.71, 0.71, -0.71, 0.71, 0, 0);</li>
<li>left: 305px;</li>
<li>}一个箭头的css.</li>
<li>P，span包裹文字有什么区别么？</li>
<li>weui层级规范，四层—最下面是内容，然后是fixed元素，然后是遮罩，最后是遮罩上的点击东西。</li>
<li>他一开始的结构是很简单的，后来的样式都是拿js渲染出来的。一开始就两个div,一个是警告的，一个是container</li>
<li>$(function(){</li>
<li>var winH = $(window).height();</li>
<li>console.log(winH);</li>
<li><p>var categorySpace = 10;</p>
</li>
<li><p>$(‘.js_item’).on(‘click’, function(){</p>
</li>
<li>var id = $(this).data(‘id’);</li>
<li>window.pageManager.go(id);</li>
<li>console.log(“1”);</li>
<li>});</li>
<li>$(‘.js_category’).on(‘click’, function(){</li>
<li>var $this = $(this),</li>
<li>$inner = $this.next(‘.js_categoryInner’),</li>
<li>$page = $this.parents(‘.page’),</li>
<li>$parent = $(this).parent(‘li’);</li>
<li>var innerH = $inner.data(‘height’);</li>
<li><p>bear = $page;</p>
</li>
<li><p>if(!innerH){</p>
</li>
<li>$inner.css(‘height’, ‘auto’);</li>
<li>innerH = $inner.height();</li>
<li>$inner.removeAttr(‘style’);</li>
<li>$inner.data(‘height’, innerH);</li>
<li><p>}</p>
</li>
<li><p>if($parent.hasClass(‘js_show’)){</p>
</li>
<li>$parent.removeClass(‘js_show’);</li>
<li>}else{</li>
<li><p>$parent.siblings().removeClass(‘js_show’);</p>
</li>
<li><p>$parent.addClass(‘js_show’);</p>
</li>
<li>if(this.offsetTop + this.offsetHeight + innerH &gt; $page.scrollTop() + winH){</li>
<li><p>var scrollTop = this.offsetTop + this.offsetHeight + innerH - winH + categorySpace;</p>
</li>
<li><p>if(scrollTop &gt; this.offsetTop){</p>
</li>
<li>scrollTop = this.offsetTop - categorySpace;</li>
<li><p>}</p>
</li>
<li><p>$page.scrollTop(scrollTop);</p>
</li>
<li>}</li>
<li>}</li>
<li>});</li>
<li>});第一段js代码。</li>
<li>a标签这个里面很多的都是不直接规定大小的，例如长度和高度，而是利用padding，line-height;来撑开高度。而实现这种类似块的结构的都是加display：block;</li>
<li>为什么他不直接加上边框，非要用这个呢？<br>.weui-btn:after {</li>
<li>content: “ “;</li>
<li>width: 200%;</li>
<li>height: 200%;</li>
<li>position: absolute;</li>
<li>top: 0;</li>
<li>left: 0;</li>
<li>border: 1px solid rgba(0, 0, 0, 0.2);</li>
<li>-webkit-transform: scale(0.5);</li>
<li>transform: scale(0.5);</li>
<li>-webkit-transform-origin: 0 0;<br>11.<br>transform-origin: 22 12;</li>
<li>box-sizing: border-box;</li>
<li>border-radius: 10px;</li>
<li>} </li>
</ol>
<p>*<br>.weui-btn + .weui-btn {</p>
<pre><code>1. margin-top: 15px;
</code></pre><p>}<br>想在一些东西之间除了第一个都来些上下间距。。。就用这个。。。</p>
<ul>
<li>Input</li>
<li>为什么他这块的单位又可以是em.</li>
<li>为什么简单得加个边框，他非要做成这样。。<br>.weui-cells:before {</li>
</ul>
<ol>
<li>content: “ “;</li>
<li>position: absolute;</li>
<li>left: 0;</li>
<li>top: 0;</li>
<li>right: 0;</li>
<li>height: 1px;</li>
<li>border-top: 1px solid #D9D9D9;</li>
<li>color: #D9D9D9;</li>
<li>-webkit-transform-origin: 0 0;</li>
<li>transform-origin: 0 0;</li>
<li>-webkit-transform: scaleY(0.5);</li>
<li>transform: scaleY(0.5);<br>}<br>.weui-cells:after {</li>
<li>content: “ “;</li>
<li>position: absolute;</li>
<li>left: 0;</li>
<li>bottom: 0;</li>
<li>right: 0;</li>
<li>height: 1px;</li>
<li>border-bottom: 1px solid #D9D9D9;</li>
<li>color: #D9D9D9;</li>
<li>-webkit-transform-origin: 0 100%;</li>
<li>transform-origin: 0 100%;</li>
<li>-webkit-transform: scaleY(0.5);</li>
<li>transform: scaleY(26.5);<br>}</li>
</ol>
<p>一个是给上边的加一个，一个是给下边的加一个。。</p>
<ol>
<li>想在下一行用一个很小的地方做个图标之类的东西，那就可以用给他的父元素设置flex，下面整个都是flex=1;</li>
<li>他那个自定义选择的对勾，就是checbox,那个。。。</li>
<li>先看结构吧。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首先最上面有一个错误提示的东西开始都是藏起来的，藏得最深的。&lt;/li&gt;
&lt;li&gt;他的样式注意啊：position:fixed;top:0;left:0;right:0;自动撑满页面。连宽高都没有就可以填出来颜色为什么？还用padding调整大小。&lt;/li&gt;
&lt;l
    
    </summary>
    
    
      <category term="weui" scheme="https://github.com/skoll1/libateer.github.io/tags/weui/"/>
    
  </entry>
  
  <entry>
    <title>人工智能</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-人工智能/</id>
    <published>2017-03-09T13:17:38.000Z</published>
    <updated>2017-03-09T13:19:11.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>其中一个好处就是你有机会亲眼见证一个研究领域的发展过程以及那些原始梦想成真的瞬间</li>
<li>儿童并不是人们过去想的那种小大人，他们思考问题的方式和大人的差异非常大，而且在成长过程种每个不同阶段都通过不同的方式进行推理。</li>
<li>为了研究出人类大脑的替代物，我们需要掌握神经突触将两个细胞联系在一起的的具体机制，同时我们也需要掌握大脑中各种结构对活跃在她们周围的丰富的电厂，激素，神经递质，营养素一集大脑中其他化学物质的反应机制。</li>
<li>人类智能最大的特性不是在于工作的时候所进行的活动，而是没有工作的时候大脑所进行的活动。</li>
<li>你能像想象以前人们使用的图书馆里，那些书记不能聊天，在未来的生活中，只是将是活生生的，而不是在被禁止的，他们不是被动的等待你使用它，而是主动与它感兴趣的对象进行联系，并进行合作。</li>
<li>无聊，随机写出一个东西，大家聊和这个东西有关的事情，不大于四个字。</li>
<li>可不可以实现一种自动对话的东西，让那些app制动读取你的信息，在你不方便的时候替你回答。转接</li>
<li>你正在阅读的书可以告诉你可能对那些章节感兴趣，而房间里的书架着会向你展示有关的书籍，与此同时，你在墙上悬挂的注目的相片还会在你注视她的时候告诉你最最近的健康状况</li>
<li>我说想到的和自己能做的差距太大了。发现自己的优势，产品开发思维，－－最快的速度把知识压缩，应用。</li>
<li>可不可以仿照人的方式发展人工智能，就是这个机器先是歌盲人，然后再射向他的功能。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;其中一个好处就是你有机会亲眼见证一个研究领域的发展过程以及那些原始梦想成真的瞬间&lt;/li&gt;
&lt;li&gt;儿童并不是人们过去想的那种小大人，他们思考问题的方式和大人的差异非常大，而且在成长过程种每个不同阶段都通过不同的方式进行推理。&lt;/li&gt;
&lt;li&gt;为了研究出人类大
    
    </summary>
    
    
      <category term="人工智能" scheme="https://github.com/skoll1/libateer.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Chrome调试</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-chrome%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-chrome调试/</id>
    <published>2017-03-09T09:10:01.000Z</published>
    <updated>2017-03-09T13:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>console.log()还可以用Jquery语法。</li>
<li>cmd+o打开当前文件夹。</li>
<li>查找当前元素绑定的js文件。css也可以找到。</li>
<li>在console.log()中输入getEventListeners(a)可以获得当前节点的所有绑定的事件。</li>
<li>在Js文件中选中一段代码后，ctrl+shift+e可以在console.log()面板中运行这段代码。</li>
<li>console.trace()可以追踪代码执行过程中的栈信息。</li>
<li>timeline时间线如果出现红线就说明渲染时间超过了18ms，点击这些红色的线，就可以知道相应的警告信息，不超过16ms的才是流畅的画面。</li>
<li>快捷方法$()返回指定的css的选择器相匹配的的第一个元素。$$()返回与指定的css选择器相匹配的所有元素的数组。</li>
<li>chrome第一个elements右边的那一行最后两个是干嘛的。</li>
<li>cmd+o是寻找整个文件中你想要知道的东西的位置。</li>
<li>cmd+f是当前文件夹内寻找。</li>
<li>如果你希望在所有加载的文件中搜索特定的文字，你可以用下面的快捷键来加载搜索框界面：cmd+ shift+f</li>
<li>Cmd + Shitf + O 定位到特定的函数。</li>
<li>network查看网络请求的全部信息。</li>
<li>lnitiator:parser:请求是html发起的。script：脚本。redirect:页面重定向发起的。other:其他发出的。</li>
<li>Cmd + K 清除控制台</li>
<li>Shitf + Enter 允许你从控制台进入多行模式。</li>
<li>###console.log()API###</li>
<li>console.trace()跟踪一条栈信息。</li>
<li>console.assert(blloean,obj):如果表达式错误，就把obj打印</li>
<li>console.count()记录当前被执行的次数。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;console.log()还可以用Jquery语法。&lt;/li&gt;
&lt;li&gt;cmd+o打开当前文件夹。&lt;/li&gt;
&lt;li&gt;查找当前元素绑定的js文件。css也可以找到。&lt;/li&gt;
&lt;li&gt;在console.log()中输入getEventListeners(a)可以
    
    </summary>
    
    
      <category term="Chorme 调试" scheme="https://github.com/skoll1/libateer.github.io/tags/Chorme-%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>标准全局变量</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-全局变量/</id>
    <published>2017-03-09T08:44:01.000Z</published>
    <updated>2017-03-09T08:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>1：布尔值，数字和字符串这三种原始值都有对应的构造函数：Boolean,Number,String().他们的实例包含原始值，作为构造函数，他们创建的对象和他们包装的原始值有很大的不同。作为函数，他们会将值转换为相应的原始值，注意，避免包装对象是一种最佳实践，毕竟没有什么事是对象能做而原始值不能的。</p>
<p>2：包装值是对象。注意他比较大小的时候，不能比较大小。</p>
<p>3：当需要对一个原始值增加属性的时候，首先要对原始值包装并且给包装后的对象增加属性，当您使用值得时候就要先对他去包装。</p>
<p>4：去包装是调用valueOf（）。将包装对象转为原始值是用Blloean (new Blloean(true));值得注意的是转换为原始值得时候只能正确提出数字和字符串，而布尔值不能。</p>
<p>5：原始值会从包装器中借调方法，只是在严格模式和宽松模式中发生不同的处理方法。</p>
<p>6：强制类型转换：它是指从一种类型隐式的转换为另外一种类型。强制类型会出现BUG,所以在这一方面的时候要注意，可以先把将变量转换为合适的类型。</p>
<p>7：Boolean()转换。undefined,null,false,NAN,0,’’,除了这些，别的都是true.</p>
<p>8:Number（），好像是类似于一般的字符串解释,undefined-NAN,null-0,false-0,true-1,字符串会被解析，对象会先被转为原始值，然后在转为数字。</p>
<p>9：String（），这个就是所有原始值转换为字符串。</p>
<p>10：Object()这个还是？我去。。。将一个东西转为对象。。。’abc’ instanceof String;  false; Object(‘abc’) instanceof String-true. typeOf Object(‘abc’)-Object;Object(null),object(undefined)–{}.空数组都是。</p>
<ol>
<li>全局变量：所有的全局变量都是全局对象本身或者继承自全局对象（WINDOW）的属性。</li>
<li>全局构造器：Array().Blloean().Date(),Function(),Number(),Object(),RegExp(),String(),</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1：布尔值，数字和字符串这三种原始值都有对应的构造函数：Boolean,Number,String().他们的实例包含原始值，作为构造函数，他们创建的对象和他们包装的原始值有很大的不同。作为函数，他们会将值转换为相应的原始值，注意，避免包装对象是一种最佳实践，毕竟没有什么事
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>JSON</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-Json/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-Json/</id>
    <published>2017-03-09T06:25:01.000Z</published>
    <updated>2017-03-09T07:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>json字符串的使用必须是双引号，字符串变量‘ok’是错的。</li>
<li>属性键也必须使用双引号。</li>
<li><code>JSON.stringify(value,replacer,space)</code>把js对象变成json格式.第一个参数是要处理的值，第二个的值是要在做之后对值处理</li>
<li><p>var student = new Object();<br> student.name = “Lanny”;<br> student.age = “25”;<br> student.location = “China”; </p>
<p> // var json = JSON.stringify(student);<br> 如果没这个函数的话，只是弹出来的时候还是[object,object]但是你找的时候还是很简答的啊。<br> alert(student);</p>
</li>
<li>var students = new Array() ;<br>students[0] = “Lanny”;<br>students[1] = “dong”;<br>students[2] = “I love you”;<br>var json = JSON.stringify(students,switchUpper);<br>function switchUpper(key, value) {<br>return value.toString().toUpperCase();<br>}<br>alert(json); </li>
<li><p>parse用于从一个字符串中解析出json对象,如</p>
<p> var str = ‘{“name”:”huangxiaojian”,”age”:”23”}’</p>
<p> 结果：JSON.parse(str)</p>
</li>
<li>可选参数replacer是用来替换参数Valued的。具体的替换规则是这样的：JSON.stringify({A:5,B:[9,2]},replacer);function replacer(key,value){<br> if(typeof value==’number’){<pre><code>value=2*value;
</code></pre> }<br> return value;<br>}<br>“{“A”:10,”B”:[18,4]}”</li>
<li>当replacer为数组的时候，用来隐藏非数组对象内属性不在这个列表中的所有属性。JSON.stringify({foo:1,bar:{foo:1,bar:2}},[‘bar’]);—<br>“{“bar”:{“bar”:2}}”</li>
<li>最后一个是用来影响输出格式的。如果没有这个参数，那么变换后的结果实单行的文本。有了这个可以可以插入新行而且通过数组和对象的嵌套增加缩进。有这两种方法可以指定如何缩进。</li>
<li>他的参数可以是什么呢？数字。。。将数字会成以相对应的数量的空格来缩进。</li>
<li>一个不被JSON支持的值将解析成为undefined,而不是string.</li>
<li>可以使用一个函数toJSON来先把这个转换为字符串，然后使用该方法来做JSON.stringify().</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;json字符串的使用必须是双引号，字符串变量‘ok’是错的。&lt;/li&gt;
&lt;li&gt;属性键也必须使用双引号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JSON.stringify(value,replacer,space)&lt;/code&gt;把js对象变成json格式.第一个参数是
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
</feed>
