<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李巴特儿de小屋子</title>
  <subtitle>...触之不动...</subtitle>
  <link href="/libateer.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/skoll1/libateer.github.io/"/>
  <updated>2017-03-26T15:28:44.000Z</updated>
  <id>https://github.com/skoll1/libateer.github.io/</id>
  
  <author>
    <name>李巴特儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互联网协议</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/25/best-1-%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/25/best-1-互联网协议/</id>
    <published>2017-03-25T13:00:43.000Z</published>
    <updated>2017-03-26T15:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>###https为什么安全###<br>他是http和ssl/tls的组合<br>密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。</p>
<ol>
<li>密匙：是在使用密码算法的过程中输入的一段参数，同一个明文在相同的密码算法和不同的密匙计算下回产生不同的密文。密匙才是决定密文是否安全的重要参数，密匙越长，破解的难度越大。根据密匙的使用方法，密码可分为对称加密和公匙加密。</li>
<li>对称密码：加密和解密的使用相同的密匙。关键问题：如何安全的传送密匙。</li>
<li>公匙加密：发送者用加密密匙进行加密，接受者用解密密匙解密。加密密匙是公开的，任何人都可以获取。解密密匙只能自己使用。收的人自己创建锁和钥匙，把箱子给他，把东西放到这个里面，然后发送回来。</li>
<li>消息摘要：消息摘要函数是一种用于判断数据完整性的算法，也称为散列函数或哈希函数，函数返回值叫做散列值，散列值又称为消息摘要或是指纹。这种算法是一个不可逆的算法，因此你没法通过消息摘要反推出消息是什么。所以他也称为单项散列函数，下载软件时如何确定是官方提供的完整版呢，如果中间有人在里面嵌入了病毒，你也不得而知。所以我们可以使用散列函数对消息运算，生成散列值，通常软件提供方会同时提供软件的下载地址和散列的散列值，用户下载后在本地用相同的散列值算法甲酸出散列值，与官方提供的散列值对比，如果相同的，说明软件时完整的，否则就是被别人修改过的。</li>
<li>消息认证：可以解决同事替代消息和消息摘要的情况。</li>
<li>消息认证码是一种可以确保消息完整性并进行认证的技术。消息认证码是一种可以理解为一种与密匙相关的单项散列函数。<br>7.<br>公钥证书</li>
</ol>
<p>公钥密码在数字签名技术里面扮演举足轻重的角色，但是如何保证公钥是合法的呢，如果是遭到中间人攻击，掉包怎么办？这个时候公钥就应该交给一个第三方权威机构来管理，这个机构就是认证机构（Certification Authority）CA，CA 把用户的姓名、组织、邮箱地址等个人信息收集起来，还有此人的公钥，并由 CA 提供数字签名生成公钥证书（Public-Key Certificate）PKC，简称证书。</p>
<ol>
<li>Bob 生成密钥对，私钥自己保管，公钥交给认证机构 Trent。</li>
<li>Trent 经过一系列严格的检查确认公钥是 Bob 本人的</li>
<li>Trent 事先也生成自己的一套密钥对，用自己的私钥对 Bob 的公钥进行数字签名并生成数字证书。证书中包含了 Bob 的公钥。公钥在这里是不需要加密的，因为任何人获取 Bob 的公钥都没事，只要确定是 Bob 的公钥就行。</li>
<li>Alice 获取 Trent 提供的证书。</li>
<li>Alice 用 Trent 提供的公钥对证书进行签名验证，签名验证成功就表示证书中的公钥是 Bob 的。</li>
<li>于是 Alice 就可以用 Bob 提供的公钥对消息加密后发送给 Bob。</li>
<li>Bob 收到密文后，用与之配对的私钥进行解密。</li>
</ol>
<p>###互联网协议入门###</p>
<ol>
<li>互联网的实现，分为好几层，每一层都有特定的功能，互联网的核心，就是一系列协议，总称为互联网协议。她们对电脑如何连接和组网作出了详细的规定。</li>
<li>第一层：实体层，把电脑连接在一起的物理手段。它主要规定了网络的一些电气特性，作用时负责传送0和1的电信号。</li>
<li>链接层：单纯的0和1没有任何意义，必须规定解读方式：多少个信号算一组，确定了0和1的分组。</li>
<li>以太网协议：早期的时候，每家公司都有自己的电信号分组方式。逐渐的，一种叫以太网的协议占据了主导地位。</li>
<li>一组信号构成一个数据包，叫做“帧”，每一帧包含两个部分，标头和数据。标头：发送者，接受者，数据类型。数据：数据包的具体内容。</li>
<li>标头和数据的大小都是有规定的，如果大于他所规定的范围，必须切割分成多个字段进行。</li>
<li>mac地址：就是网卡的地址，数据包的发送地址和接受地址。</li>
<li>广播：定义地址只是第一步，以太网采取了一种很原始的方法，他不是把数据包准确的发送给接收方，而是向本网络的所有计算机都发送，让每台计算机都自己判断，是否接受。</li>
<li>网络层：从上面的情况来看，必须找到一种方法，能够区分哪些MAC地址属于同个子网络，这样才能广播。网络层的诞生就是为了解决这个问题，它引进一套新的地址，使我们能够区分不同的计算机是否属于一个子网络。这套协议就叫做“网络地址”，简称“网址”。从逻辑上，我们先处理网络地址，在处理MAC地址。</li>
<li>IP协议的两个作用：一个是为每一个计算机分配IP地址，另一个是确定是哪些地址在同一个网络下。</li>
<li>arr协议，我们可以得到同一个子网络内的主机的MAC地址，从IP地址转换来，这样就可以把数据包发送到另一个主机之内了。</li>
<li>传输层：有了MAC地址我们就可以在互联网上任意两台电脑上建立通信。接下来的问题是一台计算机上的不同应用都需要用到网络，那么怎么区别发来的一个数据包属于那部分要用的信息呢。</li>
<li>我们需要一个参数来表示数据包属于哪个程序使用。这个参数叫做端口，他其实是每一个使用网卡的程序的编号。每个数据包发送到主机的特定端口，所以不同的程序能去到自己所需的数据。</li>
<li>传输层的功能是：建立端口到端口的通信。相比之下，“网络层”的功能是建立在“主机到主机”通信，只要确定主机和端口，我们就能实现程序之间的交流。</li>
<li>TCP和UDP协议都是为了实现这个目标，只不过TCP协议有确认机制，每一个发出的数据都是要确认，如果一个数据包发出得不到确认，就有必要重新发送一遍了。</li>
<li>应用层：收到数据后的行为。解读实现规定好的格式的数据，TCP协议可以解读EMAIL，WWW，ftp.这是最高的一层直接面对用户。她的数据就放在TCP数据包的“数据部分”。</li>
<li>数据传输的场景：同一个子域，对方的MAC地址，对方的IP地址。非统一个子网络，网管的MAC地址，对方的Ip地址。</li>
<li>动态IP地址：计算机开机时，会自动分配到一个IP地址，不用人为设置，DHCP协议：每一个子网络中，都有一台计算机负责管理本网络的所有IP地址，新加入的计算机加入网络，必须向“DHCP服务器发送一个“DHCP请求”数据包，申请IP地址和相关的网络参数。</li>
<li>上网的人确定四个参数才能用：本机的Ip，子网掩码，网关的IP地址，dns的IP地址。</li>
<li>dns</li>
</ol>
<p>###异步通信开发###</p>
<ol>
<li>http专门用来负责超文本的传输，也就是所谓的web信息传输（网页，图像，不同类型的文件）</li>
<li>http主要由两部分组成：请求和响应。</li>
<li>Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接Keep-Alive: timeout=5, max=100</li>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>客户端请求结构 请求行，请求头部，空行，和请求数据<br>GET /hello.txt HTTP/1.1<br>User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3<br>Host: www.example.com<br>Accept-Language: en, mi</li>
<li>GET /pagead/js/adsbygoogle.js?_=1472721354924 HTTP/1.1<br>Host: pagead2.googlesyndication.com<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0<br>Accept: <em>/</em><br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Accept-Encoding: gzip, deflate<br>Referer: <a href="http://domestic.firefox.sina.com/16/0901/01/R0GJL8D7VI5SUOKN.html" target="_blank" rel="external">http://domestic.firefox.sina.com/16/0901/01/R0GJL8D7VI5SUOKN.html</a><br>Connection: keep-alive</li>
<li>Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由 于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址</li>
<li>服务器响应消息 状态行 消息报头 空行 响应正文</li>
<li>HTTP/1.1 200 OK<br>Date: Mon, 27 Jul 2009 12:28:53 GMT<br>Server: Apache Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。<br>Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 实体头指定服务器上保存内容的最后修订时间<br>ETag: “34aa387-d-1568eb00”<br>Accept-Ranges: bytes<br>Content-Length: 51<br>Vary: Accept-Encoding<br>Content-Type: text/plain Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型 Content-Range实体头 </li>
<li>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： </li>
</ol>
<p>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth </p>
<p>例如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围， Content-Length表示实际传送的字节数。</p>
<ol>
<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>
<li>Allow 服务器支持哪些请求方法（如GET、POST等）</li>
<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>
<li>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。</li>
<li>http状态码分类：1 服务器收到信息，需要请求者继续执行操作。 2 成功 操作被成功接受处理 3 重定向 需要进一步的操作完成请求 4客户端错误 请求包含语法错误或无法完成请求 5 服务器错误 服务器在处理请求的过程中发生了错误。</li>
<li>交互的核心是有一个信息处理机制，这个处理机制就是回调函数。该函数时被在服务器端调用的，并负责处理服务端信息相应的信息。 </li>
<li>既然可以通过影藏框架实现动态加载服务器的请求页面，呢为什么不能用js代码开始实现这个功能呢，js标签能够动态的加载外部的js脚本，js脚本文件不仅仅可以被执行，而且可以传输数据，所以我们不妨在访问服务器端的时候使用js文件来附加传递信息。当客户在远程加载脚本文件的时候，这些附加在js脚本文件的响应信息也一并被加载到客户端中，实现异步交互的效果。</li>
</ol>
<p>###图解http协议###</p>
<ol>
<li>http是无状态的协议。超文本传输协议（超文本转移协议），适用于从万维网服务器传输超文本到本地浏览器的传送协议。</li>
<li>http是基于tcp/ip通信协议来传递数据的。由网络层的IP协议和传输层的TCP协议组成，TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址</li>
<li>无连接：限制每次连接只能处理一个请求，服务器处理完就立刻放手，断开连接。</li>
<li>http:媒体独立的，只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过http发送。客户端以及服务器端通过使用适合的MIME-type内容类型。</li>
<li>无状态：协议对事件处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则他必须重传，这样可能导致每次连接传送的数据量增大。另一方面，当服务器不需要之前的信息的时候就变得很快了。</li>
<li>http使用统一的资源标识符来URL来传输数据和建立连接。。</li>
<li>现在使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而http属于他的内部一个子集。</li>
<li>tcp/IP是互联网相关的各类协议族的总称（协议中存在各式各样的内容：包括电缆的规格，ip地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及web页面显示需要处理的步骤）</li>
<li>TCP/IP协议族最重要的一点就是分层（应用层，传输层，网络层，数据链路层）</li>
<li>应用层（ftp&lt;文件传输&gt;,http,dns&lt;域名管理&gt;）–传输层（连接俩台计算机之间的数据传输Tcp&lt;传输控制协议&gt;udp&lt;用户数据报协议&gt;）–网络层（处理在网络上流动的数据包，在众多的选项内选一条传输路线）–数据链路层（处理连接网络的硬件部分，包括控制操作系统，硬件的设备驱动，nic,硬件上的范畴基本上都在链路层的作用范围之内）–物理层</li>
<li>利用tcp/ip协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从应用层往上走。</li>
<li>浏览器现在客户端发出想看某个页面的http请求，接着为了传输方便，在传输层把从应用层收到的数据进行分割，并且会在各个报文上边打上标记序号以及端口号转发给网络层。在网络层（iP）,增加作为通信目的地点的MAC地址发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li>
<li>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接受端在层与层之间传输数据时，每经过一层时会把对应的首部去掉。这种把数据信息包装起来的做法称为封装。（http数据-TCP首部-IP首部—-以太网首部）</li>
<li>负责传输的IP协议：位于网络层层。所有使用网络的系统都会用到IP协议，IP协议的作用是把各种数据包传送给对方，利用IP地址和MAC地址定位实现。IP地址指明了节点被分配的地址，MAC指的是网卡所属的固定地址，IP地址和mac地址来配对，IP地址可以互相变化，但是MAC地址基本上不会改变。</li>
<li>ip间的通信依赖mac地址，通常的同心都是进过多台计算机和网络设备中转才能连接到对方。而在进行中转时，就会利用到另一台计算机的mac地址来搜索下一个中转目标。</li>
<li>在到达通信目标前的中转过程中，那些计算机和路由设备只能获悉很粗略的传输路线。这种机制就是路由选择，就像快递公司一样。无论那台计算机，哪台网络设备，他都无法掌握互联网中的细节。</li>
<li>确保可靠性的TCP协议：位于传输层，提供可靠地字节流服务。将大块的数据分割成以报文段为单位的数据包进行管理。而可靠地传输服务就是指能够把数据准确可靠地传给对方。tcp协议能够确认数据是否最终送达到对方。</li>
<li>为了确保无误的将数据送到目标处，tcp采取了三次握手的策略。TCP把数据包发送出去之后，tcp不会不对数据的去向不管，他一定会确认是否成功送达。握手的过程使用了TCP的标志（flag）-SYN-ACK。</li>
<li>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，在返回一个带有SYN,ACK的数据包表示确认信息。然后发送端在回传一个带ACK标志的数据包，代表握手结束。若是在握手的某个阶段发生中断，tcp协议就会再次以相同的顺序发送相同的数据包。</li>
<li>除了三次握手，tcp协议还有其他各种手段来确保通信的可靠性。</li>
<li>dns位于应用层的协议。他提供域名到IP地址之间的解析服务。dns协议提供通过域名查找IP地址，或者逆向从IP地址反查域名的服务。</li>
<li>用户通常使用主机名字或域名来访问对方的计算机，而不是直接通过ip地址来访问，对于人来说我们一般输入字母比较容易记住，但是对于电脑来说一长串数组就好多了。</li>
<li>他们之间的关系：仔细想一遍</li>
<li>url，uri：与uri（统一资源标识符）相比，我们更加熟悉url(统一资源定位符)。</li>
<li>uri就是由某个协议方案表示的资源定位表示符。协议方案就是指访问资源时所使用的协议类型名称。采用http协议时，协议方案就是http.除此之外，还有ftp,mailto,telnet,file等。</li>
<li>uri用字符串表示识别某一互联网资源，而url表示资源的地点（互联网上所处的位置）url是uri的子集，一部分。</li>
<li><a href="http://(协议方案名)user:pass(登录信息)@www.baidu.com（服务器地址）:80(服务器端口号)dir/index.html?(带层次的文件路径)uid=1(c查询字符串)#ch1(片段标识符)。--完整的绝对uri格式" target="_blank" rel="external">http://(协议方案名)user:pass(登录信息)@www.baidu.com（服务器地址）:80(服务器端口号)dir/index.html?(带层次的文件路径)uid=1(c查询字符串)#ch1(片段标识符)。--完整的绝对uri格式</a></li>
<li>rfc是一些用来指定http协议技术标准的文档，通常，应用程序会遵照由rfc确定的标准实现。可以说，rfc是互联网那个设计的文档。要是不按照这个文档设计，那么就会可能导致无法通信。</li>
<li>http协议：</li>
<li>在应用http协议时，必定一端担任客户端角色，另一端担任服务器端角色。请求必定由客户端发出，返回一定有服务器端返回。首先是从客户端开始通信的，服务器端在没有收到请求之前是不会发送相应的。</li>
<li>http虽然是无状态的协议，但是为了实现期望的保持状态的功能，于是引入了cookie技术，有了cookie在用http协议通信，就可以管理状态了。</li>
<li>get方法用来请求访问一杯url识别的资源。指定的资源经服务器解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像cgl那样的程序，就返回经过执行的输出结果。</li>
<li>post的主要目的不是用来获取响应的主体内容，而是发送信息。</li>
<li>put。delete方法分别是上传和删除信息的两个操作，但是他们都不带验证机制，所以一般的web网站也不会使用delete方法。当配合web应用程序的验证机制，或者遵守rest标准时还是有可能会开放使用的。</li>
<li>options:询问支持的方法。-（返回服务器的支持的方法get,head,post,optioins）</li>
<li>trace:让服务器将之前的请求通信换回给客户端的方法。客户端通过这个方法可以知道发出去的请求是怎样被加工的。想要连接到原服务器目标可能会通过一系列的代理中转，trace方法就是用来确认连接过程中的一系列操作的。（容易引发xst跨站追踪）攻击，通常不会用到。</li>
<li>connect:这个方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl,tls协议把通信内容加密后经网络隧道传输。</li>
<li>head方法用来接收信息的头部</li>
<li>http协议的初始版本中，美进行一次http通信就要断开一次TCP连接。但是现在的网页如果需要传输大量的图片的话，就会浪费无谓的TCP连接和断开，增加通信的开销。</li>
<li>持久连接：只要任意一端没有明确的提出断开连接：那么就保持TCP持久连接状态。（http keep-alive http connection reuse）建立一次TCP连接后进行多次的请求和响应的交互。</li>
<li>持久连接使得多数请求以管线化方式成为可能，从前发送请求需要等待并接收到响应，才能发下一个请求。管线化技术出现后，不用等待响应也可以直接发送下一个请求。当请求一个包含10张图片的htmlweb页面，与挨个连接相比，用持久连接可以让请求更快的结束。而管线化技术择比持久链接还要快。请求越多，时间差就越明显。</li>
<li>cookie通过在请求和响应报文中写入cookie信息来控制客户端的状态。</li>
<li>cookie会根据从服务器端发送的响应报文内的一个set-cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往服务器端发送信息的时候，客户端会自动在请求包头上加上自己的cookie值后发送出去。服务器端发现刻画单发送过来的cookie后。回去检查是从哪一个客户端发送过来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
<li>http通信包括从客户端发往服务器端的请求以及从服务器端返回客户端的响应。</li>
</ol>
<p>###http报文内的http信息###</p>
<ol>
<li>请求报文=报文首部+报文主体（不是必须）</li>
<li>请求报文首部=请求行（请求方法，请求url和http版本）+请求首部字段+通用首部子端+实体首部字段+其他（cookie）</li>
<li>响应报文首部=状态行（响应结果的状态码，原因短语和http版本）+响应首部字段+通用首部字段+实体首部字段+其他</li>
<li>首部字段：表示请求和响应的各种条件和属性的各类首部。</li>
<li>报文是http通信中的基本单位，由8位组字节流组成，通过http通信传输。</li>
<li>实体：作为请求或响应的有效荷载数据被传输，其内容由实体首部和实体主体组成。</li>
<li>通常：报文主体等于实体主体。只有当传输中进行编码操作的时候，实体主体的内容发生变化，才导致他和报文主体产生差异。（当对内容编码的时候，可以有效地提升传输的速率，通过在传输的时候编码，能够有效地处理大量的访问请求。）</li>
<li>常用的内容编码：Gzip,compress,deflate.</li>
<li>在传输大量内容的数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码，分块传输编码会将实体主题分成多个部分。每一块都用16进制来标记块的大小，二十题主体最后的一块使用“0（CR+LF）”来标记。</li>
<li>mime:多用途因特网邮件扩展机制，它允许邮件处理文本，图片，视频等多个不同类型的数据。</li>
<li>为了解决下载过程中遇到网络中断的情况，为了避免重新下载，需要一种可恢复的机制，可以从之前下载中断的地方恢复下载。要实现该功能需要制定下载的实体范围。指定范围发送的请求叫做范围请求。rage bytes 5001/10000</li>
<li>针对范围请求，响应会返回状态码为206的响应报文，另外对于多重范围的范围请求，响应会在首部字段content-type标明multipart/byteranges。如果服务器无法响应范围请求，则会返回状态码200 ok和完整的实体内容。</li>
<li>内容协商机制：同一个网站可能存在多分相同的内容的页面，当浏览器默认语言为英文或中文，访问相同的URL的web页面时，则会显示对应的英语版本或中文版的web页面。</li>
<li>内容协商机制会以响应资源的语言，字符集，编码方式等作为判断的基准。包含在请求报文中的某些首部字段就是判断的基准。accept,accept-charset,accept-encoding,accept-language,content-language;</li>
<li>内容协商机制有以下几种情况：服务器驱动协商，已浏览器为标准，可能不会得到准确的信息。客户端驱动协商（脚本实现PC端或移动端）;透明协商：两个结合。</li>
</ol>
<p>###http首部报文###</p>
<ol>
<li>若http首部字段重复了会怎样？有的会使用第一个，有的会使用第二个。</li>
<li>通用首部字段：cache-control:控制缓存的行为</li>
<li>connection:逐跳首部，连接的管理。</li>
<li>data创建报文的日期时间。</li>
<li>pragma:报文指令。</li>
<li>trailer:报文末端的首部一览。</li>
<li>transfer_Encoding:指定报文主题的传输编码方式</li>
<li>upgrade:升级为其他协议</li>
<li>via；代理服务器的相关信息。</li>
<li>warning:错误统治。</li>
<li></li>
</ol>
<p>###返回结果的http状态码###</p>
<ol>
<li>状态码如200 OK 三位数字和原因短语组成。</li>
<li>1**信息状态码 请求正在处理</li>
<li>2**成功状态码 成功</li>
<li>3**重定向状态码 需要进行附加操作以完成请求</li>
<li>4** 客户端错误状态码 服务器无法处理请求</li>
<li>5** 服务器错误状态码  服务器处理请求出错</li>
<li>常用的状态码 200 成功  204处理成功，但是不给你更新页面，没有资源可以返回  206 只是进行了范围请求，成功了。</li>
<li>301 永久性重定向：请求的资源早已经被分配了新的url，以后应该使用资源现在的url&gt;也就是说，重新保存地址url.  302 临时性重定向 该状态表示请求的资源一杯分配了新的URL,希望用户能够使用新的url访问。  303 在302的基础上，请求方试必须为get  <em>当301，301，303响应状态码返回时，几乎所有的浏览器都会把post改成get，并且删除报文内的主体，并且之后请求会自动再次发送</em>  304：该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是没有满足条件的情况。和重定向没有关系。</li>
<li>400 请求报文内存在语法错误。服务器无法理解这个请求，但是浏览器会像200 OK 一样对待该状态码。 401 该状态码表示发送的请求需要有通过http认证的认证信息。另外若之前已经进行过一次请求，那么第二次返回就表示认证失败。</li>
<li>403 请求的资源没有权限，被服务器拒绝了。  404 服务器上没有请求的资源（也可以在服务器拒绝请求且不想说明理由的时候使用）</li>
<li>500 服务器端在执行请求的时发生了错误（都发生了错误了怎么还会返回信息呢？）  503该状态码表示服务器正在处于超载负荷停机维护，现在无法处理请求。<br>12.状态码和状况不一致，不少返回的状态码响应都是错误的，但是与用户是觉察不到这点的。</li>
</ol>
<p>###与http协作的web服务器###</p>
<ol>
<li>一台web服务器可以搭建多个独立域名的web服务器，也可以作为通信路径上的中转服务器提升传输效率。</li>
<li>http/1.1允许一台http服务器搭建多个web站点。比如提供web托管的供应商，可以用一台服务器为多位客户服务，也可以让每位用户持有的域名运行各自不同的网站，这是因为用了虚拟主机的功能。由于寄存在一个服务器下，当解析之后会有相同的Ip地址，所以在发送http请求时，必须在host首部内完整指定主机名或者域名的URL;</li>
<li>在http通信的时候，还有一些用与数据转发的应用程序，例如代理，网关，隧道。他们可以配合服务器工作。</li>
<li>代理：有转发功能的应用程序，接受由客户端发送的请求并转发给服务器，同时也接受服务器发回的响应并转发给客户端。(通过设置组织内部的代理服务器可以做到针对特定URL的访问控制)</li>
<li>网关：网关是转发其他服务器通信数据的服务器，接受客户发过来的请求，他就像自己拥有资源的服务器一样对请求处理。有事客户端都不会差距自己通信的目标是一个网关。网关可以使通信线路上的服务器提供非http协议服务。利用网管能提高通信的安全性，因为可以在客户端与网关之间的通信路线上加密以确保连接的安全，比如，网关可以连接数据库，使用sql语言查询数据。</li>
<li>隧道：在两个相聚很远的客户端和服务器端之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。</li>
<li>使用代理的原因：利用缓存技术，减少网络带宽的流量，组织内部针对特定的网站的访问控制，以获取访问日志为主要目的。</li>
<li>代理的分类：缓存代理》预想将资源的副本缓存保存在代理服务器上。当代理再次收到相同资源的请求的时，就可以不从源服务器那里获取资源获取资源，而是将之前的缓存的资源作为响应返回。</li>
<li>透明代理：转发请求或响应时，不对报文做任何的加工的代理类型被称为透明代理。反之，对报文内容进行加工的代理被称为非透明代理。</li>
<li>服务器端缓存，浏览器缓存：缓存是在本地磁盘内保存的资源副本，利用缓存能减少对源服务器的访问，因此也就节省了通信流量和通信时间。（怎么控制那些是可以缓存的，那些是不可以缓的，下一次请求怎么知道）</li>
</ol>
<p>###浏览器缓存清除###</p>
<ol>
<li><meta http-equiv="pragma" content="no-cache"><br> <meta http-equiv="Cache-Control" content="no-cache, must-revalidate">  <meta http-equiv="expires" content="0"></li>
<li>form表单的临时缓存： <body onload="javascript:document.yourFormName.reset()"></body></li>
<li><p>ajax 请求 $.ajax({<br>  url:’www.haorooms.com’,<br>  dataType:’json’,<br>  data:{},<br>  beforeSend :function(xmlHttp){ </p>
<pre><code>xmlHttp.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;); 
xmlHttp.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
</code></pre><p>  },<br>  success:function(response){</p>
<pre><code>//操作
</code></pre><p>  }<br>  async:false<br>});</p>
<ol>
<li><p>$.ajax({<br>url:’www.haorooms.com’,<br>dataType:’json’,<br>data:{},<br>cache:false,<br>ifModified :true ,</p>
<p>success:function(response){<br>   //操作<br>}<br>async:false<br>});</p>
</li>
<li>方法四：用随机时间，和随机数一样。在 URL 参数后加上 ?timestamp=+ new Date().getTime();</li>
</ol>
</li>
</ol>
<p>###浏览器的9中缓存机制###<br>2.浏览器缓存的种类：缓存协商（last-modified），彻底缓存(cache-control)</p>
<ol>
<li>http缓存是基于http协议的浏览器文件缓存机制。针对文件的重复请求的情况下，浏览器可以根据协议头判断从服务器端请求文件还是本地读取文件，chrome下的frames就是表示的浏览器的http文件级缓存。</li>
<li>协商缓存就是还要去页面问一下页面有没有更新，如果更新了，那么就返回新内容，如果没有，返回304直接使用胡村内容。</li>
<li>彻底缓存是在缓存失效之前不再需要和服务器发生交互，常用的是：Expires，expires是一个绝对时间，由服务器产生：这里容易出现的问题是服务器的时间可能和客户端的时间不一样，那么就用到了cache-control这是一个相对于浏览器的时间。</li>
<li>浏览器缓存的机制：针对重复请求的情况：判断pxpires：如果未过期，直接读取http文件，不发http请求，否则进入下一步。判断是否含有taag，有则带上if-none-mtahc发送请求，未修改返回304，修改返回200，否则进入下一步，判断是否含有last-modified,有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求。</li>
<li>last-modified:标志这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器最后的修改时间/if-modified-since：当资源过期的时候，发现资源具有last-modified声明，则再次向web服务器请求上带上头if-Modified-since，表示请求时间，web服务器收到请求后发现这个东西，泽宇被请求资源的最后修改时间进行对比，如果最后时间较新，说明资源被改过，则响应整片资源内容，</li>
<li>etag:web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。他的值是根据文件的索引，大小，最后修改时间hash得到的。</li>
<li>if-none-match:当资源过期的时候，发现资源有etag声明</li>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
<li>2：websql只有在比较新的chrome上实现：不是h5的一部分，将数据以数据库的形式存在客户端，根据需求去读取。web sql更方便检索，允许sql语句查询，让浏览器实现小型数据库的功能，三个核心方法：openDatabase : 这个方法使用现有数据库或创建新数据库创建数据库对象。transaction : 这个方法允许我们根据情况控制事务提交或回滚。executeSql : 这个方法用于执行真实的SQL查询</li>
<li>3： indexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且可以在这些数据上使用索引进行高性能检索的api。这个是为了存储大量结构化的数据而准备的。</li>
<li>4：cookie:一般网站为了辨别用户身份，进行session跟踪而存储在本地终端上的数据。不同域名之间的cookie是独立的，如果需要设置共享可以再服务器端设置cookie的path和domain来实现共享。</li>
<li>5：localStorage:是html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开的渲染速度，有大小限制，不适合放过多的数据，如果数据太大会删除最先的数据。</li>
<li>6： sessionStorage:浏览器关闭会全部删除，一般项目中不用。</li>
<li>application cache：将大部分的图片资源，js,css等静态资源放在manifest文件配置中。当页面打开时通过manifest文件来读取本地文件或是请求服务器文件。离线访问需要依靠这个来实现。</li>
<li>7：cacheStorage是在ServuceWorker的规范中定义的。cacheStorage可以保存每个serverworker申明的cache对象，</li>
<li>8：falsh缓存。</li>
<li>浏览器缓存类型：强缓存，不会向服务器发送请求，至鸡肉从缓存中读取资源。</li>
<li>协商缓存：向浏览器发送请求，服务器会根据这个请求的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并且带上新的参数统治浏览器从缓存中读取资源。</li>
<li>用户对浏览器缓存的控制：地址栏的访问，链接的跳转是正常用户的行为，将会触发浏览器的缓存机制,F5刷新会设置max-age=0,效果强缓存判断，会进行协商缓存判断；ctrl+f5:跳过强缓存和协商缓存，直接从服务器拉去资源。</li>
<li>web缓存游走于服务器和客户端之间。这个服务器可能是源服务器，数量可能是一个或多个，这个客户端也可能是一个或多个。web缓存就在服务器端和客户端之间搞监控，监控请求，并且把请求输出的内容另存一分。然后，如果下一个请求是相同的url，则直接请求保存的副本，而不是在次麻烦源服务器。</li>
<li>代理服务器缓存，网关缓存。</li>
<li>如何控制缓存和不缓存？</li>
<li>meta标签使用很简单，但是效果一般，如果你的网站托管到ISP或者主机托管商那里，并且他们没有赋予你任何设置http头信息的能力，那你就要注意了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###https为什么安全###&lt;br&gt;他是http和ssl/tls的组合&lt;br&gt;密码学中的密码是一套算法，这套算法用于对消息加密和解密，从明文到密文的过程就是加密，密文反过生成明文称之为解密，加密算法和解密算法结合在一起叫做密码算法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密匙：是在
    
    </summary>
    
    
      <category term="互联网协议" scheme="https://github.com/skoll1/libateer.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/22/best-1-this%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/22/best-1-this你所不知道/</id>
    <published>2017-03-22T11:21:28.000Z</published>
    <updated>2017-03-22T12:16:24.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>this指向自身：错误1</li>
<li>this指向函数的自己的作用域 错误2</li>
<li>this的机制：他不是在编写时就绑定的，而是在运行的时候那么会定的，他的上下文是取决于函数调用时的各种条件，this的绑定和函数声明的位置没有任何关系，只是取决于函数的调用方式。当一个函数被创建的时候，会自动生成一个活动记录，这个记录会包含这个函数在哪里被调用，函数的调用方法，传入的参数等信息。this就是其中记录的一个属性，会在函数的执行过程中用到。</li>
<li>this的调用位置：调用位置就是函数在这个代码中被调用的位置，绝不是声明的位置，寻找调用位置就是在找“函数被调用的位置”，在实际环境中，最重要的就是分析函数的调用栈：就是为了执行你这个函数我之前执行的所有函数都是栈，找到这个以后，调用位置就是正在执行的函数的前一个函数。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;this指向自身：错误1&lt;/li&gt;
&lt;li&gt;this指向函数的自己的作用域 错误2&lt;/li&gt;
&lt;li&gt;this的机制：他不是在编写时就绑定的，而是在运行的时候那么会定的，他的上下文是取决于函数调用时的各种条件，this的绑定和函数声明的位置没有任何关系，只是取决
    
    </summary>
    
    
      <category term="this你所不知道" scheme="https://github.com/skoll1/libateer.github.io/tags/this%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的js</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/21/best-1-%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/21/best-1-你所不知道的js/</id>
    <published>2017-03-21T06:37:15.000Z</published>
    <updated>2017-03-21T08:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>需要一套设计良好的规则来存储变量，并且可以之后很方便的找到这些变量，这套规则叫做作用域。</li>
<li>任何的js代码在执行之前都必须要进行编译，通常就在执行前，因此，js编译器首先会对代码进行编译，然后做好执行他的准备。</li>
<li>变量的赋值会经过两个操作，首先编译器会在当前作用域中声明一个变量，然后运行的时引擎就会早作用域中查找该变量，如果找到就会对他赋值。</li>
<li>lhs,rhs可以理解为赋值目标是谁（查找的目的是为变量赋值），以及谁是赋值操作的源头（目的是获取变量的值）。</li>
<li>函数作用域的意思是可以属于这个函数的全部变量都可以在整个函数的范围内使用以及复用，事实上嵌套的作用域中也是可以使用的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;需要一套设计良好的规则来存储变量，并且可以之后很方便的找到这些变量，这套规则叫做作用域。&lt;/li&gt;
&lt;li&gt;任何的js代码在执行之前都必须要进行编译，通常就在执行前，因此，js编译器首先会对代码进行编译，然后做好执行他的准备。&lt;/li&gt;
&lt;li&gt;变量的赋值会经过
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>天天一点点-面试</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/17/best-1-%E5%A4%A9%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9-%E9%9D%A2%E8%AF%95-1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/17/best-1-天天一点点-面试-1/</id>
    <published>2017-03-17T06:03:35.000Z</published>
    <updated>2017-03-19T15:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>###html###</p>
<ol>
<li>form–method get post</li>
<li>display:block;w80;overflower:hidden;text-wrap:nowrap;text-overflow:ellipsis;</li>
<li>dom文档的加载顺序-解析html结构-加载外部样式和脚本-解析和执行脚本-dom构建完成(domcontentLoaded)-加载外部图片-window.onload-</li>
<li>domready是指整个文档熏染好了，domonload是指加载图形。</li>
<li>-ms-是ie的浏览器前缀。</li>
<li>background-color:是不可以继承的样式。</li>
<li>xml只能有一个根节点，但是可以嵌套，他的解析方法分为dom,sax.</li>
<li>form是块级元素，会自动换行。但是label也不是什么inline-block元素。</li>
<li>行内块级元素有select，img,input,button,object</li>
<li>css常用选择器：标签，id，类选择器。</li>
<li>blob是对大数据块的不透明引用或者句柄。名字来源于SQl数据库，表示“二进制大对象”。在js中，他表示二进制数据。mime是描述消息内容类型的因特网标准。</li>
<li>mime消息是能包含文本，图像，音频，视频以及其他应用程序专用的数据。</li>
<li><p>如何垂直居中一个浮动元素 `width: 200px;</p>
<pre><code>height: 200px;
background-color: #6699FF;

margin:auto;
position: absolute;  /*  父元素需要相对定位,子元素绝对定位 */
left: 0;
top: 0;
right: 0;
bottom: 0;`
</code></pre><ol>
<li>元素的type属性可以取值为：image,checkbox,select,button,file,password,number,text,reset,</li>
<li>放在body部分的元素会在页面加载的时候被执行。在html-head部分的js会在被调用的时候才会被执行。</li>
<li>head中必不可少的标签是title。</li>
<li>mark自动给元素加背景，还是黄色的。</li>
<li>标签的权重是1，累的权重是10，id的权重是100，内联样式的权重是1000</li>
<li>所有的link同时加载么？给html添加相同属性不同属性值的的css样式,后面的css文件样式会覆盖前面的css文件样式.但是他们的覆盖还是按照权重选择来的。先加载玩的优先解析。</li>
<li>加载图片的情况：首先是img标签，只要设置了src都会加载。</li>
<li>图片背景：可见的情况下加载。</li>
<li>js的情况：只要写了src都会加载的。</li>
<li><p>`span{</p>
<pre><code>float: left;
width:auto;
height: 100%;
</code></pre><p>}<br>i{</p>
<pre><code>position: absolute;
float: left;
width: 100px;
height: 50px;
</code></pre><p>}`i设置了绝对定位，脱离文档流，所以父级宽度会塌陷，为0；</p>
</li>
<li><p>css注释/**/，html注释<!--  -->，js注释还不一样么// ？真的不一样。。。。</p>
</li>
<li>web worker是运行在后台的js，不会影响页面的性能。</li>
<li>svg标签是用来制作可升缩的矢量图来画图或是文本。</li>
<li><p>innerHTML—<span style="haha"></span></p>
<pre><code>&lt;i&gt;hello&lt;/i&gt;
</code></pre><p>连这个都会显示。。</p>
</li>
<li><p>自定style方式 resource-style-item</p>
</li>
<li>它只是HTML、CSS和客户端脚本的一种集成，即一个页面中包括html+css+javascript（或其它客户端脚本），其中css和客户端脚本是直接在页面上写而不是链接上相关文件。DHTML不是一种技术、标准或规范，只是一种将目前已有的网页技术、语言标准整合运用，制作出能在下载后仍然能实时变换页面元素效果的网页设计概念</li>
</ol>
<p>###window###对象</p>
<ol>
<li>百分比中的matgin-top，padding-top都是相对于最近的父元素的宽度来说的。</li>
<li>select中的text才是选项，value是option里面的标签内的value.</li>
<li>发送表单的时候：当表单中包含文件上传控件的时候，属性规定在发送到服务器之前应该如何对表单数据进行编码，需要将enctype设置为application/x-www-form-urlencodeed.在发送前编码所有字符，multipart/form-data不对字符编码，在使用包含文件上传控件的表单时，必须使用改值，text/plain空格转换为“+”号，但不对特殊字符编码。</li>
<li>label只有两个属性。form,for。当点击<label for="cb_add_favorite">时，光标焦点会定位到id=”cb_add_favorite”为的输入框上。</label></li>
<li>对于MVC来说，模型变更后，只有控制器才能驱动视图变更或重新渲染视图。</li>
</ol>
</li>
</ol>
<p>###bfc###</p>
<ol>
<li>表单提交方式method，路径的属性为action.</li>
<li>span[class=”aa bbb”]&gt;a;</li>
<li><td> 标签定义 HTML 表格中的标准单元格。</td></li>
<li><th> 元素中的文本通常呈现为粗体并且居中</th></li>
<li><td> 元素中的文本通常是普通的左对齐文本</td></li>
<li>html的文档就是超文本标记语言。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###html###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;form–method get post&lt;/li&gt;
&lt;li&gt;display:block;w80;overflower:hidden;text-wrap:nowrap;text-overflow:ellipsis;&lt;/li&gt;
&lt;
    
    </summary>
    
    
      <category term="天天一点点-面试" scheme="https://github.com/skoll1/libateer.github.io/tags/%E5%A4%A9%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>天天一点点-1</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/17/best-1-%E5%A4%A9%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9-1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/17/best-1-天天一点点-1/</id>
    <published>2017-03-17T05:35:35.000Z</published>
    <updated>2017-03-17T06:03:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>1. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1. &lt;/p&gt;

    
    </summary>
    
    
      <category term="天天一点点-微信知识" scheme="https://github.com/skoll1/libateer.github.io/tags/%E5%A4%A9%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9-%E5%BE%AE%E4%BF%A1%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>面试html-css-1</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E9%9D%A2%E8%AF%95html-css-1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-面试html-css-1/</id>
    <published>2017-03-13T12:37:07.000Z</published>
    <updated>2017-03-25T12:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>###隐藏元素###</p>
<ol>
<li>overflow:hidden(占据空间，无法点击)</li>
<li>opacity:0(占据空间，可以点击)</li>
<li>visibility:hidden(占据空间，无法点击)</li>
<li>display:none(经典的隐藏元素，彻底的隐藏元素)</li>
<li>position:absolute;left:-9999px;(不占据空间,无法点击)position:relative;left:-9999px;占据空间，无法点击</li>
<li>clip-path()裁剪。</li>
<li>z-index:-10000；</li>
<li>transform:scale(0,0)|translate(-10000px,-10000px)</li>
</ol>
<p>###clip-path()###</p>
<ol>
<li>clip-path:polygon(0 100%,64% 50%,70%,0)三角形</li>
<li>clip-path: circle(61% at 47% -24px);○</li>
<li>clip-path: ellipse(50% 23% at 50% 55%);椭圆，模拟眼镜眨</li>
<li>clip-path: inset(25% 0 25% 0 round 0 25% 0 25%);  </li>
<li><code>inset(&lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt; round &lt;top-radius&gt; &lt;right-radius&gt; &lt;bottom-radius&gt; &lt;left-radius&gt;)</code></li>
<li>polygon(0% 0%, 100% 0%, 100% 75%, 75% 75%, 75% 100%, 50% 75%, 0% 75%);定义任意形状</li>
<li>主要是他每一个属性之间会互相影响的。</li>
</ol>
<p>###flex布局###</p>
<ol>
<li>父元素里面可以加的东西；flex,/inline-flex/后一个好像不起作用;flex之间是可以嵌套的。</li>
<li>父容器属性：flex-direction:子容器的排列方向。row:row-reverse,水平  column:column-reverse,竖直</li>
<li>flex-wrap:子容器的换行效果。nowrap wrap wrap-reverse;显示的前提是父元素给了大小，并且子元素用的是固定大小，但是超出了父元素的宽度。</li>
<li>justify-content:子容器水平对齐方式.flex-start flex-end center space-between space-round; 有的好像是只能搭配固定属性才能显示出效果。</li>
<li>align-items:子容器的垂直对齐方式 flex-start flex-end center baseline stretch</li>
<li>align-content:多行子项的整体垂直对齐方式。flex-start flex-end center space-between space-round;</li>
<li>flex和固定宽度元素之间的结合 width:100px;flex:2;flex:1;</li>
<li>子元素属性：order:定义它们的排列顺序。</li>
<li>flex-grow:子项宽度不足父元素宽度的时候，子项的拉升比例</li>
<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父容器的align-items属性。默认值为auto，表示继承父容器的align-items属性，如果没有父容器，则等同于stretch。</li>
<li>遇到的坑：</li>
</ol>
<p>###not###-</p>
<ol>
<li>li:not(:last-child):not(:last-child) 两个效果都是一样：都是在加样式的忽略最后一个。</li>
<li>他的用法实例：li:not([alt=”li”])</li>
<li>p:not(.abc){<br>color:#f00;<br>}否定尾类为class=”abc”的p元素。</li>
<li>li:nth-child(2n){<pre><code>    color:yellow;
}
</code></pre></li>
<li>nth-child  nth-type-of 的区别:nth-of-type更彪悍些，前一个会出错的。</li>
<li>input{<pre><code>    color:red;
}填完以后的样子
input::-webkit-input-placeholder{
    color:green;
    font-size: 20px;
}填之前的样子。
</code></pre></li>
<li>怎么设置选择以后的元素。</li>
<li>绝对单位长度：cm,mm,px,pt,pc,px;</li>
<li>相对单位长度：rem:相对于根元素。em:现对于当前文本对象。vm:相对于视口宽度。vh：相对于视口高度。vmax：相对于视口宽度或高度重较大的那个。</li>
<li>color:transparent.透明。</li>
<li>url()里面不加引号，这是历史遗留问题。</li>
<li>list-style-type:toggle(disk,box):可以循环使用这些值。</li>
<li>语义化标签：header,content,footer,nav,slider,column栏目，loginbar,logo,banner,scroll,tag,main,hot,news,download,subnav,search,friendlink,copyright,list，文章列表。msg:提示信息，joinus,guide,title,service,vote,partner合作伙伴。</li>
<li>事假命名空间：jquery可以实现，别的可以实现么？</li>
</ol>
<p>###css组件构架设计思想###</p>
<ol>
<li>附加和重写   同名的样式，后面的会覆盖前面的。</li>
<li>整个css组件，分成8个大的类型的样式，根据每个组件的特性，来组建这些类型的特性，从而达到丰富多彩的配置效果。</li>
<li>基础样式-颜色，尺寸，状态，特殊样式，并列元素，嵌套子元素样式，动画样式</li>
<li>Web1.0是一家实体商店，房子就在那里，你随时都可以来：台式电脑使得人们只能在固定的地点连入网络Web2.0是一家移动商店，随时随地跟着你等待你的即时召唤；移动设备使得人们随时随地可以连入网络Web3.0则是商店和你是一体的，你自己就可以娱乐自己。人机交互意味着“人”和“科技”的距离进一步缩短，甚至可以说“科技”逐渐演变成为“人”的组成部分之一。</li>
<li>body{<br> line-height:1.4;<br> color:#333;<br> font-family:arial;<br> font-size: 12px;<br> background:white;<br>}<br>input,textarea,select{<br> font-size:12px;<br> font-size:100%;<br> font-family:arial;<br> font-family:inherit;<br>}<br>body,h1,h2,h3,h4,h5,h6,p,ul,ol,form{<br> margin:0;<br>}<br>h4,h5,h6{<br> font-size:1em;<br>}<br>ul,ol{<br> padding-left:0;<br> list-style-type:none;<br>}<br>/<em>image with no-border</em>/<br>a img{border:0;}<br>img{border:0;}简单的css重置样式，不要盲目的随波直流</li>
<li>通用样式库 css样式库 网站通用小图标样式</li>
<li><a href="mailto:842323422@qq.com" target="_blank" rel="external">点击</a>转到相关的邮箱</li>
<li>什么时候css元素需要用width,height,之类的东西规定大小，什么时候让他自己定义。</li>
<li>position:fixed;r0;l0;t0;b0;当一个东西固定的时候，需要在body里面加上padding-top:</li>
<li>为移动设备添加js文件：$(function(){if(window.screen.width&lt;600){$.getScript(“<a href="http://&quot;)}}" target="_blank" rel="external">http://&quot;)}}</a>)</li>
<li>怎么才能让css模块化，不能让他们互相渲染。</li>
<li>任何网站布局都是先整体后局部。</li>
<li>可以用flex代替百分比布局么？</li>
<li>还有就是一些小的杂七杂八的样式了；为元素表单控件的样式</li>
<li>csstransform是不会对周围元素产生任何影响的。</li>
<li>scale()加负数的时候，会让他来回翻转的。<br>###CSS兼容问题###</li>
<li>margin加倍：这是IE6的bug;</li>
<li>浮动ie产生的双倍边距。</li>
<li>为什么无法定义1px左右高度的容器 IE6下这个问题是因为默认的行高造成的,解决的方法也有很多,例如 verflow:hidden | zoom:0.08 | line-height:1px</li>
<li>li和li之间看不见的空白间隔是什么“？行框的排列会受到中间空白的影响，这些空白也会被应用样式，占据空间，所以会有间隔。在ul标签设置font-size＝0，在li中设置标签文字的大小，因为空格也属于字符，把字符大小设置为0,就没有空格了</li>
<li>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的，但如果是table相关的元素，例如table行，table group，table列，table column group，它的表现跟display:none一样，也就是说，它们占用的空间会释放。这个还有三个值？</li>
</ol>
<p>###浏览器渲染问题####</p>
<ol>
<li>浏览器是如何进行加载，解析，渲染的呢？</li>
<li>用户访问网页，dns服务器（域名解析系统）会根据用户提供的域名查找对应的ip地址，找到后，系统会向对应的ip地址的网络服务器发送一个http请求。</li>
<li>网络服务器解析请求，并发送请求给数据库服务器。</li>
<li>数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回浏览器。</li>
<li>浏览器解析http response;</li>
<li>1-4步需要了解http协议，访问服务器端可能遭受的问题：如果网络服务器无法获取数据库服务器返回的资源文件 404 由于并发原因暂时无法处理用户的http请求500.</li>
<li>浏览器解析http文件之后，需要下载html文件，以及html文件内包含的外部应用文件，以及文件内涉及的图片或者多媒体文件。</li>
<li>重点：加载顺序</li>
<li>当获得一个http文件时，会自上而下的加载，并在加载过程中实现解析渲染。</li>
<li>加载</li>
<li>加载过程中遇到外部css文件的时候，浏览器会发出一个请求，获取css文件，遇到图片资源，也会发出一个请求，这是异步请求，并不影响html文档的加载，但是当遇到js文件的时候，html会挂起来渲染，不仅会等待js文件加载完毕，还要等待解析完毕才行。才可以恢复html文档的渲染线程。（主要原因是js文件可能会修改dom所以在这个后面的html渲然现在看来都是没有意义的）</li>
<li>还有一个要注意的是虽然css文件的记载不影响js的加载，但是影响他的执行，同样的原因，还是这个可能会修改他的结果，所以只有在css文件下载和解析完成的时候，js代码才会执行。</li>
<li>解析：html文档解析生成解析树，由dom元素和属性节点组成，树的根是document对象。</li>
<li>渲染：就是构建渲染树的过程，他是原来的dom树的可视化，构建这棵树正式为了以正确的顺序绘制文档内容。在其中，不可见的dom元素是不会被插入到渲染树中的，还有一些节点的位置为绝对定位和浮动定位，这些节点也会在文本流之外，因此会在两棵树上的不同位置，渲染树表示出真实的位置，并用一个展位结构标识出他们原来的位置。</li>
<li>渲染最大的困难就是为每一个dom计算符合他的最终样式。首先为每一个元素找到匹配的样式规则，需要遍历整个规则表。（右–左）；</li>
<li>webkit渲染:避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp&gt;p{}</li>
<li>避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知</li>
<li>页面的渲染 需要首先生成dom树，再由css生成CSSOM，最后两个一起生成render tree。由前面两个例子 可以证明dom树有最小的生成要求，及只要body标签被生成，dom树就可以和CSSOM一起进行渲染啦</li>
<li>定律一：资源是否下载依赖 JS 执行结果。<br>定律二：JS 执行依赖 CSS 最新渲染。<br>定律三：现代浏览器存在 prefetch 优化。</li>
<li>不同于一般的浏览器chrome为每个tab都配备了各自的渲染引擎实例。</li>
<li>渲染引擎：渲染，浏览器窗口中显示的请求的内容。默认情况下，渲染引擎可以显示html，xml文件，他也可以借助插件显示其他数据，例如pdf阅读器。</li>
<li>渲染主流程：通过网络获取所请求的文档的内容，通常以8K分块的方式完成。</li>
<li>构建dom树–构建render树–布局render树-绘制render树。</li>
<li>解析可以分为两个子过程–语法分析和词法分析。解析器将工作分配给两个组件-词法分析器负责将输入分解为合法的符号，词法分析器知道怎么跳过空白和换行之类的无关字符。</li>
<li>解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配语法规则，如果匹配到了规则，那么这个符号对应的节点将被加到解析树上，然后解析器再去请求另一个符号。如果没有匹配到规则，解析器将在内部保留该符号，并从词法分析器去下一个符号，直到所有的内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</li>
<li>解析器分为自顶向下解析以及自底向上解析。</li>
<li>在树的构建阶段，将修改以document为根的dom树，将元素附加到到树上。每个由符号识别器生成的节点将会被狗在其处理，规范中定义了每个符号响应的dom元素，对应的dom元素将会被创建。这些元素除了会被添加到dom树种，好讲被添加到开放元素的堆栈中,这个堆栈用来纠正嵌套的未匹配的和未闭合的标签，这个算法也是状态机制来描述，所有的状态都是采用插入机制。</li>
<li>在碰到最后一个html标签的时候，意味着dom解析结束，在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式的脚本-这些脚本在文档解析之后执行。文档状态为完成，同时触发一个load事件。</li>
<li>欲解析不是改变dom树，而是将这个工作留给主解析过程，自己解析外部资源的引用，比如脚本，样式表以及图片。</li>
<li>样式表采用另一种不同的模式，理论上，既然样式表不改变dom树，那就没必要停下文档的解析等待他们，但是当脚本在执行的过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的信息，firefox采用的是存在样式表加载和解析的时候阻塞所有的脚本，而chrome只是当在脚本试图访问某些可能未加载的样式所影响的特定的样式属性时才阻塞这些脚本。</li>
<li>渲染树的构建：当dom树构建完成时，浏览器开始构建另一颗树-渲染树。渲染树由元素显示序列中可见元素组成，他是文档中的可视化表现，构建这棵树是为了以正确的顺序绘制文档内容。</li>
<li>每个渲染对象用一个和该节点的css盒模型相对应的矩形区域来表示，正如css2所描述的那样，他包含诸如宽，高和位置之类的几何信息。和模型的类型受该节点相关的display样式属性的影响。</li>
<li>元素的类型也是要考虑的，例如，表单控件和表格带有特殊的框架。在webkit中，如果一个元素想要创建一个特殊的渲染对象，他需要重写createRender方法，使渲染对象指向不包含几何信息的样式对象，那他的css怎么加啊。</li>
<li>渲染树和dom树是相对应的，但这种关系不是一一对应的，不可见得dom元素不会被插入渲染树，例如head元素。另外display为none的元素是不会在渲染树中出现的，visiiblty属性为hidden的树将会出现在渲染树中。</li>
<li>还有一些dom元素对应几个可见对象，他们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如select元素有三个渲染对象–显示对象，下拉列表，按钮。1：当文本因为宽度不够而折行的时候，新行将作为额外的渲染元素被添加2：根据css规范，一个行内元素只能包括行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。</li>
<li>一些渲染对象和所对应的dom节点不在树上的相同位置，例如，浮动元素和绝对定位元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出他们原来的位置。</li>
<li>创建树的过程：在firefox中表示为监听dom的更新，将frame的创建委派给constructor，这个构造器计算样式并创建一个frame.</li>
<li>webkit中，计算样式并生成渲染对象的过程为attactment，每个dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到dom树种。</li>
<li>计算html和body标签将构建渲染树的根，这个根渲染对象应被css规范称为containing block的元素–包含了其他所有块级元素的顶级块元素。他的大小就是viewport–浏览器窗口的显示区域，树中的其他部分都将作为一个插入的dom节点被创建。</li>
<li>样式计算：样式来源的复杂，样式数据是非常大的数据结构。找到元素的性能问题</li>
<li>css 规则树：样式树的使用使得节点共享这些属性值不需要计算多次，同事节省了存储空间。</li>
<li>所有匹配的规则都存在规则树种，一条路径中的底层节点拥有最高的优先级，这棵树包含了所找到的所有规则匹配的路径。每条路径对应一个节点，路径上包含了该节点所匹配的所有规则。规则树并不是一开始就为所有的节点进行计算，而是在某个节点需要计算样式的时候，才进行相应的计算，并将计算之后的路径添加到树中。</li>
<li>结构化：样式按照上下文结构划分，一个结构中的所有特性不是继承的就是非继承的，对于继承的特性，除非元素自身有定义，否则就从他的parent继承。非继承的特性如果没有定义，则使用默认的值。样式上下文树缓存完整的结构，这样，如果底层节点没有为一个结构提供样式，那么就使用上层节点缓存的结构。</li>
<li>使用规则树来计算样式上下文：当为一个特定的元素计算样式时，首先计算出规则树的一条路径，或是使用已经存在的一条，然后使用路径中的规则去填充新的样式上下文从样式的底层节点开始计算，它具有最高的优先级，遍历规则树，直到填满结构，如果那个规则节点没有定义所需要的结构规则，就沿着路径向上，直到找到该结构规则。</li>
<li>css样式权重完全是看着那个好找就用哪个？</li>
<li>布局：当渲染对象被创建并添加到树中，这个时候没有位置和大小，计算和谐值得过程称为layout或者reflow.</li>
<li>布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归，通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。</li>
<li>为了不使每个微小的变化都不必全部重新布局，浏览器有一个diety bi系统，一个渲染对象发生了变化或是被添加了，就标记他的chidren为dirty。</li>
<li>当layout在整棵渲染树触发时，成为全局layout,这可能在下面的情况下发生：一个全局的样式改变影响所有的渲染对象，比如字号的改变。窗口resieze.</li>
<li>绘制：遍历渲染树并调用渲染对象的paint方法将他们的内容显示在屏幕上，绘制使用UI组件。</li>
<li>一个块渲染对象的堆栈顺序是：背景色，背景图，border,children,outline，</li>
<li>动态变化：浏览器总是试着以最小的动作响应一个变化，所以一个元素颜色的变化将只会导致改元素的重绘，元素位置的变化将大致元素的布局重绘，添加一个dom节点，也会导致这个元素的布局和重绘，一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而导致整数的布局和重绘。</li>
<li>float－对象先像普通流一样布局，然后尽可能的向左或是向右移动</li>
<li>对象在渲染树中的位置和Dom树中位置无关:absolute.</li>
<li>第二个文档</li>
<li>html和css规范中规定了浏览器解释html文档的方式，由w3c组织对这些规范进行维护，w3c是负责制定web标准的组织。</li>
<li>浏览器引擎和渲染引擎还不是一回事：用来查询及操作渲染引擎的借口。</li>
<li>数据存储-属于持久层，浏览器需要择硬盘中保存类似cookie的各种数据，h5定义了web database技术。</li>
<li>值得注意的是为了更好地用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建布局树，他是解析完一部分就显示一部分，同时，可能会在网络下载其余内容。</li>
<li>html不能被一般的自上而下或者自底向上的解析器所解析。原因如下：这门语言是十分宽容的，浏览器对一些常见的非法html有容错机制，解析过程是往复的，通常源码是不会再解析过程中改变的，但在html中，脚本标签包含的document.write可能添加标签，这说明在解析过程中实际上修改了输入。所以html有专门的解析算法。-符号识别算法<br>###数据结构和算法###</li>
<li>具体问题抽象出数据模型-设计算法-编程调试</li>
<li>数据的逻辑结构，数据的运算–引用型运算：不改变数据中原有的数据元素的状态；加工型运算：改变数据结构中原有的数据状态。</li>
<li>存储结构：顺序存储（数组），链式存储（指针，引用型数组实现）</li>
<li>索引存储方法：散列存储方法：散列函数的书写是关键。</li>
<li>时间复杂度：一个算法执行所耗费的时间，所有语句执行之和，而每条语句执行时间是该语句执行一次的时间和执行次数的乘积。</li>
<li>时间渐进复杂度：O（1）&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n3)&lt;O(n3)&lt;O(2n);</li>
<li>空间复杂度：算法所需要的存储量。</li>
</ol>
<p>###面试题开始了###</p>
<ol>
<li>iframe使用的场景：ajax上传文件，加载别的网站的内容（广告），在上传图片时，不用flash实现刷新，跨域访问的时候可以使用。</li>
<li>在html中有三种结构特征：树结构，层次结构，框结构。iframe属于框结构的一种。每个iframe都是一个独立的沙箱，他们拥有自己的window以及dom.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###隐藏元素###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;overflow:hidden(占据空间，无法点击)&lt;/li&gt;
&lt;li&gt;opacity:0(占据空间，可以点击)&lt;/li&gt;
&lt;li&gt;visibility:hidden(占据空间，无法点击)&lt;/li&gt;
&lt;li&gt;display:n
    
    </summary>
    
    
      <category term="面试" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于图片的一些问题</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-关于图片的一些问题/</id>
    <published>2017-03-13T12:20:55.000Z</published>
    <updated>2017-03-17T05:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>###图片格式###</p>
<ol>
<li>jpg:这种图片一生成就是有损的，他把一些不打算不打算保存的数据抹掉，可支持有损压缩，不支持透明，动画，非矢量。</li>
<li>我们常见的图片格式是不能保存透明信息，系统会默认为白色背景。gif可以保存透明信息，但是gif最多有256种颜色，只能用在对图片要求不高的场景。</li>
<li>png可以支持无损压缩，而且可以很好地保存透明的信息。</li>
<li>jpeg：在拷贝照片的时候看到，一般都是我们先保存jpg,这种图片比较大是因为里面保存了相机里面拍摄的参数，色相，饱和度，对比度。可以直接的打印。</li>
<li>png:网页中用的最多，应为它支持透明，但是不考虑他的大小么？</li>
<li>盒模型溢出问题：用min－Height来解决溢出行为。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###图片格式###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jpg:这种图片一生成就是有损的，他把一些不打算不打算保存的数据抹掉，可支持有损压缩，不支持透明，动画，非矢量。&lt;/li&gt;
&lt;li&gt;我们常见的图片格式是不能保存透明信息，系统会默认为白色背景。gif可以保存透明信息，但是gif
    
    </summary>
    
    
      <category term="小技巧" scheme="https://github.com/skoll1/libateer.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>页面优化</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-页面优化/</id>
    <published>2017-03-13T06:07:57.000Z</published>
    <updated>2017-03-21T14:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>###dns预加载</p>
<ol>
<li><ol>
<li>用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv="x-dns-prefetch-control" content="on"></li>
</ol>
</li>
<li><link rel="prefetch" href="http://www.example.com/"> <!-- Firefox --> </li>
<li><link rel="prefetch" href="/images/test.jpg">图片都可以</li>
<li><meta http-equiv="x-dns-prefetch-control" content="on"></li>
<li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.itechzero.com&quot;&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//api.share.baidu.com&quot;&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//bdimg.share.baidu.com&quot;&gt;</code></li>
<li><ol>
<li>尽量减少HTTP请求。合并文件。csssprites(www.csssprites.com)</li>
</ol>
</li>
<li>使用cdn。</li>
<li>设置头文件过期或是静态存储。</li>
<li>Gzip压缩。</li>
<li>把css放在头部。把js放在底部</li>
<li>避免css表达式。</li>
<li>减少dns查询。</li>
<li>一些较为公开的js.css文件可以使用外链的形式。</li>
<li>减少重定向。</li>
<li>删除重复脚本</li>
<li>用get 方法来进行ajax交互。</li>
<li>预加载组建。</li>
<li>减少dom结构，更多的dom复杂的页面结构意味着需要更多的响应时间。</li>
<li>iframe:详细解释</li>
<li>cookie的使用。</li>
<li>js访问DOM是很慢的，尽量减少不用js构建网页结构。</li>
<li>使用事件代理。不要为dom树中的元素附加过多的事件句柄，并且这些被频繁触发。</li>
<li>图片要用多大就用多大的，网页内改变图片大小，它本身的大小是不会变化的。</li>
<li>别替用户做决定。</li>
<li>别让我等。别让我想。（包装好自己的网站，关注用户极其行为，引导用户，）别让我烦。缩短途径就是帮用户偷懒，那就是好的用户体验。</li>
<li>目标信息要醒目而且近，距离越远，越难点击。<br>###初级优化###</li>
<li>减少http请求</li>
<li>使用内容发布网络</li>
<li>添加expires头</li>
<li>Gzip压缩组件</li>
<li>减少dns查询</li>
<li>避免重定向</li>
<li>配置ETAG</li>
<li>使用AJAX缓存。</li>
<li>YSlow规则来重构代码</li>
<li>js代码的3个速度0.1 ,1,10.</li>
<li>webworker</li>
<li>想要开发离线应用，首先需要一种本地缓存和拦截文档的方法。还需要一种储存包括新旧两种文件的方法。d</li>
<li>当web worker不可用的话，使用greats和js定势器，来拆分代码。</li>
<li>拆分初始化加载，知道那些是必须加载的，那些是可以后来加载的。页面初始化，</li>
<li>script的阻塞行为，但浏览器解析dom的时候一但遇到script标签，就会立即下载并执行，与此同对浏览器的文档解析会停止，直到script标签的结束，出现这种阻塞行为一方面是因为浏览器的ui渲染，交互行为都是单线程操作，另一方面是因为script里面的代码可能会影响到后面文档的解析。</li>
<li>优化方案：尽量把脚本放在文档的后边，尽量按照脚本之间的依赖关系放在一个文件中，</li>
<li>延迟脚本：defer属性，可以让文档树全部解析完毕后触发，但不是所有的浏览器都支持这个属性。</li>
<li>动态脚本：用脚本创建script元素，设置src<br>function loadJS(url, callback){<br>var script = document.createElement(‘script’);<br>script.type = ‘text/javascript’;<br>if(script.readyState){  // 兼容IE的旧版本<br>script.onreadystatechange = function(){<br>  if(script.readyState == ‘loaded’ || script.readyState == ‘complete’){<pre><code>script.onreadystatechange = null;
callback();
</code></pre>  }<br>}<br>}<br>else{<br>script.onload = function(){<br>  callback();<br>}<br>}<br>script.src = url;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);<br>}<br>19.<br>loadJS(‘a.js’, function(){<br>loadJS(‘b.js’, function(){<br>loadJS(‘c.js’, function(){<br>  app.init();<br>})<br>})<br>})</li>
<li>xmlhttprequest动态插入；优点是可以：懒加载：也就是下载好了可以不执行，等她需要的时候在用<br>function xhrLoadJS (url, callback){<br>var xhr = new XMLHttpRequest();<br>xhr.open(‘get’, url, true);<br>xhr.onreadystatechange = function(){<br>if(xhr.readyState == 4){<br>  if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<pre><code>var script = document.createElement(&apos;script&apos;);
script.type = &apos;text/script&apos;;
script.text = xhr.responseText;
eval(xhr.responseText);  // 执行代码
document.body.appendChild(script);
callback();
</code></pre>  }<br>}<br>}<br>xhr.send(null);<br>}缺点是不能跨域加载。</li>
<li>js加载与执行：合并多个标签，减少请求次数</li>
<li>xor注入 var xhrObj=getXHRObject();xhrObj.onreadystatechange=function(){if(xhrObj.readyState==4){var }}getXHRObject(){var xhrObj=false;try{xhrObj=new XMLHttpRequest()</li>
<li>scriptdomelement: 创建，地址，加入，三步。允许跨域加载</li>
<li>忙指示器在某些情况下，我们需要忙指示器来告诉用户网页正在加载，其他情况下，最好不现实，鼓励用户和页面互动。</li>
<li>不同决策情况：不同域，无序，scriptdomelement</li>
<li>不同域，保持顺序：script defer，scriptdomelement</li>
<li>同域，无序，无忙指示器。xhreval xhr </li>
<li>无阻塞加载脚本可能出现竞争状态，我们关注依赖外部脚本里东移的标识符的行内脚本来，如果外部的脚本异步加载不考虑行内代码的依赖，那么可能会由于竞争出现为定义标示符的错误。以下就是整合两个代码之间的关系</li>
<li>绝大多数的网页在加载外部脚本的同时也包含使用了外部脚本定义的表示符内的行内脚本，因为行内脚本依赖于外部脚本，那么</li>
<li>在执行行内脚本的时候，必须保证外部脚本已被加载。</li>
<li>异步加载保证执行顺序。把行内代码和依赖行内代码的外部脚本整合起来。</li>
<li>var domscript=document.createElement(‘script’);</li>
<li>domscript.src=”menu.js”;document.getElementsByTagName(‘head’)[0].appendChild(domscript);</li>
<li>domscript.onloadDone=false;</li>
<li>domscript.onload=function(){</li>
<li>domscript.onloadDone=true;</li>
<li>init()</li>
<li>};</li>
<li>domscript.onreadystatechange=function(){</li>
<li>if((“loaded”===domscript.readyState||”complete”===domscript.readyState)&amp;&amp;!Domscript.onloadDone){</li>
<li>domscript.onloadDone=true;</li>
<li>init();</li>
<li>}</li>
<li>}</li>
<li>document.getElementsByTagName(‘head’)[0].appendChild(domscript);</li>
<li>// 单个脚本的情况下。</li>
<li>managed XHR技术是实现多个的方法。</li>
<li>＊行内脚本的的一些小知识点</li>
<li>行内脚本不仅阻塞下载，还阻塞渲染，</li>
<li>异步加载执行行内脚本：</li>
<li>function longCode(){</li>
<li>var tSatrt=Number(new Date());</li>
<li>while((tSatrt+5000)&gt;Number(new Date())){};</li>
<li>}</li>
<li>setTimeout(longCode,0);</li>
<li>在样式表后面的行内脚本会阻塞所有后续资源的下载。</li>
<li><ol>
<li>了解浏览器工作的原理：哪怕只知道个大概，也能知道在什么地方来优化</li>
</ol>
</li>
<li>减少html中元素的元素的数量，用最少量但是必须的html语义化去布局。</li>
<li>减少重绘，在绘制完成之后在动态的更改dom结构或者css样式都会引发浏览器的重绘。</li>
<li>浏览器的重绘：</li>
<li>性能的损耗直接取决于动态修改的范围。如果只是改动一个css的话，那么只是重绘一个元素，如果是在原来的地方加上一个元素的话，那么就是改变所有兄弟元素，会引发大量重绘。</li>
<li>在改变元素的时候，能改多深就改多深，这样越独立，对其他的节点影响越小。</li>
<li>如果要对dom操作的话，尽量合并到一次做完而不是奉承一次一次的做。css是我们改变dom的好伙伴。</li>
<li>浏览器的渲染页面是在渲染一系列的盒子，而且这些盒子里面还包括了许多其他的盒子。所以说我们浏览器的天然渲染模型是“很多盒子套许多盒子”，</li>
<li>完美实现这“盒子套盒子”的方法就是把一个或几个元素抱在一个大盒子里面。</li>
<li>渐进增强：</li>
<li>使用特征检测来显示渐进增强：不能用浏览器版本的检测来判断页面优化，而是要用特征检测：这样你可以检测是否有这个功能，悠久使用他，没有就给用户提供一个有吸引力的替代品。使用modernizr检测文档，开放者源码库</li>
<li>在任何时候都要尽可能的用css来完成交互，因为浏览器天生就可以处理它们，同时css的代码量要比js少很多。</li>
<li>性能准则：</li>
<li>cdn加速服务</li>
<li>页面加载时间，加载时间每延长100ms，销量就涨1%。</li>
<li>减少http请求：了解多少资源是可以一同加载的，（看苹果的网站：页面加载很快，其他资源是一组一组的加载，如何分组是根据浏览器能并行链接几个来决定的。可以把资源文件放置在不同的域名下，这种做法充分利用了浏览器并发）2:合并资源文件，大的文件比小的文件好，把内容尽可能的合并成较少的文件。图片精灵的好处是谁让你只是用了一小部分，但还是增长图片都被缓存好了，这样就不用每一次都去请求图片。</li>
<li>避免空的src和href属性，增加过期头，过期的日期要设置的非常远，那样浏览器就会缓存文件，第二次访问就会很方便。</li>
<li>Gzip压缩所有的文字代码，但不是图片。</li>
<li>避免使用css表达式，移除不用的css语句，不规定图片的宽和高（浏览器每次渲染都要猜，而且猜错的概率很大）浏览器在布局的好时候，会给每一个元素留下特定的位置，如果没有大小的话，只有来猜了。</li>
<li>提高开发效率：响应式网页设计</li>
<li>媒体查询功能:手机横，竖布局都要考虑到。。。我去。。。</li>
<li>自适应图片：img{max-width:40px}</li>
<li>弹性栅格：预先定义好者可以完美适应者鞋栅栏的样式，12个,classOne,classTwo,classThree———.</li>
<li>页面重用机制：</li>
<li><ol>
<li>所有看到的东西都是通过引擎绘制出来的，更新频率取决于开发者指定的FPS，帧数越高，视觉上感觉越流畅，60是满值。在实际运行情况中，性能还取决于JS解析器的效率，制定的FPS帧数可能在低性能解释器中得不到体现，所以这不是开发者所能决定的，说一只能做的是尽可能的优化代码，关注每帧执行逻辑代码带来的CPU消耗，好需要注意每帧调用回吐指令的数量以及CPu的纹理提交速度</li>
</ol>
</li>
<li>基准测试：实时监测当前性能。FPS越高越好。Sprite：渲染节点数量：越低越好</li>
<li>内存优化：对象池：涉及到不断重复使用的对象。在初始化应用的程序期间创建一定的数量的对象并将其存储在一个池中。对一个对象完成操作后，将该对象放回到池中，在需要新对象时可i对其进行检索</li>
<li>h5内嵌框架标签元素，iframe<iframe src="http://www.divcss5.com/" width="400" height="200" scrolling="yes">使用框架不利于网页搜索的优化。</iframe></li>
<li>闭合标签就是标签又开始，有结束</li>
<li>h5可以支持很多标签不闭合</li>
<li>无内容元素：是一种不能包含任何内容的特殊的元素，例如:br,hr,img,link,meta,area,base,col,command,embed,keygen,param,source,track,war,渊源：sgml时期有一种标签叫无尾标签，当一个标签内只有简单的文字的时候，就可以使用无尾标签无须闭合这个标签了。</li>
<li>接下来升级为无标签元素，<br>这样写起来自然，当h5的时候，他们是这样说的：HTML5 的语法完全兼容 HTML4 和 XHTML1，但是不兼容 SGML 中那些晦涩的 HTML4 特性。比如无尾标签（&lt;em/content/）。</li>
<li>自闭合标签到底要不要加／号，</li>
<li>创建按钮的四种方法<input type="button"> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><input type="submit"> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。<button> 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题。其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮.如果只是歌单纯的按钮，触发一些动画动作，那么button,当要把画面数据提交给服务器的submit。</button></li>
<li>button和input:button.在button内部，您可以放置内容，比如文本或图像。这是该元素与实用input元素不同的之处。button与button之间的所有内容都是按钮内容，其中包括可接受的正文内容，文本或者多媒体内容。需要注意的是要始终给她加上type属性，IE的默认类型是button而其他的浏览器着submit。</li>
<li>web安全色216种，</li>
<li>img上title和alt  title是在鼠标悬停上显示的内容，alt是在某种情况无法显示图片的情况下出现的信息。</li>
<li>网页字体用偶数不用奇数</li>
<li>网页元素</li>
<li>meta：位于文档的头部，定义了与文档相关联的元信息，这些元对象是以名称的形式成对定义的。一个页面可以定义多个meta标签，每个标签分别通过对应的name（关联到http头部）和content（把属性关联到一个名称）属性定义键值，来定义不同的原信息。</li>
<li>base指定所有页面中所有链接的基础路径。如果没有base的话，那么页面所有的相对路径将生成绝对路径作为默认的基础路径。</li>
<li>style的type 指定样式类型，浏览器支持的样式只有css一种，所以这个属性只有css一种，media属性置顶使用的媒体，表明文档在什么时候用什么元素定义的样式。</li>
<li>media属性详解：运算符 and,not ,or,</li>
<li>link:link和style 怎么结合起来用啊？link内部也有一些属性，media.</li>
<li>给网站添加logo。&lt;link rel=“shortcut icon” href=“” type=“image/x-icon”&gt;</li>
<li>预先获取资源：等同于让浏览器在空闲时间或预读取一些资源文档，不造成资源浪费。</li>
<li>link rel=“prefetch” href=“页面地址” 怎样控制什么时候开始。。</li>
<li>这是什么书？真是菜啊。。</li>
<li>异步执行脚本。方法：回调函数，事件监听，观察者模式，promise对象。</li>
<li>meta定义页面关键<meta name="“keywords”" content="“”">设置页面描述：<meta name="“description”" content="“输入内容"">都是为了搜索引擎，只是输入的字数限制不同。<meta name="“author”" content="“"">设置作者信息，<meta name="“robots”" content="“可选值”">：可以限制搜索网站方式，也就是把自己藏起来，</li>
<li>语言和文字:<meta http-equiv="“content-language”" content="“Zh-CN”/"></li>
<li>定时跳转页面：&lt;meta http-equiv=“Refresh” content=“10,url=http:www.baidu.com”&gt;也可以刷新网页</li>
<li>设置网页缓存过期的时间。</li>
<li>禁止从缓存中调用。</li>
<li>删除过期的cookie.</li>
<li>网页过渡效果：什么都可以，我去长见识了</li>
<li>标记文字</li>
<li>强调em.外文或科技术语i.重要的文字:strong.表示不正确和较正s.</li>
<li>为文字加下划线u.小号字体small.添上标sub.下标sup.</li>
<li>表示缩写abbr.定义术语<dfn title="“sdfsdf”">jlkjlklkjl</dfn>;</li>
<li>引用其他处的内容<q cite="“http://baidu.com”">sdkls<p></p>;</q></li>
<li>cite引用其他作品的标题。</li>
<li><ruby>漠&lt;&gt;</ruby></li>
<li>显示图像</li>
<li>图像预先加载</li>
<li>图像区域映射 <img><map>&lt;area shape=“circle coords=“0,100,200,30,9”&gt;</map></li>
<li>使用base64:url格式的图片。data取的数据的协定名称。就是代码表示一张图片，但是不能大于32k.高清图片不能显示，不可以裁成小段么？</li>
<li>生成超链接</li>
<li>指向外部的</li>
<li>使用相对url，相对路径和。绝对路径。</li>
<li>生成页面⚓️点</li>
<li>生成图像链接，电子邮件链接mailto</li>
<li>设定浏览环境——self当前页面打开，_blank创建新页面打开。</li>
<li>组织文字内容</li>
<li>pre：可以定义预格式化的文本。被包围在pre中的元素会保留空格和换行符。而文本也会呈现为等宽字体。pre标签的一个常见的应用就是来显示计算机的代码可以显示非格式化的内容。</li>
<li>应用他处内容block quote 他们之间的所有文本都会被从常规的文本中分离出来，经常会在左右两边缩进，而且有时会用斜体，也就是说，块引用有自己的空间。</li>
<li>dialog h5中用于定义对话框或窗口</li>
<li>划分文档结构：标题的使用是十分常见的，页面标题，模块标题，块区标题，各式各样的标题都可以使用h1-h6来实现。</li>
<li>hgroup 给标题分组隐藏起来，那就可以出现多个了。</li>
<li>section:对内容进行块划分，代码层次结构简单。在一个页面里面可以使用多个footer，既可以做页面的整体页脚，也可以做为一个内容区块的结尾。</li>
<li>语义化写代码article大段纯文字   附注栏：aside. </li>
<li>adress在页面输出联系人信息。</li>
<li>details summary 配合起来可以提供一个显示和隐藏文字的小工具。</li>
<li>使用下拉列表：label for=“sd”我最爱的球队 input type=“text” name=“team” id=“team_list”<pre><code>1. datalist id=“team_list&quot;
2. option                                                                     
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###dns预加载&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;用meta信息来告知浏览器, 当前页面要做DNS预解析:&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="页面优化" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/13/best-1-浏览器缓存机制/</id>
    <published>2017-03-13T05:45:16.000Z</published>
    <updated>2017-03-13T05:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>1. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1. &lt;/p&gt;

    
    </summary>
    
    
      <category term="浏览器缓存机制" scheme="https://github.com/skoll1/libateer.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>面试html-css-2</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-%E9%9D%A2%E8%AF%95html-css-2/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-面试html-css-2/</id>
    <published>2017-03-12T08:08:01.000Z</published>
    <updated>2017-03-23T13:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>标准盒模型：外盒尺寸：h+p+b+m  内盒：h+p+b</li>
<li>ie:外盒h+mie 盒子模型的 content 部分包含了 border 和 pading,所以才是h+m</li>
<li>在网页上显示的时候：实际的占据位置和他的实际大小是不一样的，因为margin是看不到的。</li>
<li>在选择的时候，我们要用IE的标准盒子模型。在doctype中声明。如果不这样，那就会按照自己的默认方式去解析。</li>
<li>所以box-sizing:如果值为border-box的话，那就是IE那个样子解析的，如果是content-box的话，就是w3c的解析方式。</li>
<li>原来border一直都是跟随着padding在变，而margin择跟随border变。</li>
<li>Box-sizing统一form元素风格：、box-sizing拯救我们的布局</li>
<li>使用not()选择器来决定表单是否显示边框。为最后一个元素去掉边框。 .nav li:not(:last-child){border:1px solid red;}</li>
<li><p>更简单的垂直居中方式：align-items: center;display: flex;.container {<br>margin: 0 auto;就这几项。<br>}</p>
<ol>
<li>a[href]:not([class]) {<br>color: #008000;<br>text-decoration: underline;<br>}<br>给默认连接添加样式。通过cms系统插入的链接，通常没有class属性，以上样式可以甄别他们，而且不会影响其他样式。</li>
</ol>
</li>
<li>利用负的nth-child来选择元素。使用负的nth-child可以选择1-n个元素。</li>
<li>.container {   height: 0;   padding-bottom: 20%;   position: relative; }</li>
<li>.container div {   border: 2px dashed #ddd;    height: 100%;   left: 0;   position: absolute;   top: 0;   width: 100%; }子元素的div将保持宽高为1：5.</li>
<li><p>.slider {   height: 200px;overflow-y: hidden;width:300px;background-color: red;transition: all 0.3s ease; }<br>.slider:hover {  height: 300px;  overflow-y: scroll;background-color: yellow;}模拟滑块的划动。</p>
</li>
<li><p>img {<br>display: block;<br>font-family: Helvetica, Arial, sans-serif;<br>font-weight: 300;<br>height: auto;<br>line-height: 2;<br>position: relative;<br>text-align: center;<br>width: 100%;<br>}<br>img:before {<br>content: “We’re sorry, the image below is broken :(“;<br>display: block;<br>margin-bottom: 10px;<br>}</p>
</li>
</ol>
<p>img:after {<br>  content: “(url: “ attr(src) “)”;<br>  display: block;<br>  font-size: 12px;<br>}图像没显示的时候的处理方法。</p>
<ol>
<li>当触发select的下拉列表时，为了避免表单元素在移动浏览器（IOS Safari 等等）上的缩放，加上font-size：</li>
</ol>
<p>input[type=”text”],<br>input[type=”number”],<br>select,<br>textarea {<br>  font-size: 16px;<br>}</p>
<p>###icon字体进化###</p>
<ol>
<li>四种字体格式，eot微软，woff,web最佳字体。ttf,mac和微软操作系统最常见的字体。</li>
<li>svg：由w3c指定的开放的标准的图形格式。</li>
<li>可以通过在标签里面添加before来插入小图标。那个输入就在content里面，但是为设么这样做也能实现前面的css控制呢？</li>
<li>node.js优势。高并发，聊天，实时推送。</li>
<li>doctype标签是一种标准通用标记语言的文档类型声明，她的目的是告诉通用标记语言文档解析器应该用什么样的文档类型定义来解析文档。他是将特定的标记通用语言或者XML文档与文档类型定义联系起来的指令。他出现在文件的第一行。只有确定了一个正确的文档类型，超文本标记语言或者可扩展超文本标记语言中的标记和层叠样式标才能生效，甚至对JS脚本都有影响。</li>
<li>严格模式是浏览器根据规范去显示页面；混杂模式是以一种向后兼容的方式去显示，决定浏览器如何渲染网站即浏览器使用哪种规范去解析网页。她的触发是根据doctype是否存在和使用的那种dtd来决定。mozilia ,safair还有一种“几乎标准模式”，除了在处理表格上的方式有一点细微的差异之外。其他都不变。</li>
<li>dtd文档定义类型document type definition 是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。是标准通用标记语言和可扩展语言的一部分</li>
<li>空元素img ,input,br,hr,</li>
<li><ol>
<li>h5不基于sgml，因此不需要对dtd引用，当需要doctype来规范浏览器的行为，让浏览器按照她们的应该的方式运行。</li>
</ol>
</li>
<li>h5基于什么机制实现运行？既然他不基于sgml.沿用了h5的语法，过去的是sgml语法的一个子集，更简洁，更人性化。</li>
<li>link在页面载入时加载css，而@是在网页完全载入以后加载</li>
<li>ink,@import url() .link是xhtml标签，除了加载css时间外，还可以定义rss等其他事件，@只能加载css。</li>
<li><ol>
<li>link是xhtml标签，没有兼容问题，而@低版本浏览器不支持。</li>
</ol>
</li>
<li>link支持js改变dom去改变样式，而@不支持</li>
<li>ie:trident 三叉戟</li>
<li>firfox:gecko 壁虎。</li>
<li>　<a href="download_pdf.php" download="somefile.pdf">下载PDF文件</a></li>
<li><ol>
<li>命名规则：BEM高级别的类。，元素，修饰符代表状态。<br>.site-search{} /<em> 块 </em>/<br>.site-search__field{} /<em> 元素 </em>/<br>.site-search–full{} /<em> 修饰符 </em>/</li>
</ol>
</li>
<li>使用bem的诀窍是，你要知道是什么时候要写成bem格式。因为某些东西确实是位于一个块内的内部，但这并不意味着他就是bem所说的元素。</li>
<li>遵循单一功能，意味着每一个模块内斗应该有一个单一的功能，并且应该由这个类完全分装起来，单一的原则意味着每一段代码，类，模块都只做一件事。当我们提交css文件时，意味着每隔独立的组建，都应该有自己的 css文件。</li>
<li>position 和display margin collapse overflow float这些特性叠加后的会怎样？</li>
<li>1.<br>bfCbox：css布局的对象和基本单位，一个页面就是有很多个box组成的，元素的类型和isplay属性，决定了这个盒子的布局类型。。不同的盒子会参与不同的文档渲染流程，因此，box内的元素会以不同的方式渲染。</li>
<li>bfc布局规则，内部的box会在垂直方向上，一个接一个的放置。box的垂直方向的距离由margin 决定，属于同一个的bfc的两个相邻的box的margin会发生重叠。</li>
<li>bfc就是页面上的一个隔离的独立容器，容器的元素不会影响到外面的雨啊怒，反之亦然。</li>
<li>会生成bfc的元素有这些?根元素， float元素！＝none，position=absolute,fixed，display=inline-block,table-cell,table-caption,flex,inline-flex.over!=visible.每个元素的margin-box左边，与包含块border-box的左边相接触，即使存在浮动也一样。</li>
<li>m是用来隔开元素和元素之间的距离，padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素之间互不相干，padding用来元素与内容之间的间隔，让内容和元素之间由一段呼吸距离。</li>
<li>最根本的区别：是否创造了新的元素：需要在新添加元素加以标示的，就是伪元素，如果在既有元素上添加类名，就是伪类，伪元素表示某个元素的子元素，他们虽然理论上出现，但是实际上并不存在于文档树中。</li>
<li>伪类用一个冒号表示，伪元素用两个表示加以区分。</li>
<li>html只能表示12-16的字体，以上的字体锯齿大到没朋友，16以上的都用图片表示</li>
<li>浮动的历史：包裹特性：bfc块级格式化上下文。</li>
<li>浮动具有破坏性。会让父级元素塌陷。</li>
<li>浮动原来的作用是实现文字环绕。</li>
<li>匿名函数的优势：将匿名函数当做参数传递给其他函数，这样接收函数就能够利用我们传递的函数完成许多事情，2：利用匿名函数执行一些一次性的任务。</li>
<li>(function (count){<br>if(count&lt;5){<br>console.log(count);<br>arguments.callee(++count)<br>};<br>})(1);</li>
<li>window是js在浏览器的全局对象。window的全局方法与浏览器相关的属性。</li>
<li>页面导航方式：window.href=””location.href=””.location.assign=””</li>
<li>document.documentElement是整个html的根节点。</li>
<li>利用childrNodes，parentNode。这些我们可以实现结构结构之间的自有导航。并处理相关的文件操作，但是空白处也会成为一个文本节点，这就会让我们操作dom有一点不方便。</li>
<li>p.previousSibling :p.nextSibling;</li>
<li>document.title;document.domain(当前载入页面的域名访问);document.referrer.</li>
<li>置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。img,input,select,textarea,</li>
<li>元素的重绘：元素的外观发生改变，且在没有改变布局的情况下发生，如改变Outline,visibility,background,color,不会影响到dom结构渲染。</li>
<li>reflow：影响到dom的结构渲染，同时会发生重绘，他会改变他本身和所有父辈元素，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。</li>
<li><tr><br>    <td>123</td><td>456</td><td>789</td>  //横着来数据排列<br></tr></li>
<li><dl><br><dt>sdf</dt><br><dd>123</dd><br><dd>456</dd></dl>  //竖着来排列</li>
<li><code>&lt;input type=&quot;text&quot; list=&quot;brow&quot;&gt;
&lt;datalist id=&quot;brow&quot;&gt;
&lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
&lt;option value=&quot;2&quot;&gt;12&lt;/option&gt;
&lt;option value=&quot;3&quot;&gt;123&lt;/option&gt;
&lt;option value=&quot;4&quot;&gt;1234&lt;/option&gt;
&lt;/datalist&gt;</code></li>
<li><keygen name="security">是否在提交表单时添加钥匙。</li>
<li>output输出结果，也是html五的新属性。</li>
<li>onchange()改变失去焦距触发，blur()只要失去焦距就会触发。</li>
<li>域名必须携带“http”协议.这个是真的。</li>
<li>h1是最大的标题，通常我们看到的内容，都是放在body里面的。</li>
<li>em起强调的作用。</li>
<li>sup下标，sub上标。</li>
<li>pre代码格式化，最后显示出来的跟源码中的样式一样，所见即所得。</li>
<li>根据标题所在不同层级选取不同的h1,h2,h3，title标签用来描述网页最上层的标题。应该讲h1作为主标题，其次是h2,然后是h3。</li>
<li>target=”_self”,target=”_blank”,target=”_top”,target=”_parent”;</li>
<li>dl&gt;dt&gt;dd是用来定义列表的。</li>
<li>div标签可以用来定义文档中的分区或节。来作为分区工具。</li>
<li>css样式添加的方式 在css文件中@import url(css/style.css) 行内加样式，style标签嵌入，link引入样式。</li>
<li>html负责网页的结构。</li>
</ol>
<p>###表单验证码实现###</p>
<ol>
<li>服务器端生成验证码之后一方面通过图片将验证码返回给客户端，同时在服务器端保存文本的验证码，有服务器端验证输入内容是否正确。</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;标准盒模型：外盒尺寸：h+p+b+m  内盒：h+p+b&lt;/li&gt;
&lt;li&gt;ie:外盒h+mie 盒子模型的 content 部分包含了 border 和 pading,所以才是h+m&lt;/li&gt;
&lt;li&gt;在网页上显示的时候：实际的占据位置和他的实际大小是不一样的
    
    </summary>
    
    
      <category term="面试" scheme="https://github.com/skoll1/libateer.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>css-代码案例</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-css-%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/12/best-1-css-代码案例/</id>
    <published>2017-03-12T05:57:05.000Z</published>
    <updated>2017-03-17T05:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>####做页脚效果：让网页的footer始终位于浏览器串口底部###</p>
<ol>
<li><p><code>html, body {
height: 100%;
margin: 0;
}  
.wrapper {
min-height: 100%;
margin-bottom: -50px;
}
//这个不就是那那个margin-bottom改变下一个元素的参考位置么？主要是min-height:100%;
.footer{
height: 50px;
background-color: red;
}</code></p>
</li>
<li><p><code>&lt;div class=&quot;wrapper&quot;&gt;
   content
 &lt;div class=&quot;push&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</code>主要是必须有push结构</p>
</li>
<li><p>方法一的变形：html, body {<br>height: 100%;<br>margin: 0;<br>}<br>.content {<br>min-height: 100%;<br>}<br>.footer {<br>height: 50px;<br>margin-top: -50px<br><code>&lt;div class=&quot;content&quot;&gt;
 &lt;div class=&quot;content-inside&quot;&gt;
   content
 &lt;/div&gt;
&lt;/div&gt;
&lt;footer class=&quot;footer&quot;&gt;&lt;/footer&gt;</code></p>
</li>
</ol>
<ol>
<li><code>*{margin: 0;padding: 0;}
html {
height: 100%;
}
body {
min-height: 100%;
display: flex;
flex-direction: column;
}
.content {
flex: 1;
}
.footer{
background-color: red;
}</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####做页脚效果：让网页的footer始终位于浏览器串口底部###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;html, body {
height: 100%;
margin: 0;
}  
.wrapper {
min-height: 100%;
margin-bo
    
    </summary>
    
    
      <category term="css-代码片段收集" scheme="https://github.com/skoll1/libateer.github.io/tags/css-%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/11/best-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/11/best-1-面向对象/</id>
    <published>2017-03-11T11:55:48.000Z</published>
    <updated>2017-03-20T16:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>对象的情况和数组很相似，只是他的键值类型是自定义的，也就是我们常说的索引方式不再局限于数字了，可以使用一些更加人性化的键值。也就是我们用数组来表示索引型数组，而用对象表示关联性数组</li>
<li>访问对象的方式/.[]如果我们访问的属性名字是不确定的就必须要用中括号来表示，它允许我们在运行的时候通过相关的变量来实现先关属性的动态属性的存取。</li>
<li>可以使用一些很奇怪的属性名字，但是遇到保留字的情况要加上‘’这个</li>
<li>构造函数的方式来创建对象：也就引出了创建对象的方式：工厂的方式，构造函数方式，原型方式，混合的构造函数，原型方式：function Parent(){<br>this.name=”脚本”;<br>this.age=4;<br>};<br>Parent.prototype.lev=function(){<br>return this.name;<br>};;<br>var x =new Parent();<br>alert(x.lev());</li>
<li>function hero(name){this.name=name};</li>
<li>var hero=new hero(“hah”);</li>
<li>hero.name</li>
<li>实质：创建一个新的对象，使this指向新的对象，</li>
<li>新对象的prototype指向构造函数的prototypr，返回this，所以创建的实例的实质是获得了一个引用实现原型链的继承。</li>
<li>全局变量只不过是全局对象的属性罢了。这就是实质window,document</li>
<li>如果我们定义了一个构造函数又不应new来调用，那么就会返回unefined，如果我们使用###new###来创建对象，那么this就会指向这个该对象。</li>
<li>insatnceof操作符还可以干这个测试某个属性是不是由某个构造函数的的构造属性。function hero(name){this.name=name};</li>
<li>var h=new hero(“xixi”);</li>
<li>var result=h instanceof hero;</li>
<li>result</li>
<li>直接使用=号，当我们拷贝某个对象或是将它传递给某个函数时，旺旺都是传递的某个对象的引用。因此我们在拷贝上做任何的改动，都会影响原对象的值。</li>
<li>内建对象的三种分类：数据封装类函数：，工具类函数。错误对象类函数。</li>
<li>引用类型不在变量中保存对象，所以本例中的object()实际上并不包含独享的，而是一个指向内存中实际对象所在位置的指针。这是对象和原始值得一个基本差别。</li>
<li>就像他们复制拷贝的时候的差别b获取值是a值的一份拷贝，虽然，两个变量的值是相等，但是两个变量保存两不同的基本数据类型值。b只是保存了a复制的一个副本。所以，当b的值改变时，a的值依然是10;<br>下面，两个Boolean变量bl和bl1同样是基本数据类型，同样保存两个不同的基本数据据类型值，bl1保存bl复制的一个副本。而对于对象来说：我们声明了一个引用数据类型变量obj1，并把它赋值给了另外一个引用数据类型变量obj2。当我们obj2添加了一个name属性并赋值”我有名字了”。obj1同样拥有了和obj2一样的name属性。说明这两个引用数据类型变量指向同一个堆内存对象。obj1赋值给obj2，实际只是把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象。</li>
<li>两个对象之间的原型关系类似于继承，每个对象都可以把另一个对象作为他的原型，并继承原型的所有属性。对象通过内部属性[prototype]指定他的原型。每个对象都有这个属性，而他可以是null，通过prototype属性连接成的对象称为原型链</li>
<li>js的值可以在不同的框架之间穿来穿去，当你试图去鉴别一个弱类型的，因为每一个页面都有自己的上下文全局，当把一个数组从一个框架传到另一个框架的时候，instanceOf就无法识别，因为那个数组是来自不同框架之间的Array()，所以就要用Array.isArray()函数了。</li>
<li>函数就是对象，使他区别于其他对象的一个最重要的特点就是函数存在一个被称为[[call]]的内部属性，他不可以被代码访问到，但是定义代码的执行行为。</li>
<li>把那些看起来名字超级Nb的东西搞懂真的很有成就感。</li>
<li>js根据参数的不同类型决定执行的版本就叫做函数重载，但在JS中可以接受任意数量，类型的函数，所以根本不存在重载，但是我们可以根据参数的一些特性来模拟决定函数执行从而模拟其行为。</li>
<li>当一个属性第一次被添加给一个对象时，Js在对象内调用了一个[put]方法，[put]方法会在对象上创建一个新的节点来保存对象，这个操作不仅指定了初始值，而且也定义了一些属性。注意这个创建的是自有属性，所有对他的操作都必须通过该对象才行。【set】方法是将属性的当前值替换为新值。</li>
<li>如果想要删除一个属性必须用delete,其他的都是简单的覆盖</li>
<li>检查对象里面有没有属性的方法；in hasOwnProperty()这个只能检查自有属性，不能检查继承来的;还有一一个就是所有检查的属性必须加上双引号。for(var i in p){console.log(i);}这个也可以。Object.keys(p);返回的是可枚举的属性。</li>
<li>上面的组合：通过组合hasOwnProperty()方法和in操作符，就可以区分该属性是否存在于原型中。for-in循环与hasOwnProperty()方法输出对象的原型属性。使用in操作符判断某个属性是否存在于对象的实例或原型中。使用for-in循环输出对象所有可枚举的实例属性与原型属性</li>
<li>实例属性指的是在构造函数方法中定义的属性，属性和方法都是不一样的引用地址例如。。。原型属性指的是不在构造函数中定义的属性，属性和方法都是一样的引用地址，例如function CreateObject(){}<br>CreateObject.prototype.name=’ZHS’;</li>
<li>对象的访问器属性：包含getter和setter函数。读取访问器属性时，调用getter函数，返回有效的值；在写入访问器属性时，调用setter函数传入新值。它包含了4个特性： </li>
<li>[[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 </li>
<li>[[Enumerable]]：表示能否用for-in循环返回。 </li>
<li>[[Get]]：读取属性时调用的函数，默认undefined。 </li>
<li>[[Set]]：写入属性时调用的函数，默认undefined。</li>
<li>访问器属性甚至包括上面这些都无法直接被定义只能使用函数来修改或访问：var person = {<br> age:100<br>};</li>
</ol>
<p>Object.defineProperty(person,”name”,{<br>    configurable:false,能否删除这个属性，能否修改这个属性，能否把这个属性改为访问器属性。<br>    writable:false,<br>    value:”xiaochang”<br>})</p>
<ol>
<li>另外需要注意的是当configurable设置为false后无法再将其改为true，且除了writable之外，无法修改其它特性。在configurable为true的情况下可多次调用Object.defineProperty( )修改同一属性。</li>
<li>访问器属性：包含getter和setter函数。读取访问器属性时，调用getter函数，返回有效的值；在写入访问器属性时，调用setter函数传入新值。它包含了4个特性： </li>
<li>[[Configurable]]：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 </li>
<li>[[Enumerable]]：表示能否用for-in循环返回。 </li>
<li>[[Get]]：读取属性时调用的函数，默认undefined。 </li>
<li>[[Set]]：写入属性时调用的函数，默认undefined。</li>
<li>Object.defineProperties(person,{<br> name:{<pre><code>get:function(){
    return this._name;
}
</code></pre> },<br> age:{<pre><code>set:function(newage){
    this._age = newage;
}
</code></pre> },<br> tel:{<pre><code>get:function(){
    return this._tel;
},
set:function(newtel){
    this._tel= newtel;
}
</code></pre> }<br>});</li>
</ol>
<p>6.显示原型：proyotype属性，这个属性指向函数的原型对象。每个函数创建之后都有这个，指向函数的原型对象，但是除了function.prototype.bind方法构造出来的函数是个例外，他没有这个属性。该属性是一个原型对象用来创建新的对象实例。所有被创建的对象实例都会共享对象原型，且这些对象实例可以访问原型对象的属性。</p>
<ol>
<li>隐式原型：js中任何一个对象都由一个内置属性[[prototype]],在es5之前没有标准的方法访问这个内置的属性，但是绝大多数浏览器支持<em>proto</em>来访问。es5中有了对这个内置标准属性的get的方法。Object.getPrototypeOf()。除了Object.prototype这个对象例外。他的<em>proto</em>值为null。</li>
<li>他们二者的关系，隐式原型指向创建这个对象的函数的prootype。</li>
<li>始终确保用new来调用构造函数，否则就会出现改变全局对象的风险，而不是创建一个对象。当不是被new调用的时候，构造函数中的this对象等于全局对象中的对象。</li>
<li>所有的对象都是继承到object.prototype().</li>
<li>所有新创建的对象先是继承object的prototype的。</li>
<li>`function rect(l,w){<pre><code>this.l=l;
this.w=w;
</code></pre>}<br>rect.prototype.get=function(){<pre><code>return this.l*this.w;
</code></pre>}<br>function sound(size){<pre><code>this.l=size;
this.w=size;
</code></pre>}<br>sound.prototype=new rect();<br>sound.prototype.constructor=sound;这两步是继承的关键么？<br>sound.prototype.toString=function(){<pre><code>console.log(this.l)
</code></pre>}<code>为什么这个不行了。。</code>function person(name,age){<br>this.name=name;<br>this.age=age;<br>this.sayname=function(){<br>console.log(this.name);<br>}<br>}</li>
</ol>
<p>function worker(name,age,job){<br>  this.job=job;<br>}<br>worker.prototype=new person();<br>worker.prototype.constructor=worker;`<br>难道上面的是这样写的？<br>for(var i=0;i&lt;person.prototype){<br>    worker.prototype[i]=person.prototype[i];<br>}<br>原型属性拷贝加原型链结合。</p>
<p>`function person(name,age){<br>  this.name=name;<br>  this.age=age;<br>  this.sayname=function(){<br>    console.log(this.name);<br>  }<br>}</p>
<p>function worker(name,age,job){<br>  person.call(this,name,age)<br>  this.job=job;<br>  this.sayjob=function(){<br>    console.log(this.job);<br>  }<br>}<br>worker.prototype=new person();<br>worker.prototype.constructor=worker;`</p>
<ol>
<li>定时器，事件，会出现this乱用，可以先把this赋值为_this.</li>
<li>使用构造器函数的好处就是我们可以在创建对象时接受一些参数，这样，我们就可以用一个构造函数来创建不同的对象了。</li>
<li>constructor这个属性实际上是指向一个用于创建该对象的构造器函数的引用。</li>
<li>传递对象，当我们拷贝某个对象将他传递给某个函数的时候，传递的往往是该对象的引用，因此我们在引用上做的任何改动，实际上也会影响他所引用的原对象。</li>
<li>原型都可以提供方法了，为什么还需要继承？</li>
<li>对象比较：当我们对对象进行比较的时候，当且仅当两个引用指向同一个对象的时候才是true。而如果是不同的对象，及时他们碰巧有了相同的属性和方法，那么也会返回false.</li>
<li>function有一个caller属性，这个属性会返回一个调用该函数对象的外层函数引用。也就是说，如果我们是在（）中调用A（），那么只要在a（）中返回a.caller，那么结果就会返回函数b.</li>
<li><code>function a(){return a.caller;};function b(){return a();}b();function b(){return a();}</code></li>
<li>arguments对象还有一个值得关注的属性，那就是callee,该属性引用的是当前被调用的函数对象。也就是说，如果我们所建的函数的返回值是argument.callee。那么该函数就会在被调用的时候返回自身的调用。</li>
<li>利用原型可以添加方法和属性的方法。</li>
<li><p><code>function person(name,age){
this.name=name;
this.age=age;
this.sayname=function(){
console.log(this.name);
}
}
person.prototype={
price:100,
get:function(){
return this.price;
}
}</code></p>
</li>
<li><p>对于原型来说，最重要的是要理解他的“驻留的概念”，由于在js中，对象都是通过引用的方式传递，因此我们所创建的每一个对象其实都没有自己的副本，也就是说我们可以随时修改原型，并且与之相关的对象也会继承这一改变，甚至会影响之前就已经创建好了的对象。</p>
</li>
<li>自身属性和原型属性。当我们访问newstoory的某个属性时，例如newSstoory.name时，js引擎就会遍历该对象的所有属性，查找这个值，如果没有找到就会查询创建这个对象的构造器属性的原型属性，如果找到就用这个。</li>
<li>原型对象，自身属性，对象属性，可枚举属性。</li>
<li><code>function Cat(name,color){
　　　　Animal.apply(this, arguments);
　　　　这个是可以成功的。
　　　　this.name = name;
　　　　this.color = color;
　　}</code>继承1.
　　</li>
<li><ol>
<li>竟然没发现这个东西。我们在定义函数的时候，默认的会有一个prototype属性，但是用new生成的函数就没有这个。</li>
</ol>
</li>
<li><p>`function a(c){<br>this.b = c;<br>this.d =function(){</p>
<pre><code>alert(this.b);
</code></pre><p>}<br>}`a的prototype包含两个值，一个是constrocuor,一个是<em>proto</em>;第一个事构造这个例子的函数。</p>
</li>
<li><p>第二个是原型链的概念，每个对象都会在其内部初始化一个属性，就是<em>proto</em>，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就去<em>proto</em>里面找，这个里面又有这个，就这样一直找下去。</p>
</li>
<li><code>function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true</code></li>
<li>Object.prototype的原型对象是null</li>
<li>原型的作用现在来了第二个：给对象扩展功能。</li>
<li>Array.prototype.isArray=function(value){for(var i=0,len=this.length;i&lt;len;i++){if(value===this[i]){return true;}}return flase;}扩展内建对象。</li>
<li>在扩建之前先检查有没有现成的方法。if（！Array.prototype.isArray）{}</li>
<li>当我们重写某个对象的prototype时，重置相应的constroctor属性是一个好习惯。</li>
<li>继承，代码的重用。</li>
<li>第一种继承方式：原型链继承。</li>
<li>继承第一阶段 </li>
<li><p><code>function shap(){
this.name=&quot;shape&quot;;
this.say=function(){
return this.name;
}
}
function two(){
this.name=&#39;2D&#39;
};
function thres(side,height){
this.name=&quot;3D&quot;;
this.side=side;
this.height=height;
this.get=function(){
return this.height*this.width;
}
}
two.prototype=new shap();
thres.property=new two();
thres.prototype=new two();
thres.prototype.constructor=thres;
two.prototype.constructor=two;
var my=new thres(10,33);
my.constructor;
my instanceof two
my instanceof shap</code><br>以上是第一阶段的继承，实现了功能了。</p>
</li>
<li><p>将共享的属性迁移到原型中去。</p>
</li>
<li>出于效率的考虑，我们可以尽可能的把一些可以冲用的属性和方法添加到原型中去，如果这样的话，我们仅仅依靠原型就可以实现继承了。</li>
<li><p>`function shap(){}</p>
<pre><code>shap.prototype.name=&quot;shape&quot;;
shap.prototype.say=function(){
  return this.name;
</code></pre><p>}</p>
<p>function two(){};</p>
<pre><code>two.prototype=shap.prototype;
two.prototype.constructor=two;
two.prototype.name=&quot;2D&quot;;
</code></pre></li>
</ol>
<pre><code>function thres(side,height){
  this.side=side;
  this.height=height;
</code></pre><p>}</p>
<pre><code> 扩展对象必须在完成继承关系的构建。
thres.prototype=two.prototype;
thres.prototype.constructor=thres;
thres.prototype.name=&quot;3d&quot;;
thres.prototype.get=function(){
  return this.height*this.side;
</code></pre><p>}`这个是修正一点的了。<br>坏处是什么？一旦对子元素原型改变，那么父原型也会遭殃。通过实现临时构造器来实现继承。</p>
<ol>
<li>继承的由来，一开始每一个实例对象都有自己的属性和方法，不仅无法做到数据共享，而且十分浪费资源，所以发明了prototype属性，所有实例需要共享的属性和方法，都放在这个对象里面，那些不需要共享的属性和方法，就放在构造函数里面。</li>
<li>function Cat(name,color){<br>　　　　Animal.apply(this, arguments);<br>　　　　this.name = name;<br>　　　　this.color = color;<br>　　}实现了功能的。继承2</li>
<li>function extend(Child, Parent) {</li>
</ol>
<p>　　　　var F = function(){};<br>　　　　F.prototype = Parent.prototype;<br>　　　　Child.prototype = new F();<br>　　　　Child.prototype.constructor = Child;<br>　　　　Child.uber = Parent.prototype;<br>　　　　这个为什么不可以继承他的里面的，就是可以继承外面的。继承3
　　</p>
<ol>
<li><p>function extend2(Child, Parent) {<br>　　　　var p = Parent.prototype;<br>　　　　var c = Child.prototype;<br>　　　　for (var i in p) {<br>　　　　　　c[i] = p[i];<br>　　　　　　}<br>　　　　c.uber = p;<br>　　} 继承4<br>　　<br>　21.`function animal(){</p>
<pre><code>this.species=&quot;动物&quot;;
</code></pre><p>}</p>
<pre><code>animal.prototype.saya=function(){
</code></pre><p>  console.log(“jib”);<br>}<br>function cat(name){<br>  animal.call(this)<br>  this.name=name;<br>  this.say=function(){<br>return this.name;<br>  }<br>}继承5</p>
<p>这个和那个相比就是少了那个constroctor.完全可以实现<br>cat.prototype=new animal();`</p>
</li>
</ol>
<p>###注意这些函数分别是来干什么的###</p>
<ol>
<li>Object.getPrototypeOf()</li>
<li>Object.defineProperty()</li>
<li>hasOwnProperty()这个只能检查自有属性</li>
<li>Object.getOwnPropertyDescriptor(person,’name’);互逆的是两个。</li>
<li>Object.preventExtensions(person);阻止对象扩展或添加。Object.isExtensible(person)返回一个值，该值指示是否可向对象添加新属性。</li>
<li>object.seal()不能添加新的属性。不能删除或修改 object.isSealed()</li>
<li>object.freeze()冻结对象。不能修改 object.isFreeze();<br>8.他们三个有区别么？</li>
<li>isPrototypeOf()检查是不是他的原型对象。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;对象的情况和数组很相似，只是他的键值类型是自定义的，也就是我们常说的索引方式不再局限于数字了，可以使用一些更加人性化的键值。也就是我们用数组来表示索引型数组，而用对象表示关联性数组&lt;/li&gt;
&lt;li&gt;访问对象的方式/.[]如果我们访问的属性名字是不确定的就必须要
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>css-基础</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-CSS基础/</id>
    <published>2017-03-10T15:30:02.000Z</published>
    <updated>2017-03-16T12:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>小东西：淘宝，搭配，比较-游戏-社交-好的一部分-商品评论</li>
<li>你给我一个目标，我会马上调动我的知识库帮你完成这个，扩展，用某种观点。</li>
<li>字体–font-style:让字体变斜就这个。</li>
<li>font-weight:粗细就看这个</li>
<li>font-stretch:chrome不支持</li>
<li>@font-face{<br> font-family:’iconfont’;<br> src:url(‘’);<br>}引入字体。</li>
<li>font-varight:今年仅针对字母：小型的大写字母。</li>
<li>text-transform:也是和字母有关系，将第一个值变成大写字母，全变成大写，全变成小写。</li>
<li>white-space:和文字空间有关系的。pre:不会合并文字间的空白，超出边界不换行只会显示一行。nowrap:合并文字间空格，只会显示一行。pre-wrap:不合并空格，但是会发生换行碰到边界。pre-line:会合并空格，也会换行。</li>
<li>word-space:单词之间的间距,在这个测试里好像他完全是以空格来区分单词的，不论是汉字还是英文。</li>
<li>letter-space:字符之间的间距</li>
<li>text-indent:文本缩进。</li>
<li>word-break:break-all;word-wrap:break-word;想要节省地方，这么写就对了。</li>
<li>text-align-last:只对最后一行做这个属性设置</li>
<li>text-justify:类似于flex那种对齐方式，但是没什么卵用，好多浏览器不支持。</li>
<li>vertical-align:他的百分比是按照line-height计算的。</li>
<li>vertain—align：起作用的前提是他的元素是inline属性才行。inline-block.table-cell()简单来说就是图片，按钮，文字和单元格。这只是在默认的情况下，当给他设置属性的时候或者使用浮动以后，那就不能显示了。`.test&gt;span{<pre><code>    display: inline-block;width: 210px;vertical-align: middle;
}
.test&gt;img{
    vertical-align: middle;
    width: 300px;
    height: auto;
}`
</code></pre></li>
<li>text-size-adjust:auto;文字根据设备大小自动调整</li>
<li>text-decoration:怎么改下划线加颜色啊。text-decoration-color: #f06d06;这个好像不能显示，只能和color共用一个颜色。</li>
<li>writing-mode:实现文字的排列</li>
<li>只要你是内联元素，你就受到vertain-align和line-height的影响。</li>
<li>行高是字符大小乘百分比。</li>
<li>定位position:staticabsolute,relative,center,fixed;</li>
<li>布局：display:inline,block,flex,inline-felx,table</li>
<li>display:none;彻底消失，原来是位置也腾出来。visibilty:hidden.就是简单的影藏，原来的位置还在。</li>
<li>margin:相邻的margin会发生合并，我们称之为margin折叠。折叠只会发生在block元素。浮动元素的margin不发生任何折叠。根元素，绝对定位的元素也不发生折叠。</li>
<li>border-首先是我们熟悉的那一套，还有就是border-image:</li>
<li><p>`width: 300px;</p>
<pre><code>height: 300px;
border: 30px red solid;
&lt;!--必须有这个--&gt;
border-image-source:url(1.jpg);
border-image-slice: 27;
border-image-width: 27px 1 10% 27px;
border-image-outset:27px;
/*border-image-repeat: stretch;*/
/*border-image-repeat: repeat;*/
/*border-image-repeat: round;*/
border-image-repeat: space;`
</code></pre></li>
<li><p>background:可以加纯色。图片。渐变。</p>
</li>
<li>background-repeat:round;自动缩放，会有repeat效果;space：没有任何效果。</li>
<li>background-attachment:fixed; scroll,local都不动</li>
<li>background-position:数字，关键字。center center;</li>
<li>但是background-origin:padding-box,content-box,border-box;只有这几个关键字能用。</li>
<li>background-size:100% 100%这个会强行把他放大到全部包含背景,cover:等比例覆盖：可能会超出容器 ,contain:缩放，但是始终在容器内.在满足一个方向之后就不管了。。。;</li>
<li>background-clip的真正作用是决定背景在哪些区域显示。如果它的值为border,则背景在元素的边框、补白和内容区域都会显示；如果值为padding,则背景只会在补白和内容区域显示；如果值为content，则背景只会在内容区域显示。</li>
<li>background-origin是指背景显示的区域，或者说背景是从哪个区域开始绘制的(边框、补白或内容区域)。</li>
<li>该属性指定了背景在哪些区域可以显示，但与背景开始绘制的位置无关，背景的绘制的位置可以出现在不显示背景的区域，这时就相当于背景图片被不显示背景的区域裁剪了一部分一样。</li>
<li>该属性指定了背景从哪个区域(边框、补白或内容)开始绘制,但也仅仅能控制背景开始绘制的位置，你可以用这个属性在边框上绘制背景，但边框上的背景显不显示出来那就要由background-clip来决定了</li>
<li>filter:属性，blur(设置高斯模糊)，brightness(%调节亮度)，contrast(%图片对比度)，drop-shadow(类似于盒子阴影),grayscale(%)定义图片灰度。hue-rotate(deg定义色相翻转),invert(%翻转输入图像)，saturate(%定义图像饱和度)，</li>
<li>list-style-type:</li>
<li>caption:默认的是在上边，而且他还不属于table里面。</li>
<li>caotion-side:boottom,top,left;放在左边是不得先排那个字的走向</li>
<li>empty-cells: show;表格无内容的时候，不显示边框。</li>
<li>border-collapse: collapse;边框之间的边框省略。</li>
<li>content:尾类中的使用；none,attr,url,string;</li>
<li>所有主流浏览器都不支持 appearance 属性。为什么这样？</li>
<li>浏览器对每个html元素的渲染都是不一样的，比如button,在chrome中，渲染出来的效果是不一样的。我们可以用appearance属性对任何元素的渲染风格改变，最简单的来说，我们可以把‘a’连接默认显示成“按钮”风格，那么我们可以使用‘appearance’设置为“button”.</li>
<li>text-overflow:clip(超出部分裁掉)，ellipsis(替换为…);</li>
<li>outline:设置或检查对象外的线条轮廓。</li>
<li>cursor:鼠标各种的抚摸特效。</li>
<li>zoom:设置对象缩放比例。可以缩放任何东西。</li>
<li>user-select:none(文本不能被选择)，text(可以),all(将所有内容变成一个块的时候可以)，element(可以选，但是选择范围受限制)</li>
<li>resize:如果希望此属性生效，需要设置对象的overflow属性.both.horizontal,vertical.</li>
<li>transfrom:translate(),scale(),rotate(),skew()斜切扭曲。</li>
<li>3D转换需要设置的新属性：perspective,transform-style:flat,perserve-3d;perspective-origin:指定透视点的位置。</li>
<li>backface-visibility:visible,指定背面元素可见。hidden：指定元素背面不可见。</li>
<li>transition:注意可以起作用的对象，z-index.</li>
<li>animation: name 持续时间 过渡帧率 延迟时间 循环次数(1,infinite无限次) 动画的播放方向 默认向前播放，alternate（偶次向前，基数向前）</li>
<li>media引入的两种方式：<link rel="stylesheet" type="text/css" href="styleA.css" media="screen and (min-width: 400px)"></li>
<li><p>@media screen and (min-width:600px)and (max-width: 1000px){</p>
<pre><code>    body {
        background-color:lightblue;
}
</code></pre><p>}小的必须在前面，错了，跟这个没关系!有关系的是必须要在他们之间留下足够的空格。</p>
</li>
<li><p>选择所有作为E元素的子元素F E&gt;F适用于剔除孙子元素里面不想选的，但是子元素里面有的。也就是说孙子和儿子都有的东西，但是你只想选择儿子的。</p>
</li>
<li>选择紧贴在E元素之后F元素。 E+F p+p的选择就是先必须找到两个p,然后后一个被选中。</li>
<li>选择E元素后面的所有兄弟元素F。 E~F  p~p 表示只要出现第一个p元素之后，接下来只要有p元素都会起到作用的</li>
<li>选择中的标签属性，这个是来动态变化的添加css属性。</li>
<li>img[type=”text”] img[type^=”text”] img[type$=”text”] img[type*=”text”] img[type|=”text”]开头具有用”-“分隔的字符串。</li>
<li>link visited hover active focus(成为输入焦点的时候)</li>
<li>还可以筛选文字形式给确定文字样式。</li>
<li>border:none;border:0;的区别border:none;  =&gt; border-style: none;border:0;       =&gt; border-width: 0;两者理论上都是一个效果，就是不显示边框实际上，我记得 none 在某个 ie 下面有 bug，用 0 没有 bug。<br>至于 border:0 none; 没必要;后一个是小号内存了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;小东西：淘宝，搭配，比较-游戏-社交-好的一部分-商品评论&lt;/li&gt;
&lt;li&gt;你给我一个目标，我会马上调动我的知识库帮你完成这个，扩展，用某种观点。&lt;/li&gt;
&lt;li&gt;字体–font-style:让字体变斜就这个。&lt;/li&gt;
&lt;li&gt;font-weight:粗细
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
      <category term="css-基础" scheme="https://github.com/skoll1/libateer.github.io/tags/css-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网站代码分析</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-网站代码分析/</id>
    <published>2017-03-10T15:22:43.000Z</published>
    <updated>2017-03-17T05:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>###bootstrap###</p>
<ol>
<li><ol>
<li>书写格式</li>
</ol>
</li>
<li>.btn-default</li>
<li>badge:内联样式，徽章</li>
<li>hover,focus用一个属性</li>
<li>text-size-adjust:文字会根据设备的不同自动调整。</li>
<li>details标签可以和summary配合实现手风琴效果</li>
<li>template声明模板元素；</li>
<li>don：对特殊语或者短语的定义可以用dfn括起来。</li>
<li>mark突出显示的文本。。我去这个属性了</li>
<li>取得名字：navbar</li>
<li>为什么他的代码格式那么简单，嵌套关系也没那么复杂。</li>
<li><blockquote>
<p>这是什么意思,表示从属关系都是这样的来用的。</p>
</blockquote>
</li>
<li>tr.info是指的自己的还是他下面的子元素呢？</li>
<li>下面的子元素都加上他的父元素的名字—-这样就简单多了。还可以表示关系。</li>
<li>一个页面需要的css</li>
<li>margin-right:负值是什么意思？</li>
<li>output输出标签。</li>
<li>自适应品均分配用的是百分比，想分几份就除几。</li>
<li>left,right,margin-left,margin-right.还可以像上面那样加半分比，是位置么？</li>
<li>*.html,body,input,button,select,textarea, a,figure,img,hr,</li>
<li>:focus{border-color,outline,box-shadow,}</li>
<li>::后面加尾类元素-ms-input-placeholder{}-webkit-input-placherholder{}</li>
<li>还是语义化起名字看起来，input-lg/has-success .help-block.就是那种你直接看css都可以知道你的样式是什么样。</li>
<li>到底是要一个一个的看属性呢？还是结合具体问题看实践。两个都来吧？在做东西的时候自己用到的争取都弄明白。。</li>
<li>pre:定义预格式化文本，显示特殊符号。<ol>
<li>appearance：使元素看上去向某个东西：button,icon,window,menu.</li>
<li>orphans:设置或检索对象内容内一定要留在一页范围地段以内的行的最少数量</li>
</ol>
</li>
</ol>
<p>   ###火狐###</p>
<ol>
<li>主体结构：window- browser - html—head-body-script <ol>
<li>head;</li>
<li>body:div-script;</li>
<li>div-header/dir/footer</li>
<li>header-layout-fleft/fright</li>
<li>fleft-logo-top/bottom   div-p-a/span</li>
<li>dir-left-banner/menu</li>
<li>css命名规范：<br>###淘宝###</li>
</ol>
<ul>
<li>div+p+gq</li>
<li>div&gt;p&gt;span+em</li>
<li>ul&gt;li.item$*5</li>
<li>form#search.wide</li>
<li>p.class1.class2.class3</li>
<li>ul&gt;.class</li>
<li>table&gt;.row&gt;.col自动补全结构</li>
<li>a:link</li>
<li>a:mail</li>
<li>link:css</li>
<li>link:favicon</li>
<li>meta:vp</li>
<li>script:src</li>
<li>form:get</li>
<li>inp</li>
<li>input:t</li>
<li>input:time</li>
<li>btn:b</li>
<li>btn:r</li>
<li>btn:s</li>
<li>ol+</li>
<li>ul+</li>
<li>table+</li>
<li>select+</li>
<li>cc:ie6<br>####知乎###</li>
</ul>
<ol>
<li><ol>
<li>首先就是在html那块还加了一堆class.</li>
</ol>
</li>
<li>在head里面也加了一堆页面内的样式。style.</li>
<li>Logo一般都是用a装的。<a href="“/“"></a></li>
<li>可能要转到下一页的都用a标签，</li>
<li>汉字一般用span装。</li>
<li>下面可能出现的东西就要用ul ，li，装了，这些都是，然后a里面的汉字用i标签来装。</li>
<li>图标的东西都要用i</li>
<li>可以表示为列表的都要用ul li</li>
<li>A 可以用来表示，出现一个“新动态”，“加载中”。利用这个来加载新的东西。</li>
<li>Span还可以加小圆点来</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###bootstrap###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;书写格式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;.btn-default&lt;/li&gt;
&lt;li&gt;badge:内联样式，徽章&lt;/li&gt;
&lt;li&gt;hover,focus用一个属性&lt;/li&gt;
&lt;li&gt;te
    
    </summary>
    
    
      <category term="网站代码分析" scheme="https://github.com/skoll1/libateer.github.io/tags/%E7%BD%91%E7%AB%99%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>自适应页面</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-1-自适应页面/</id>
    <published>2017-03-10T15:18:38.000Z</published>
    <updated>2017-03-17T05:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>box-sizing:border-box;</li>
<li>background-size:修改背景图片的唯一办法。可以使用多个背景图片，会带来意想不到的效果。</li>
<li>3个角度来考虑设计方案。</li>
<li>web design</li>
<li>meta标签。主要思想。调整列，弹性宽度，紧缩空白空间，调整字体大小，修改导航菜单。隐藏一些内容。</li>
<li>如何创建断点：也就是替换样式表的时候。（打开自适应设计，不断调整窗口大小，发现不美观的时候就可以了）</li>
<li>怎样替换载入样式表么？</li>
<li>media可以识别别的属性限制么？媒体查询支持的其他属性</li>
<li>弹性玩网格：宽度。100%。桌面：max-width:    布局的每一个列都应该用百分比。</li>
<li>HTML源代码的顺序的重要性，因为手机列显示的时候，可能是把float属性改一下。</li>
<li>自适应的图片问题：</li>
<li>只要你没有给每一个设计元素设计精确元素，宽度，高度，和位置，就会发现css定位属性是如此的强大，这些属性可以把蚊子显示在图片上，把LOGO放在网页的任何位置上。</li>
<li>绝对定位可以脱离文档流，以至于网页上的其他元素甚至不知道这个元素的存在。</li>
<li>相对定位：网页上的其他元素不会占用相对定位原来在HTML的位置。</li>
<li>浏览器兼容方法。</li>
<li>.img-wrap img{</li>
<li>max-width: 100%;</li>
<li>height: auto;</li>
<li>/<em>那就是可以实现自己的自适应轮播图了吧</em>/</li>
<li>}</li>
<li>基于cookie以及js的响应式图像。在服务器端根据用户的请求返回特定的图片</li>
<li>自适应视屏：在页面是可以支持百分比的，如果服务器端有类似的视屏那就更好了。</li>
<li>bili没有自适应视屏，只有两个格式，全屏和变小那个，先找到主要的东西展示出来，在小得时候把全部的信息给出来，然后你再自己变大看主要的，在变大的时候还可以加上自己想要展示的小的东西。</li>
<li>video{</li>
<li>max-width: 100%;</li>
<li>height:auto;</li>
<li>}</li>
<li>视屏托管网站比放自己托管更加安全，自己可能受到带宽的货磁盘空间的限制。这是通过iframe实现，如果是应用地址的话，使不得在他的网站打开这个啊。好像没有那个问题啊。</li>
<li><embed height="515" width="700" quality="high" allowfullscreen type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=7382789&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></li>
<li>基于媒体查询的图像图像。在客户端调整选取图像，还是那个服务器的好，但是要是按照一开始的加载的来看的话。</li>
<li><form action=""></form></li>
<li><select name="URL" onchange="location.href=this.form.URL.options[this.form.URL.selectedIndex].value"></select></li>
<li><option value="1.html">1</option></li>
<li><option value="2.html">2</option></li>
<li><option value="3.html">3</option></li>
<li></li>
<li>用这样的的来组织一个小的nav</li>
<li>图像padding还得自适应。</li>
<li>Em</li>
<li>html{</li>
<li>font-size: 12px;</li>
<li>}</li>
<li>p{</li>
<li>font-size: 3rem;</li>
<li>}这个还得用media查询来区分，这样也太菜可呗。</li>
<li>不能再外面的加一个固定的，在里面的加上百分比。</li>
<li>css3d文字</li>
<li>0px 0px 0px #666,</li>
<li>-1px -1px 0px #666,</li>
<li>-2px -2px 0px #666,</li>
<li>-3px -3px 0px #666,</li>
<li>-4px -4px 0px #666,</li>
<li>-5px -5px 0px #666,</li>
<li>-6px -6px 0px #000,</li>
<li>1px 1px 5px #ccc,</li>
<li>2px 2px 5px #ccc,</li>
<li>3px 3px 5px #ccc,</li>
<li>4px 4px 5px #ccc,</li>
<li>5px 5px 5px #ccc,</li>
<li>6px 6px 5px #ccc,</li>
<li>0px 0px 0px #888,</li>
<li>-1px -1px 0px #777,</li>
<li>-2px -2px 1px #666,</li>
<li>-3px -2px 1px #555,</li>
<li>-4px -4px 2px #444,</li>
<li>-5px -5px 3px #333,</li>
<li>-6px -6px 4px #000;就是在最后加个分号。。。</li>
<li><meta name="viewport" content="initial-scale=1 maximum-scale=1 minmum-scale=2"></li>
<li>响应设计始终就是内容优先（相对于那些侧边栏，导航栏）</li>
<li>所有伟大的设计或思想，都会卷土重来。</li>
<li>响应设计需要百分比布局</li>
<li>百分比布局创建的弹性界面，同时使用媒体查询限制元素的变动范围。主要是相对于左右百分比。</li>
<li>响应式设计网站欣赏借鉴？最好就是看写的东西。</li>
<li>目标元素宽度%上下文宽度=百分比宽度  每个元素加完这个，还在内部加margin-left/right 这个还得计算</li>
<li>1：1.61803398874989 黄金比例，网页设计也最好不要四舍五入</li>
<li>界面元素的排列也可以用mar-l//r百分比。但是要注意相对父级元素。</li>
<li>用em代替px，body设置文字大小为100%.其他用相对单位em,改用body,其他也会相应得度。</li>
<li>目标元素尺寸%上下文尺寸元素尺寸=百分比尺寸</li>
<li>h1span</li>
<li>span的文字大小是相对于父级元素文字大小，而他的行高是相对于自己的文字大小的。所有单位是em</li>
<li>图片适应</li>
<li>现代浏览器十分简单：img video embed{max-width:100%};</li>
<li>为特定图片制定特定规则。额外添加特定的规则。额外添加一个新的class，{max-weidth:45%}</li>
<li>为了防止图片变形：让他绝对不能超过max-width:属性</li>
<li>为了页面无限扩张：给最外侧的div加{max-width:1414px;}</li>
<li>刷新页面：live,.js</li>
<li>设置只适应图片</li>
<li>字体设置一定要加font-size</li>
<li>看css 3d.</li>
<li>css 变形 、过度，动画</li>
<li>表单：modernizr:可以按需加载js.</li>
<li>响应式设计：将三种已有的开发技巧（弹性网格布局，弹性图片，媒体查询）</li>
<li>真正响应设计方法不仅仅只是根据视口大小改变网页布局。相反，我们应该首先针对小屏幕进行设计，然后足部增大对屏幕的设计和内容、</li>
<li>他只是一种根据不同设备内容进行完美布局的一种显示机制。相反，如果需要根据不同设备提供特定内容的功能，那就需要一个真正的手机版网站</li>
<li>www.mediaqueri.es</li>
<li>媒体查询能够检测那些属性。视口宽度和屏幕宽度。</li>
<li>移动设备在任何时候都要想到文字输入的困难。</li>
<li>在小屏幕中去除那些不必要的杂乱元素，在大屏幕中突出控件和增强式导航。</li>
<li>要时刻质疑开发过程中是否简化了界面，设计师非常容易陷入增加新设计的误区。</li>
<li>可以先体验些没有被优化的应用来决定自己的下一步操作。</li>
<li>真正的响应式设计不是根据视口来改变网页布局，而是我们首先针对小屏幕进行设计，然后逐步增加对大屏幕的设计和内容。</li>
<li>对于inline元素来说，水平padding产生影响，垂直padding不影响。padding: 41%;<br>display: inline;</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;box-sizing:border-box;&lt;/li&gt;
&lt;li&gt;background-size:修改背景图片的唯一办法。可以使用多个背景图片，会带来意想不到的效果。&lt;/li&gt;
&lt;li&gt;3个角度来考虑设计方案。&lt;/li&gt;
&lt;li&gt;web design&lt;/li&gt;
&lt;
    
    </summary>
    
    
      <category term="自适应页面" scheme="https://github.com/skoll1/libateer.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>战争的逻辑--普鲁士到德国崛起</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/10/best-3-%E6%88%98%E4%BA%89%E7%9A%84%E9%80%BB%E8%BE%91-%E6%99%AE%E9%B2%81%E5%A3%AB%E5%88%B0%E5%BE%B7%E5%9B%BD%E5%B4%9B%E8%B5%B7/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/10/best-3-战争的逻辑-普鲁士到德国崛起/</id>
    <published>2017-03-10T14:32:27.000Z</published>
    <updated>2017-03-19T14:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>没有什么东西能够够比陆军和海军更加依赖经济前提。一发炮弹是那个时代农民五年的收入<br>2.一旦技术上的进步可以用于军事并且已经用于军事目的，他们便立刻几乎强制的。而且往往是违反指挥官意图而引起作战方式的改变甚至是变革。随着技术武器的出现，将再也不可能出现落后文明对高等文明的征服，也就是说，类似与成吉思汗之类的草莽英雄再也不会回来了。 </li>
<li>对于其他国家来说，是国家拥有一支军队，而对于普鲁士来说，是一支军队拥有一个国家。</li>
<li>民族认同感并不是凭空来的，是在被侵略的时候来的，德国的民族意识觉醒就是在拿破仑的铁蹄下瑟瑟发抖的时候。</li>
<li>在耶拿会站的时候，拿破仑不仅毁灭了一个封建陆军，而且也肃清了封建观念最后的灰烬，但是在这灰烬里确诞生了一个新的民族陆军，终于在莱比西会战中把自己打败了。德意志也将在民族主义下开始统一。</li>
<li>赎罪券：德意志被称为“教皇的奶牛”.</li>
<li>1685年的时候就发现：政治分裂导致的市场狭小，这与资本主义大工业的生产方式是由根本矛盾的。</li>
<li>德国统一是在匹斯麦的领导下的。当代重大问题不是靠演讲和多数会议解决的，而是要通过铁和血才能解决。</li>
<li>嘉斯泰公约只不过是一张遮盖裂缝的糊墙纸。<br>10.普鲁士和奥地利打在一起是普鲁士想要同一德国。但是当时奥地理在联邦里有很大的威信<br>11.他骑在<pre><code>  .-&apos; _..`.
 /  .&apos;_.&apos;.&apos;
| .&apos; (.)`.
;&apos;   ,_   `.
</code></pre>.–.<strong><strong>__</strong></strong>.’    ;  <code>.;-&#39;
|  ./               /
|  |               /</code>..’`-.<em>  <em>__</em></em>, ..’<br>  / | |     | |\ \<br> / /| |     | | \ \<br>/ / | |     | |  \ \<br>/<em>/  |</em>|     |<em>|   \</em>\<br>|<strong>\  |</strong>\    |<strong>\  |</strong>\上看着山脚下数十万的士兵厮杀在一起，在回忆录中他这样写到，当时好像在玩一场扑克牌，把不属于自己的100万塔勒孤注一掷，甚至传言他还携带了一瓶毒药，准备在普军这一场“不得人心的”战争失败之后自杀。</li>
<li>在大败奥地利的时候，他却坚决的与奥地利签订宽大的条约，假如奥地利遭受严重的损失，那可能成为法国或是我们一个敌人的盟友。。要尽可能的防止奥地利造成屈辱的回忆，普鲁士军队进入帝国首都可能会给我们留下美好的回忆，但是对我们的政策并无必要，但是要使奥利利的自尊受损，那么只会给以后的关系增加困难。</li>
<li>他达到政治目的之后便戛然而止，绝不允许所谓的胜利果实妨碍他的政治目的，作为一个成熟的政治家，匹斯麦始终把军事力量当成实现政治目的工具加以运用，更难得可贵的是他对军事力量的克制，使军事力量始终服从与政治需要而不相反。</li>
<li>后勤补给的因素：国内畜力运送，抢劫：温柔的，土匪式的。</li>
<li>中国无法解决四轮车转向的问题，所以很多的时候都是用两个轮子拉。</li>
<li>铁路的作用：第一次世界大战中威廉二世要求德军总参谋改变作战计划这也是不可能的了，所有的军队调动都已经按照运输能力做了最好的调度安排。一旦改变就引起巨大的混乱。</li>
<li>如果有好的机会，我也许会创业，但是如果没有好的机会的话，也许我会成为一个人生最好的掌舵手，帮他认清自己和目标的反向。</li>
<li>火门枪:一分钟一发，100米的射程。而且还是提前的装枪，也就是说一个枪手只有一次的机会。</li>
<li>手枪的出现极大地改变了战争的形态，从此类似于成吉思汗的草莽英雄再也不能出现了，决定战争的不是士兵的勇敢和智慧，而是双方的生产能力，手枪的结构不是复杂，却需要强大的工业作为支撑。</li>
<li>我们的军队一切准备就绪。一直到最后一个士兵的鞋套上的最后一个纽扣。</li>
<li>法兰西第二帝国–法兰西第三共和国</li>
<li>两个爱好一样的人—记录—搜索—聊天—排行榜。</li>
<li>德意志联邦————德意志帝国————此时早已赶走了奥地利（奥地利+匈牙利）。</li>
<li>此前是法国一家独大：一个流传甚广的笑话是这样说的。从此欧洲收了一个女管家，来了一个男主人。</li>
<li>普法战争的演变：从德国对法国的侵略变成法德两国对欧洲霸权的争夺。</li>
<li>从此德国和发过结下了世仇：7.5亿白银。阿尔萨斯和洛林。无法化解的仇，所以尽可能的削弱法国。</li>
<li>德国：不强大到遭人嫉妒，避免俄法结盟。</li>
<li>俄–内陆国家，想要获得出海港口–黑海海峡周围的土地（除了这个，也有一点宗教行为）。–英国遏制俄国–印度：东印度公司一开始是香料（后来价格下降）开始鸦片–利益太大，所以印度成为英国的咽喉。 鸦片–纺织–茶叶</li>
<li>印度的财富滋养了大英帝国：1910年的收入相当于293吨黄金。所以他要控制所有去往英国的航线。</li>
<li>拿破仑时代结束后，欧洲民族主义开始兴起，沙皇俄国趁机叫嚣“泛斯拉夫主义”，企图利用民族主义鼓动这些南部斯拉夫人民从土耳其的统治下独立出来，成为操纵的傀儡，从而实现间接控制黑海海峡的目的</li>
<li>欧洲制度规定只有正妻的儿女才有继承权，情妇永远是违法的，所以才会有女国王。</li>
<li>奥匈帝国：让别人去打仗吧，快乐的奥地利喜欢和别人结婚。可以说是他现在自己早就独自疼得受不了了，根本没有闲工夫去寻找那些吃的东西了。</li>
<li>结果就是由于俄奥两国在巴尔干半岛的争夺最终引爆了第一次世界大战。</li>
<li>土耳其的统治极其残暴，在位的苏丹为了防止自己的儿子和兄弟夺权，会把他们关在一个没有窗户的建筑里，很多皇子都是这样度过一辈子的，当老的苏丹死了，他们之中幸运的一个会被选为国王，完全不懂人情事故，没有受过教育，甚至不知道如何和别人交谈的人就当了这个帝国的国王。</li>
<li>塞尔维亚起义成功–俄国开始以“奥斯曼帝国东正教基督徒的保护着为名”，这样就是可以插手一些国际事务了。</li>
<li>希腊要起义了。—为了减少俄国早巴尔干半岛的影响。最后俄委员会认为，一旦奥斯曼帝国崩溃，那么欧洲列强各国对土耳其瓜分的狂潮，并将导致分脏不均而引发世界大战。</li>
<li>同时英国为了减弱俄国的影响力，决定帮助希腊独立—希腊独立以后，这更加鼓舞了巴尔干各民族争取独立的斗志。</li>
<li>1841年-规定黑韩海峡由国际共同管理，并对各国军舰封闭，这就废除了此前俄国十多年的侵略计划。</li>
<li>我们不会研究英国国王或首相的个人问题，也不会去研究发过总统或总理的特征，作为民主国家的领袖，他们只是实现国家利益的的工具，其个人特征在国家事物影响非常小，但在专制独裁或者是威权国家里就不同了，国家利益往往是和独裁者本人的利益不符合的，独裁者本人往往没有国人的智慧，却拥有了无限的权利。这就往往是悲剧的根源，更可悲的是，一些聪明的人确只能眼睁睁的看着这个国家在义无反顾的走向悬崖。最可悲的是这个国家的人民，他们被虚无的爱国热情和民族主义宣传和煽动，成为独裁者实现个人野心的工具，如果胜利了他们会获得一丝荣誉，一无所获，如果失败了他们却要承受所有的苦难。荣耀和苦难，他们只能被动的承受，因为他们根本没有选择的权利。</li>
<li>威廉二世不挂海军上将的徽章就不会去养鱼池，不打扮成英国陆军元帅就不吃葡萄干。每次狩猎都要当公鹿，每次婚礼都要当新娘，每次葬礼上都相当死人。</li>
<li>英国的核心利益：本土安全，保护工商业的利益。大陆均衡政策，光荣孤立政策。不签订任何有束缚性质的条约，只是从各种博弈中得到自己想要的结果。</li>
<li>由于第一次工业革命的完成，，这些国家需要一个原材料能稳定供应，并且稳定的市场销售范围，促使各国纷纷走上了开辟海外殖民低的活动，企图独占原材料的供应和销售市场。海外扩展本质上是一场经济活动，是一种谋求高额利润的活动，但是殖民地一定会给他的国家带来利润么？帝国主义内部有着不同的利益集团，虽然总体上殖民某一个地区从今机上是不划算的，但支付的是整个国家，也就是全体纳税人，而真正获得利益的确实某个特定的利益集团，这些利益集团有着巨大的能量，让真个国家为了他们的利益敷处理巨大的代价，他们左右国家的政策其实非常高明，往往宣称某一地区是十分重要的，殖民该地区对国家是多么的有利益，往往把自己的私利藏在这个后面，还有一天最重要额私利就是虚妄的荣耀的成就感带来的感觉，感觉自己可以建功立业了，开疆扩土了，但是为这个虚妄的成就感付出的确实实实在在的代价，这就是很多国家扩张之后突然崩溃的结果。</li>
<li>非洲是最后的一个被殖民的地区—甚至最后只能把他们卖了才有油水。</li>
<li>威廉二世为了满足自己的虚荣就想开阔新的殖民地，但是这样虽然没有很大的利益，但是确使英国产生了更大的警惕，于是越走越远，最后德国不得不把英国作为自己的假想敌来指定战争策略。</li>
<li>于是他开始发展自己的海军，。。等20年后，当海军以建造完毕，那是我将用另一种语言讲话。</li>
<li>他无法简答的理解匹斯麦，只是单纯的认为，德国越强大越越安全。为了发展自身安全而发展军事量那会一定会导致危机的。</li>
<li>“大炮巨舰主义”</li>
<li>德国的疯狂扩充海军的装备引起了英国的海军恐慌。“海军要求6艘，经济学家只肯给四艘，我们折中了一些，决定给8艘”。</li>
<li>在维持一个强大的陆军的同时在维持一个强大的海军是德国承担不起的。而且疯狂的军备竞赛之后的军舰。在一战的时候，全部的海军都被英国人封锁在波罗的海侠里面。</li>
<li>战前英国多年的政治活动使我们坚信，德国作战舰队的迅速扩展是使英国站到敌对面的重要原因。一个强大的海军给德国带来一个世界上最强大的敌人，最终把自己的祖国送到坟墓。</li>
<li>按照英法的要求；这只舰队的主力要求群不赔偿给协约国德国不愿意，最后全都沉到了海里。</li>
<li>由于海峡被封锁，我国出口减少98%，进口降低95%，土耳其利用黑海海峡彻底封锁了俄国。由此导致了“二月革命”，“十月革命”</li>
<li>土耳其被德国拖入战船。</li>
<li>罗马尼亚的参战不仅没有帮助协约国，而且帮了德国的忙，80%的士兵在一枪潍坊的时候就投降了，20%临阵脱逃。</li>
<li>加特林是一个一声发明的，为了减少士兵的数量。每分钟6000发可以瞬间摧毁一辆汽车</li>
<li>马克沁机枪的射程长达四公里，所以防御一方的枪手把机枪朝天，到达对方阵营的子弹就变成了真正的枪林弹雨，能祈祷的只是运气。</li>
<li>大炮，铁丝网，马克沁机枪，战壕可以说是当时最强大的防御武器。</li>
<li>地狱般的战壕生活：由于进攻只是简单的送死，所以双方士兵便长年累月的蜷缩在战壕里，承受着难以想象的折磨和痛苦。床没有，有的只是狗洞，污水，没有热的食物，厕所，疾病，虱子，老鼠带来的病，冬天，夏天，秋天，哪怕站直身体呼吸一口威风带来的新鲜空气都是奢望，地狱般的战壕生活让人们对敌人也产生了惺惺相惜的情感，甚至在某些地段达成默契，不主动攻击，形成一种“你活着，我也活着的”状态。</li>
<li>坦克的出现正是为了打破这一僵局，不怕铁丝网，可以承受机枪的打击，但是这个时候坦克只是步兵的从属地位。</li>
<li>毒气是德国发明的这一武器，氯气与尿产生的滑雪反应可以让他失去毒性。</li>
<li>飞机：则是高度和速度的比拼，以至于当时的人称之为飞行的棺材。</li>
<li>潜艇：鱼雷。所有的战斗条件都是极其残酷的。</li>
<li>消耗战的开始，英国人封锁了海峡，他们认为只要德国人没有制造火药额化学药品就会投降，但是以为叫做哈文的科学研究出了在空气中提取氯气，利用氯气合成氨的工艺。</li>
<li>英国人明白对德国的封锁其实就是饥饿的战争，没有人会对饥饿战争，因为抗争的结果就是死亡。</li>
<li>世界各地的小麦和其他粮食都是签收的，为我们提供了一次绝好的机会，如果我们不抓住他们，那就是一种罪过，我们可以实行无限制的潜艇作战，迫使英国在五个月内投降。</li>
<li>每个人都对战争充满了恐惧，因为战争夺取了他们生命中最美好的东西，带给他们的只是饥饿还有失去亲人的痛苦。</li>
<li>二月革命之后，成立的临时政府为了能获得战后胜利的获利品。决定继续参战，但是此时俄国和普通民众早已精疲力尽，于是德国就运送回了俄国的核武器。列宁，他到处发表演讲，呼吁人命反抗临时政府，痛骂战争，并许诺他们所有的愿望，为了支持他的革命，德国支付了7500万欧元。</li>
<li>然后就是十月革命了，签订了一些列条约分裂出好多国家做缓冲带，但是一战之后，各国修生养息的时候，他们却陷入了更加惨烈的内战。</li>
<li>美国参战了，英法已经欠了美国很多的欠条，以至于美国人要为这些债主的生命安全操心了。</li>
<li>战败的德国为什么继续不被欺负不仅仅是因为四年的大战耗尽了人力，财力，物力。更为重要的是战场上美国的影响力已经越来越大了。如果继续下去，那么英法可能成为美国的附庸，美国将主导战后的秩序。德国国内已经有布尔什维克主义的倾向，使德国政府从这个当中脱身，平叛国内的革命，维持秩序，才能符合协约国的利益。</li>
<li>救济凡尔赛和约的唯一条件在于迫使我们击败的敌人不能履行他的条件。</li>
<li>法国进攻鲁尔园区导致德国彻底的经济崩溃，物价飞涨，由此导致非常严重的通货膨胀，工资必须每天发一次，喝咖啡之前都得先结账，因为喝完可能就会涨价</li>
<li>恶性通货膨胀其实本质是一场财富的重新分配，他把财富从中产阶级手里夺走，然后交给大资本家，大资本家在银行的资本因为通货膨胀而全部消失，那些在战争中处于爱国热情而购买公债的人也彻底破产了，五年前这些钱支持了德国四年的战争，五年后这些钱甚至不能买一片面包，有权有势的人大肆囤货齐聚，把工薪阶层最后一点值钱的东西都席卷一空，中产阶级和工人在陷入愤怒和绝望之后便开始相信希特勒的歪理邪说。</li>
<li>法国因为鲁尔区的骚乱导致自己国内的经济大幅度倒退，在德国工人运动风起云涌的时候，德国总理告诉大家，他的政府也许是德国最后的资产阶级政府。德国的解体就是债务人的失踪。</li>
<li>英美的干涉导致法国再也不敢独立干涉德国的事物，从此以后法国就亦步亦趋的跟在英国人后面，如果没有鲁尔时间，在对德国崛起最警惕的法国，一定会在希特勒撕毁凡尔赛和约是给他沉重的打击。</li>
<li>之后，协约国决定给德国巨额的贷款来用于发展国内经济。凡尔赛和约的目的就是限制国内经济来彻底削弱德国，现在借给他的钱比战争赔款还多，资金实际上在流入德国，帮助其发展崛起。</li>
<li>但是德国经济快速增长是建立在外国资本投资的情况下的，所以一旦国际形势发生变化，那么德国经济会立马陷入崩溃。</li>
<li>德国外交史上的胜利：利用苏联和英法的矛盾，迫使英法让步，利用英法的矛盾，迫使法国让步，仅仅用了7年就摆脱了战败国的地位，成为被承认的国际大国。</li>
<li>任何国家都没有违约债务的权利，如果政权更迭就可以赖账的话，哪还有什么国家敢在国际上发行债券了。但布尔什维克克就是赖定了不换。</li>
<li>沙皇-苏联-俄国-三个赖账国家都是。</li>
<li>随着《拉巴洛协定》的签订，苏德迅速进入蜜月期，为打破凡尔赛对德国军备的限制，由德国提供军事工业所需的机器及技术，苏联负责为他建造，提供坦克，军用飞机和化学武器的试验场。德国可以避开协约国的监督生产武器，而俄国得到先进的技术，20年后驰骋在苏德战场上把双方士兵杀得人仰马翻的武器很度都是两国共同研究的。</li>
<li>当所有的钱都投入股市的时候再也没有新钱来职场股票的价格上涨的，聪明的人必然会明白这个循环会被打破，他们在崩溃之前就撤离这个战场，从而引发恐慌性抛售导致循环提前来临。</li>
<li>随着股市崩溃，银行业的倒塌，银行及债权人开始向工厂索取债务，导致工厂无法正常生产，企业开始破产，失业的人口无法购买商品导致共产更加的举步维艰。</li>
<li>对于德国经济来说，这个是更加崩溃的事情。失业工人根本无法明白，自己辛勤努力的工作，遵纪手法的生活怎么武断的丢了饭碗被感到了大街上，面对妻子的愁容，嗷嗷待付的孩子他们又能怎么办？这是一个叫希特勒的人出现了。如果他上台，德国将恢复强大，拒付赔款，撕毁法尔赛和约，肃清贪污，迫使金融巨头就范，甚至保证在第三帝国的每个女郎都会找到一个丈夫（当时有180万的寡妇）</li>
<li>席卷世界的金融风暴没有波及到苏联，其主要原因就是本来经济就差，没什么可以坏的，然后就是一直十倍封闭的，很少和外界有经济来往。因为经济危机，所有的国家都是关紧国门，保护自己的民主产业，只有一个国家敞开胸怀迎接一切的技术和机器设备，那就是苏联。</li>
<li>由于这些工厂是在不发达的工业社会中建造起来的，就必须要在他们周围形成一个包括原材料在内的供应厂和备件唱的完整体系。</li>
<li>客观的说，西方尤其是美国的机器设备帮助苏联完成了工业化，不但是与军事工业相关，还包括几乎当时所有的工业门类。</li>
<li>苏联在短短的十年内就建造了如此多的大型企业，那他们的钱是哪里来的，除了征地拆迁不需要钱，别的其他的东西都要钱？</li>
<li>苏联是怎么从农民身上弄出钱来作为工业化的资金呢？这就是第一个五年计划来时的时候的农业集体化，斯大林的工业计划就是一项由国家规划的努力，其募捐资金的手法就是将农场集体化，意味着这些农场的产品是属于国家，因此，政府能够更加名正言顺的把这些东西拿去外销。</li>
<li>如此严厉的粮食征收政策导致1933年的乌克兰大饥荒，苏联出口的粮食换来了4.45亿卢布的外汇，但是确饿死了几百万人。</li>
<li>从此以后，好像历来苏联的粮食都是进口的。</li>
<li>一个苏联官员自豪的对前来参观的美国代表团宣布，在下一个五年计划完成的时候，每个苏联家庭都将有一架飞机，美国人大吃一惊，有这个必要么？苏联官员眼里透着坚毅的目光，比如你住在莫斯科，但居住在列宁格勒的表兄说那里开始供应鸡蛋了，你就可以开着飞机去那里排队了啊。</li>
<li>苏联连个五年计划完成的东西都是与军事相关的工业，而对于人命生活息息相关的勤工而已却完全被忽视，这一畸形的发展不但没有停下，反而在冷战的时候更加的强化，结果就是苏联人民始终生活在经济匮乏中，凡是日用平，不但质量少，而且差。</li>
<li>奥地利人最大的成就就是让全世界以为希特勒是德国人，莫扎特是奥地利人。</li>
<li>希特勒是个坚定地理想主义者，他坚信自己做的一切都是为了德国人民，他要为德国人民建设一个人间天堂。正应为如此他才获得了一种道德的优越感，才对自己所犯下的罪行不屑一顾，因为在它看来，这些事不过是为了建设天堂所犯的代价罢了。他的悲剧，或者说是人类的悲剧就是人间天堂未建成，确建成了地狱。所有想要建设天堂的伟大理想无一类外的都落实为建造地狱的具体行动。</li>
<li>希特勒最厉害的不是演讲能力，组织能力，还是募捐的能力，1933年希特勒拥有武装的冲锋队200万，这是比德国军队多20倍，这200多万人的工资都是纳粹党养活。</li>
<li>用德国的剑为德国的梨取得土地，为德国人民取得每天的面包。今天我们来谈欧洲的土地，我们指的是首先只能是德国和他的藩国。这就是他之所以打败法国的情况下还要进攻苏联的原因。德国将成为整个欧洲的顶端，不同的殖民地满足德国不同的需求和工业原材料，而整个欧洲都将成为德国工业品的市场。</li>
<li>人民的苦难给极端党派以肥沃的土壤，纳粹的发展就是明证。800万的失业工人和他们的家人大多成了纳粹的拥护者，很难说是他们认同的纳粹的政治理念，但他们知道希特勒许诺给他们工作，给他们面包，这就够了。</li>
<li>扩军是整个军官团的愿望，只要扩军军官们自然人人都能升官，希特勒以此收买了整个军官团。</li>
<li>他操控货币的本领可以说是神通广大，他也开动了印钞机，但是他印了200多种不同面额的钞票，这就是使得钞票的流通变得很麻烦。居然没有发生通货膨胀。</li>
<li>在希特勒统治的前期，德国社会各阶层都是其政策的受益者。对于广大资本家，他取消了工会，禁止罢工，禁止工人和资方进行集体谈判，对于工人，希特勒给了他们工作，给了他们面包，对于农民，希特勒让他们收入增加，对于军队，希特勒积极扩军，军官唐人人升官，自然对希特勒感恩戴德。在第三帝国的前期，希特勒确实获得了的货人命的衷心拥戴。即使被他迫害的知识分子阶层，也由与希特勒恢复了德国的光荣而屈服在他的脚下。</li>
<li>在任何时候，新政都没有导致繁荣的完全恢复，这样的恢复速度，要等到1940-1941年国防开支进入快速挡的时候才出现，美国经济的真正复苏都是二战爆发之后再战争的刺激下才可以开始。</li>
<li>挽救德国经济，拒付赔款，撕毁凡尔赛和约，重整军备，进展莱茵非军事区，短短的俩年内希特勒取得了一系类的令人眼花缭乱的成就，他不但给工人工作和面包，给了农民的金钱，军官们升职，极大地没满足了德国自一次大战后严重受挫的民族自尊心，极大地提升了德意志的民族自豪感，希特勒真正的赢的德国的民心。</li>
<li>经历过社会最顶层生活又靠着残酷政治斗争掌权的希特勒一下子就摸清了英国人的底牌，那就是不想打仗。元首当然不想放过这个弱点，于是他就开始叫嚣战争了。</li>
<li>墨索里尼一心想要重现罗马帝国的荣光，这对于国力羸弱的意大利来说是力不从心，于是墨索里尼给自己找了个更弱的对手，非洲的土著国家。</li>
<li>我们必须经常提出那么多的要求以至于我们绝对不可能得到满足。</li>
<li>五月危机的消除说明了只要英，法，苏三国联合，希特勒就不可能发动战争了，可是却被希特勒分个瓦解。</li>
<li>英国人实行绥靖政策的原因。</li>
<li>英国人在一战中赢了战争，输掉了优势-称重的财务负担，每天打战的时候想到与英国每天往战场上㭁51吨黄金，得到的是什么？不过是一些贫瘠的殖民地和德国所谓的赔款承诺。为了弥补巨大的战争债务，发行公债，直到2015年才把第一次世界大战所欠的债务还完，这还是免了利息的。英镑霸主地位的动摇：铸币税的利益就没有，工业制造能力和市场的萎缩，商船和海外资产的巨减，大英帝国的分裂，惨重的人员伤亡，没有人会知道战争会如此的残酷，竟会长达四年之久，参战各国人民都是在爱国主义的狂热宣传下不但真诚的相信本国会取得胜利。</li>
<li>一战期间忧郁男人都上了战场所以妇女大量进了工厂，所以妇女的地位提高了，妇女似乎是天生的爱好和平，而男人总是想着吧别的男人送上战场。</li>
<li>希特勒的要求似乎是合法的。</li>
<li>在英国人看来，欧洲大战的结果肯定是灾难的，但获胜的不是德国就是俄国，不困发生什么，作为一个大国的大不列颠的地位及时不完全跨下也会下降，英国政府力求和平，而不是一场战争的胜利。</li>
<li>民主政体显然不是总能做出正确的决定，但民主制度一个好处就是他能很快的纠正自己的错误，而且付出的代价极其的小，，只需要换一拨人就可以了，没有路线斗争，没有党的分裂，没有国家的分裂，没有事后清算，因为所有的决定都是大家投票做出的决定，但是专治国家就不一样了，领袖是不能犯错的，因为领袖是不能下台的，但是领袖怎么呢才能不犯错呢？很简单，需要一个替罪羊，替罪羊可以是国内的卖国集团，阴谋家，也可以是国外的敌对势力，总之，领袖一定是正确的，遇到的困难总是暂时的，犯下的错误都是别人的。</li>
<li>自由不是免费的。</li>
<li>法国实行绥靖主义的原因。</li>
<li>我们要不惜一切代价来谋求和平，因为人民的真是情感已被战争所控制。</li>
<li>事实上法国总理在签完慕尼黑协定之后心情非常沉重的，他实在没有想到在出卖了自己最忠实的盟友后法国人民竟会热烈欢呼他带来和平。面对欢呼的人民，他说，一群傻瓜，他们哪里知道他们在欢呼的是什么？</li>
<li>德国为什么选择战争？</li>
<li>不平等的法尔赛和约，让他们普遍有一种复仇的心理。</li>
<li>没有沉重的经济负担，可以重整装备。</li>
<li>实际上是在消耗战中被打败的，但是欧普通民众都是不知道，他们老说是被人背后捅了一刀。</li>
<li>德国是一个独裁国家。</li>
<li>希特勒是要挑起战争，但却绝不是世界大战。他要的事一场场小的战争，有一场场晓得战争变成一个大的战争。</li>
<li>波兰亡国：波兰还给俄国选过沙皇。。</li>
<li>民族自决原则。</li>
<li>意大利在反法西斯战争中起到了一个不是卧底，胜似卧底，虽是敌人，甚是盟友的一个无可替代的角色。</li>
<li>意大利人也真是醉了。。这份清单足以气死一头公牛，如果他认识字的话。</li>
<li>在最后几天的和平的战争的时候，英法几乎是以一种囚犯的身份等待希特勒的裁决，或是战争，或是和平，他们只希望自己近乎西斯底里的坚决态度能够吓唬住希特勒。</li>
<li>在这个世界上，勇气永远战争不了炮火。</li>
<li>马奇诺防线让法国士兵认为完全可以安全的躲在公事内一边吃饭，一边开动机枪大炮将来犯的德军一片一片的打倒在地。</li>
<li>法国事实上默认了德国在欧洲有随意扩张的权利，只要不直接触及他的自身安全就行，法国用一条坚固的防线将自己紧紧的保护起来。法国已经完全失去了欧洲大陆的全局观念，不但出卖了最忠实的盟友捷克斯洛伐克，还做视另一个盟友波兰亡国。全面防御是法国头难僵化的表现，法国完全看不到坦克，飞机带给进攻一方带来的巨大优势，而是继续沉溺在所谓的一战胜利的经验上，企图再打一场战壕战。而马奇诺防线更像是一条锁链，不但束缚了法军的手脚而且束缚了法军的头脑，让法军吧战略进攻的主动权让给了德军。</li>
<li>希特勒以一种恶作剧的方式来表达他对法国人的耻辱，那就是不让钱来谈判的法国代表领事团知道谈判的具体地点，以便从法国人巨大的惊愕和羞辱中获得一种只有征服者才能体会到的快感。在纳粹德国灭亡前，这节火车厢被希特勒亲自炸毁，以免他成为第三次停战的前字地。</li>
<li>法国二战就打了6个星期就投降了。</li>
<li>1935年就组件了世界上第一个装甲师。当看到坦克群隆隆的驶来，元首高兴的说，这就是我想要的。这就是我需要的。</li>
<li>墨索里尼在希腊的轻举妄动以及南斯拉夫的局势变化使得原本在941年春季就实施的“巴巴罗萨”计划被迫推迟到夏季，这就使得德军在1941年可以作战的时间大大缩短了，随着多雨的夏季和严寒的冬季的到来，德军被迫放满了进攻的步伐，这就使得苏联获得了一个极为难得的喘息的机会，得以动员大量的后备以的人员入伍。苏德战争不再是闪电战了，而是变成了消耗战了。</li>
<li>苏联之所以最后能赢得战争的胜利很大原因是因为他不在插手军事行动了。</li>
<li>德军失败的原因：</li>
<li>战争无非是政治通过另一种手段的继续。所以分析战争的时候就不能脱离战争的双方的政治而单纯的研究战争本身，否则就会必然得出错误的观点，尤其是面对苏联这个庞然大物，由于战争不能在短时间结束，呢么政治的重要性就更加不言而喻了。</li>
<li>由于大清洗的时候共产党的所做所为，导致很多苏军将领认为这次战争可能是苏联出现新秩序的曙光，但是希特勒的残酷虐待战俘的行为确实的苏军不得不奋斗到底，由此造成了很多不必要的牺牲。</li>
<li>苏军在1941年的战役中坚持下来，主要依靠领土的辽阔和冬季的严寒。</li>
<li>斯大林是靠庞大的人口和土地压倒了希特勒。2000万的面积。1.6亿的人口。</li>
<li>这个时候苏联都是受到了美国全方位的帮助，汽油，高射炮。</li>
<li>苏联的动员能立，依靠着内战，大清洗，和集体化运动，元帅早已牢牢地掌握了这个国家，所有反抗他的人都被枪毙和送进了劳改营。</li>
<li>我没有别的，我只有热血，辛劳，眼泪和汗水贡献给大家，但战争不是靠着热血，辛劳，眼泪和泪水就能打赢的，这些东西美洲的印第安人和黑人兄弟也有的，战争是要靠着钱才能打赢的，有了钱不见得可以打赢战争，但是没有钱是绝对不可能打赢的。</li>
<li>二战之后：大英帝国对殖民地原材料的低价掠夺和工业品的垄断销售的特权被美国人打破了。大英帝国的海上霸权再也不复存在了。</li>
<li>至少有200万的妇女被苏军官兵强奸，甚至杀了人。在如此可怕的战争后，他们和妇女们玩一玩又有什么可怕的呢？主要是你们把红军理想化了，然而他们不是理想的军队。。最重要的是，他们应该打击德军，而且他们做的很好。其他的一切都是次要的。</li>
<li>以前土地才是财富的来源，但是现在以电气化为代表的第二次工业革命的开始，技术成为创造财富的最关键的因素，土地，人口已经不再变得那么重要了，掌握先进科学技术才能创造巨大的财富，而拥有人口，土地，工厂的国家则沦为产业链的下游，只能从科学技术那里捡一点残羹冷饭。但科学技术是无形的，他的载体是人，或者说更准确的是科学家，他不像普通的东西那样可以通过掠夺来获取。科学家是培养出来的。有了先进的技术，各国的消费者要排着队把钱送过来，为什么要发动战争呢？技术的进步给我带来和平，因为他使真正变得毫无意义，相反，战争会使我们大家都变成穷人。</li>
<li>宗教，爱国主义，民族主义，这三者在战争中起到了很重要的作用，以他们的名义要求一部分人为了整体而做出一部分的牺牲，这个牺牲包括各个方面的，时间，金钱，劳动，甚至是生命。这些东西会被大力提倡并给他们崇高的理由。从本质上来说，就是让一部分人做出牺牲，并且给他们的牺牲找到意义。</li>
<li>对你从没做过的事引以为豪，对你从没见过的人恨之入骨。爱国主义是往往是通过仇恨本国的敌人来体现的，而不是关爱本国的弱势群体来体现。所以的，当两个国家产生冲突的时候，爱国主义和民族主义会是冲突激化，从而失去妥协的余地，导致真正的战争爆发。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;没有什么东西能够够比陆军和海军更加依赖经济前提。一发炮弹是那个时代农民五年的收入&lt;br&gt;2.一旦技术上的进步可以用于军事并且已经用于军事目的，他们便立刻几乎强制的。而且往往是违反指挥官意图而引起作战方式的改变甚至是变革。随着技术武器的出现，将再也不可能出现落后文
    
    </summary>
    
    
      <category term="战争的逻辑--普鲁士到德国崛起" scheme="https://github.com/skoll1/libateer.github.io/tags/%E6%88%98%E4%BA%89%E7%9A%84%E9%80%BB%E8%BE%91-%E6%99%AE%E9%B2%81%E5%A3%AB%E5%88%B0%E5%BE%B7%E5%9B%BD%E5%B4%9B%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>js代码书写规范</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-JS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-JS代码规范/</id>
    <published>2017-03-09T15:19:23.000Z</published>
    <updated>2017-03-22T04:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>###编程模式与设计模式###</p>
<ol>
<li>命名空间：为了减少命名冲突，必须减少使用全局变量的机会，最好的办法就是将变量和方法定义在不同的命名空间里面。</li>
<li>`var my=window.my||{};<br> my.event={<br>   get:function(){<br> console.log(1);<br>},<br>   set:function(){<br> console.log(this.name)<pre><code>}
</code></pre>}`</li>
<li><p>`    var NameSpace = window.NameSpace || {};</p>
<pre><code>NameSpace.Hello = (function() {

  var self = {};

  var name = &apos;world&apos;;

  self.sayHello = function(_name) {

return &apos;Hello &apos; + (_name || name);
</code></pre><p>};<br>return self;</p>
<p> }());`</p>
</li>
</ol>
<ol>
<li><p>`var NameSpace = window.NameSpace || {};</p>
<pre><code>NameSpace.Hello = new function() {
  var self = this;
  var name = &apos;world&apos;;
  self.sayHello = function(_name) {
</code></pre><p> return ‘Hello ‘ + (_name || name);<br>};<br>};`    </p>
</li>
<li><p>初始化分支：在加载的时候，对代码进行分支管理，而不是在浏览器运行事件的时候在判断行为。当再次调用的时候就不需要检测了。</p>
</li>
<li><p><code>var start={};
start.event={
addListener:null,
removeListener:null
}
if(typeOf window.onload===&quot;fn&quot;){
start.event.addListener=function(el,type,fn){
 el.addEventListener(type,fn,false);
}
start.event.removeEventListener=function(el,type,fn){
 el.removeEventListener(type,fn,false)
}
}else if(typeOf document.attachEvent===&quot;function&quot;){
start.event.addListener=function(el,type,fn){
 el.attachEvent(&#39;on&#39;+type,fn);
};
start.event.removeListener=function(el,type,fn){
 el.detachEvent(&#39;on&#39;+type,fn)
};
}else{
start.event.addListener=function(el,type,fn){
 el[&#39;on&#39;+type]=fn;
};
start.event.removeListener=function(el,type,fn){
 el[&#39;on&#39;+type]=null;
};
};</code></p>
</li>
<li><p>变量名之前的前缀应该是名词，myName,函数名前缀应该是动词(can,has,is,get,set);</p>
</li>
<li>for in 是用来遍历对象的，而不是数组。for(var i in person){console.log(i+person[i])};连值带属性</li>
<li>避免全局变量的原因：任何在全局中定义的变量都是window的对象或属性，全局变量越多，得到错误的几率越大。</li>
<li>命名冲突，代码脆弱性，难以测试。</li>
<li>意外的全局变量：党给一个未被var声明过得变量赋值的时候。</li>
<li>将代码置于严格模式会改变很多js行为，对于新的代码，最好使用严格模式来避免以外的全局变量。</li>
<li>当事件触发时，事件对象会作为回调函数参数传入事件程序中，event对象包含所有和时间相关的信息，包括事件的宿主（target）以及其他和事件类型相关的数据。</li>
<li></li>
</ol>
<p>###腾讯代码规范###</p>
<ol>
<li>项目名字全部小写，中间用下划线分割。</li>
<li>有复数形式的时候要采用复数命名法。scripts</li>
<li>Js文件命名：参照项目名字</li>
<li>html语法：缩进四个空格。嵌套的节点要缩进。属性上都用双引号，属性名都小写，用中划线做分隔符。不要再自动闭合的变迁结尾处做斜线，不要忽略可选的关闭标签。</li>
<li>Lang属性；在HTML标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉他们怎么发音和翻译。</li>
<li>字符编码：通过声明一个明确的字符编码，让浏览器更加轻松，快速的确定适合网页的渲染方式，通常是“UTF-8</li>
<li>meta变迁还可以指定页面用什么版本的IE来渲染；查，不同doctype在不同的浏览器下出发不同的渲染模式</li>
<li>引入css和js的时候不需要指明type,因为他们有默认值。查。这些都可以在w3c官方文档上面查到。</li>
<li>属性顺序：按照特定的顺序保证易读性：class,id,name,data-,/src,for,type,href,value,max-lenght,max,min,pattern/placeholder,title,alt,aria-*,role,reqired,readonly,disabled.</li>
<li>class是为了高可用重复组件设计的，所以尽量放在前面，id更高具体，所以尽量少用，放在第二位。</li>
<li>bolean属性表示不需要声明取值的属性，XHTML需要每个属性声明取值，但是html5并不需要；bloean属性的存在表示取值为true，不存在表示取值为false。（sselected）</li>
<li>在js文件中生成标签会让内容变得更加难查找，更难编辑，性能更差。所以应该尽量避免这种情况的出现</li>
<li>减少标签的数量：在编写代码的时候，要尽量避免多余的父节点；很多时候，都需要通过迭代和重构来使元素变得更少。</li>
<li>在遵循html标准和语义的时候，但是不应该以浪费实用性作为代价。</li>
<li>任何时候都要尽量小的复杂度和尽可能小的标签来解决问题。</li>
<li>css缩进4个空格。</li>
<li>以下几种情况下需要空格：属性值钱，选择器’&gt;’,’+’,’~’前后。</li>
<li>空行：文件最后白留一个空行。属性之间要保留空行。</li>
<li>换行的规则</li>
<li>注释的规则：</li>
<li>引号：最外层要用双引号，url的内容要用引号。属性选择器中的属性值需要引号。<br>li[data-type=”single”] </li>
<li>类名用小写加中划线分割</li>
<li><p>id用驼峰式命名<br>相关的属性声明要按照右边的顺序分组处理，各组之间需要有一个空行。<br>declaration-order{<br>display: block;<br>float: right;</p>
<p>position: absolute;<br>top: 0;<br>right: 0;<br>bottom: 0;<br>left: 0;<br>z-index: 100;</p>
<p>border: 1px solid #e5e5e5;<br>border-radius: 3px;<br>width: 100px;<br>height: 100px;</p>
<p>font: normal 13px “Helvetica Neue”, sans-serif;<br>line-height: 1.5;<br>text-align: center;</p>
<p>color: #333;<br>background-color: #f5f5f5;</p>
<p>opacity: 1;}<br>感觉上面的没必要啊：用chrome的时候之间分出来了，就是那个再次修改的时候比较好找一点。</p>
</li>
<li>颜色16进制用小写，16进制最好简写</li>
<li>属性简写要你特别熟悉属性的正确顺序，而且大多时候都不要写出全部的内容，所以建议分开写，因为那也废不了多少时间《放屁，给不认识的人看的时候好看就看吧。</li>
<li>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，那样做只会让人们更加容易忘记他们。</li>
<li>属性值为0的后面不加任何单位。</li>
<li>无前缀的属性要写在有前缀的属性后面。不要再同个规则里出现重复的属性，如果重复的属性是连续的就没关系。</li>
<li>用 border: 0; 代替 border: none;；</li>
<li>Js</li>
<li>换行的时候，行末必须有运算符：</li>
<li>但是在关键字哦的后面，else,catch,finally的后面就不要换行了。</li>
<li>代码注释和文档注释。。。</li>
<li>在这个里面最外层统一用单引号。</li>
<li>用’===’, ‘!==’代替’==’, ‘!=‘；</li>
<li>for-in里一定要有hasOwnProperty的判断；</li>
<li>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名</li>
</ol>
<p>###百度代码规范###</p>
<ol>
<li></li>
<li>缩进与换行：4个空格为一个缩进层。每行不要超过120个字符；</li>
<li>class命名必须代表相应的模块或不见得内容或功能，不得以样式信息来命名。</li>
<li>禁止为了hack创建无样式的class.</li>
<li>不允许class只是为了让js选择某系元素，class应该具有明确的语义和样式。否则容易导致css的泛滥</li>
<li><p>ie会混淆name和id，所以最好他们之间不一样。<br>7.</p>
<!-- good -->
<input type="text" name="title">
</li>
<li><p>上面这个编辑器会自己解决吧。</p>
</li>
<li>标签使用必须符合严格的嵌套规则</li>
<li>块级元素 一般用来搭建网站架构、布局、承载内容……像这些大体力活都属于块级元素的，它包括以下这些标签： </li>
</ol>
<p>address、blockquote、center、#dir#、div、dl、dt、dd、fieldset、form、h1~h6、hr、isindex、menu、noframes、noscript、ol、p、pre、table、ul </p>
<ol>
<li>内嵌元素 一般用在网站内容之中的某些细节或部位，用以“强调、区分样式、上标、下标、锚点”等等，下面这些标签都属于内嵌元素： </li>
</ol>
<p>a、abbr、acronym、b、bdo、big、br、cite、code、dfn、em、font、i、img、input、kbd、label、q、s、samp、select、small、span、strike、strong、sub、sup、textarea、tt、u、var </p>
<ol>
<li></li>
<li>display: inline; /<em> 转成内嵌元素 </em>/<br>14.<br><div><h1></h1><p></p></div> —— 对<br><a href="”#”"><span></span></a> —— 对 </li>
<li><span><div></div></span> —— 错 </li>
<li><ol>
<li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<br>h1、h2、h3、h4、h5、h6、p、dt </li>
</ol>
</li>
<li>li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明</li>
<li>li 和 div 标签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大滴…… </li>
<li>p - 段落</li>
<li>h1,h2,h3,h4,h5,h6 - 层级标题</li>
<li>strong,em - 强调</li>
<li>ins - 插入</li>
<li>del - 删除</li>
<li>abbr - 缩写</li>
<li>code - 代码标识</li>
<li>cite - 引述来源作品的标题</li>
<li>q - 引用</li>
<li>blockquote - 一段或长篇引用</li>
<li>ul - 无序列表</li>
<li>ol - 有序列表</li>
<li>dl,dt,dd - 定义列表</li>
<li>虽然列的都是常用的。但是没必要记那么多啊，最多就是自己给默认了几个css样式，如果对语义化和seo有差距的话那就另当别论了</li>
<li>布尔类型的属性，不要加属性值。</li>
<li>自定义属性的写法data- 使用前缀有助于区分自定义属性和标准定义的属性。<br>35.<br><meta http-equiv="X-UA-Compatible" content="IE=Edge"><br>启用IE Edge<br>36.<br>引入 CSS 时必须指明 rel=”stylesheet”</li>
</ol>
<p>不需要的是type属性这个是默认的<br>37.<br>添加 width 和 height 属性，以避免页面抖动。</p>
<p>[建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。</p>
<p>强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。</p>
<label><input type="checkbox" name="confirm" value="on"> 我已确认上述条款</label>

<p><label for="username">用户名：</label> <input type="textbox" name="username" id="username"><br>具体选择形式是这个。。</p>
<p>使用 button 元素时必须指明 type 属性值。</p>
<p>解释：</p>
<p>button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。</p>
<p>真的默认是提交我去了了。。。</p>
<ol>
<li>负责主要功能的按钮应该放在相对靠前，以提高访问性。</li>
<li>当使用js进行提交表单的时候，如果条件允许，使用原生的提交功能，当js出错的时候，照样可以提交</li>
<li>在媒体格式的时候，音频要是mp3,Wav,ogg.视屏要是MP4，webm,ogg.</li>
<li>Css</li>
<li>Css文件使用无bom得utf-8格式<br>6.<br>.post,<br>.page,<br>.comment {<br> line-height: 1.5;<br>}<br>main &gt; nav {<br> padding: 10px;<br>}</li>
</ol>
<p>label + input {<br>    margin-left: 5px;<br>}</p>
<p>input:checked ~ button {<br>    background-color: #69C;<br>}<br>article[character=”juliet”] {<br>    voice-family: “Vivien Leigh”, victoria, female;<br>}</p>
<p>#error,<br>不得为id,class选择器添加类型选择器进行限定。<br>选择器的嵌套层级应该不大于3级，位置靠后的限定条件应该尽可能的精确。<br>并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性</p>
<pre><code>* Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等
* Box Model 相关属性包括：border / margin / padding / width / height 等
* Typographic 相关属性包括：font / line-height / text-align / word-wrap 等
* Visual 相关属性包括：background / color / transition / list-style 等
</code></pre><p>将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。</p>
<p>如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。</p>
<p>建议每层包含100个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。</p>
<p>在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647</p>
<p>RGB颜色值必须使用十六进制记号形式 #rrggbb</p>
<p>[强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。</p>
<p>font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。</p>
<p>font-family: “Helvetica Neue”, Arial, “Hiragino Sans GB”, “WenQuanYi Micro Hei”, “Microsoft YaHei”, sans-serif;<br>但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。<br>将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。</p>
<p>当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。</p>
<p>尽可能在浏览器能高效实现的属性上添加过渡和动画。</p>
<pre><code>* transform: translate(npx, npx);
* transform: scale(n);
* transform: rotate(ndeg);
* opacity: 0..1;
</code></pre><p>.box {<br>    transition: transform 1s;<br>}<br>.box:hover {<br>    transform: translate(20px); /<em> move right for 20px </em>/<br>}<br>Media Query 不得单独编排，必须与相关的规则一起定义。</p>
<p>.box {<br>    -webkit-box-sizing: border-box;<br>       -moz-box-sizing: border-box;<br>            box-sizing: border-box;<br>}</p>
<p>Js</p>
<ol>
<li>Js文件使用无BOM的UTF-8编码</li>
<li><ol>
<li>所有看到的东西都是通过引擎绘制出来的，更新频率取决于开发者指定的FPS，帧数越高，视觉上感觉越流畅，60是满值。在实际运行情况中，性能还取决于JS解析器的效率，制定的FPS帧数可能在低性能解释器中得不到体现，所以这不是开发者所能决定的，说一只能做的是尽可能的优化代码，关注每帧执行逻辑代码带来的CPU消耗，好需要注意每帧调用回吐指令的数量以及CPu的纹理提交速度</li>
</ol>
</li>
<li>基准测试：实时监测当前性能。FPS越高越好。Sprite：渲染节点数量：越低越好</li>
<li>内存优化：对象池：涉及到不断重复使用的对象。在初始化应用的程序期间创建一定的数量的对象并将其存储在一个池中。对一个对象完成操作后，将该对象放回到池中，在需要新对象时可i对其进行检索</li>
<li>h5内嵌框架标签元素，iframe<iframe src="http://www.divcss5.com/" width="400" height="200" scrolling="yes">使用框架不利于网页搜索的优化。</iframe></li>
<li>闭合标签就是标签又开始，有结束</li>
<li>h5可以支持很多标签不闭合</li>
<li>无内容元素：是一种不能包含任何内容的特殊的元素，例如:br,hr,img,link,meta,area,base,col,command,embed,keygen,param,source,track,war,渊源：sgml时期有一种标签叫无尾标签，当一个标签内只有简单的文字的时候，就可以使用无尾标签无须闭合这个标签了。</li>
<li>接下来升级为无标签元素，<br>这样写起来自然，当h5的时候，他们是这样说的：HTML5 的语法完全兼容 HTML4 和 XHTML1，但是不兼容 SGML 中那些晦涩的 HTML4 特性。比如无尾标签（&lt;em/content/）。</li>
<li>自闭合标签到底要不要加／号，</li>
<li>创建按钮的四种方法<input type="button"> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li>
<li><input type="submit"> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。<button> 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题。其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮.如果只是歌单纯的按钮，触发一些动画动作，那么button,当要把画面数据提交给服务器的submit。</button></li>
<li>button和input:button.在button内部，您可以放置内容，比如文本或图像。这是该元素与实用input元素不同的之处。button与button之间的所有内容都是按钮内容，其中包括可接受的正文内容，文本或者多媒体内容。需要注意的是要始终给她加上type属性，IE的默认类型是button而其他的浏览器着submit。</li>
<li>web安全色216种，</li>
<li>img上title和alt  title是在鼠标悬停上显示的内容，alt是在某种情况无法显示图片的情况下出现的信息。</li>
<li>网页字体用偶数不用奇数</li>
<li>网页元素</li>
<li>meta：位于文档的头部，定义了与文档相关联的元信息，这些元对象是以名称的形式成对定义的。一个页面可以定义多个meta标签，每个标签分别通过对应的name（关联到http头部）和content（把属性关联到一个名称）属性定义键值，来定义不同的原信息。</li>
<li>base指定所有页面中所有链接的基础路径。如果没有base的话，那么页面所有的相对路径将生成绝对路径作为默认的基础路径。</li>
<li>style的type 指定样式类型，浏览器支持的样式只有css一种，所以这个属性只有css一种，media属性置顶使用的媒体，表明文档在什么时候用什么元素定义的样式。</li>
<li>media属性详解：运算符 and,not ,or,</li>
<li>link:link和style 怎么结合起来用啊？link内部也有一些属性，media.</li>
<li>给网站添加logo。&lt;link rel=“shortcut icon” href=“” type=“image/x-icon”&gt;</li>
<li>预先获取资源：等同于让浏览器在空闲时间或预读取一些资源文档，不造成资源浪费。</li>
<li>link rel=“prefetch” href=“页面地址” 怎样控制什么时候开始。。</li>
<li>这是什么书？真是菜啊。。</li>
<li>异步执行脚本。方法：回调函数，事件监听，观察者模式，promise对象。</li>
<li>meta定义页面关键<meta name="“keywords”" content="“”">设置页面描述：<meta name="“description”" content="“输入内容"">都是为了搜索引擎，只是输入的字数限制不同。<meta name="“author”" content="“"">设置作者信息，<meta name="“robots”" content="“可选值”">：可以限制搜索网站方式，也就是把自己藏起来，</li>
<li>语言和文字:<meta http-equiv="“content-language”" content="“Zh-CN”/"></li>
<li>定时跳转页面：&lt;meta http-equiv=“Refresh” content=“10,url=http:www.baidu.com”&gt;也可以刷新网页</li>
<li>设置网页缓存过期的时间。</li>
<li>禁止从缓存中调用。</li>
<li>删除过期的cookie.</li>
<li>网页过渡效果：什么都可以，我去长见识了</li>
<li>标记文字</li>
<li>强调em.外文或科技术语i.重要的文字:strong.表示不正确和较正s.</li>
<li>为文字加下划线u.小号字体small.添上标sub.下标sup.</li>
<li>表示缩写abbr.定义术语<dfn title="“sdfsdf”">jlkjlklkjl</dfn>;</li>
<li>引用其他处的内容<q cite="“http://baidu.com”">sdkls<p></p>;</q></li>
<li>cite引用其他作品的标题。</li>
<li><ruby>漠&lt;&gt;</ruby></li>
<li>显示图像</li>
<li>图像预先加载</li>
<li>图像区域映射 <img><map>&lt;area shape=“circle coords=“0,100,200,30,9”&gt;</map></li>
<li>使用base64:url格式的图片。data取的数据的协定名称。就是代码表示一张图片，但是不能大于32k.高清图片不能显示，不可以裁成小段么？</li>
<li>生成超链接</li>
<li>指向外部的</li>
<li>使用相对url，相对路径和。绝对路径。</li>
<li>生成页面⚓️点</li>
<li>生成图像链接，电子邮件链接mailto</li>
<li>设定浏览环境——self当前页面打开，_blank创建新页面打开。</li>
<li>组织文字内容</li>
<li>pre：可以定义预格式化的文本。被包围在pre中的元素会保留空格和换行符。而文本也会呈现为等宽字体。pre标签的一个常见的应用就是来显示计算机的代码可以显示非格式化的内容。</li>
<li>应用他处内容block quote 他们之间的所有文本都会被从常规的文本中分离出来，经常会在左右两边缩进，而且有时会用斜体，也就是说，块引用有自己的空间。</li>
<li>dialog h5中用于定义对话框或窗口</li>
<li>划分文档结构：标题的使用是十分常见的，页面标题，模块标题，块区标题，各式各样的标题都可以使用h1-h6来实现。</li>
<li>hgroup 给标题分组隐藏起来，那就可以出现多个了。</li>
<li>section:对内容进行块划分，代码层次结构简单。在一个页面里面可以使用多个footer，既可以做页面的整体页脚，也可以做为一个内容区块的结尾。</li>
<li>语义化写代码article大段纯文字   附注栏：aside. </li>
<li>adress在页面输出联系人信息。</li>
<li>details summary 配合起来可以提供一个显示和隐藏文字的小工具。</li>
<li>使用下拉列表：label for=“sd”我最爱的球队 input type=“text” name=“team” id=“team_list”<pre><code>1. datalist id=“team_list&quot;
2. option edg
                        1. option rng但是这个怎么自动生成啊，这只能玩现成的？
</code></pre><ol>
<li><ol>
<li>使用局部变量。只要使用超过一次，最好都设置为局部变量。</li>
</ol>
</li>
</ol>
</li>
<li>高效的数据读取，4字面量值，变量，数组元素，对象属性。真正的差异在于从数组或对象中读取数据。存取这些数据结构中的某个值，需要通过索引或属性值来查询数据存储的位置。</li>
<li>在数据存储的过程中，将函数使用超过一次的对象属性或数组元素存储为局部变量是一种好方法。</li>
<li>流控制：在每个环节上选择浅淡的语句能够极大的提高脚本的运行速度。</li>
<li>// 条件判断</li>
<li>if(value==9){</li>
<li>return 9;</li>
<li>}else if(value==8){</li>
<li>return 8</li>
<li>}</li>
<li>// 把最常用到的条件摆到前面，而不是按照顺序一个一个的来排练。 </li>
<li>if(value&lt;6){</li>
<li>if(value&lt;3){</li>
<li>if(value==0){</li>
<li>return 0;</li>
<li>}else if(value==1){</li>
<li>return 1;</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>//这样式将条件拆分为几个分支，确保执行任意一次都不会超过4次条件判断。</li>
<li>// 当有大量的条件判断时，推荐使用switch而不是if而且可以参照第一种用法。</li>
<li>// 数组查询方法，超过10个条件需要判断，</li>
<li>var result=[result0,result2,1,2,3,,4,]</li>
<li>return return[value];</li>
<li>// 循环问题</li>
<li>// 反复比较计数变量和数组的长度。</li>
<li>// 保存var length=arr.length;</li>
<li>var values=[1,2,3,4,4];</li>
<li>var length=values.length;</li>
<li>for(var i=length;i–){</li>
<li>process(values[i]);</li>
<li>}</li>
<li>// 结束条件与0做比较，大大减少时间的浪费。</li>
<li>// 处理大量数组的展开循环方法</li>
<li>var item=Math.floor(values.length/8);</li>
<li>var leftover=values.length%8;</li>
<li>var i=0;</li>
<li>if(leftover&gt;0){</li>
<li>do{process(values[i++]);</li>
<li>}while(–leftover&gt;0);</li>
<li>}</li>
<li>do{</li>
<li>process(values[i++]);</li>
<li>process(values[i++]);<br>}while(–item&gt;0);<br>// 字符串优化<br>// 频繁的在后台创建和销毁字符串是很费时间的，加法是在字符在1000以内所有浏览器都能在1毫秒之内完成，此时优化已经没有意义了<br>// 裁剪字符串；<br>function trim(text){<br>return text.replace(/^\s+|\s+$/g,””);<br>}<br>// 提花你开头或结尾的空白元素。<br>function trim(text){<br>text=text.raplace(/^\s+/,””);<br>for(var i=text.length-1;i&gt;=0;i–){<br>if(/\s/.text.(text.charAt(i))){<pre><code>text=text.substring(0,i+1);
break;
</code></pre>}<br>return text;<br>}<br>}<br>// 大量最快。<br>// js是单线程语言，那意味着一段时间呗只能执行一个操作，这意味着在执行js时所有的用户交互都会被打断，所以可能会出现页面冻结<br>// 脚本失控的原因，过多的dom交互，什么是dom交互.<br>// 过多的循环，过多的递归。<br>// 解决办法：使用定时器挂起。<br>window.onload=function(){<br>setTimeout(function(){<br>// 被延迟的脚本1<br>setTimeout(function(){<pre><code>// 被延迟的脚本2
</code></pre>}，100)<br>}，100)<br>}<br>// 超越gzip的压缩<br>// 有些头文件的请求会被修改，主要是web代理和pc安全软件，通过移除accept-encoding头的技术来窃听。<br>// 设计目标：最小化未压缩的文件的尺寸。使用事件委托：当有多个元素需要执行相同的事件时，可以把这个事件的处理程序绑定到<br>// 她的父级元素上面，但这个元素在字元素出发的时候，会冒泡到父元素上面。2使用相对url3移除空白。4移除属性的引号<br>// 避免行内样式，5为JS设置别名var $=document.getElementById;<br>// 直接检测是否支持Gzip。来为她设置这个属性。</li>
</ol>
<p>// 图像优化：<br>// 使用图片优化技术2:选择合适的格式,jpeg保存照片，GIF保存动画，其他所有动画都用png来保存，但是尽量使用png8。<br>// 对于超过10KB的图像，采用渐进jpeg编码。使用csssprite.不要在页面内对图片大小缩放。<br>划分主域：htttp瀑布图。</p>
<ol>
<li>最大链接限制的是url上的主机名，而不是解析出来的IP地址。只要为新域建立一条cname纪录。仅仅是以一个域名的别名，即使域名是来自一个服务器，那么浏览器依旧会给每个主机打开最大链接数。</li>
<li>css选择符，避免使用通配原则，不要限定id 选择符，不要限定类选择符，让规则越具体越好，不要使用后代选择符，依靠继承。</li>
<li>避免使用的选择符：决定优化的部分是在哪些可能匹配大量元素的关键选择符上面。</li>
<li>css选择符</li>
<li>性能工具：数据包嗅探器，性能分析器：YSlow                                   </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###编程模式与设计模式###&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命名空间：为了减少命名冲突，必须减少使用全局变量的机会，最好的办法就是将变量和方法定义在不同的命名空间里面。&lt;/li&gt;
&lt;li&gt;`var my=window.my||{};&lt;br&gt; my.event={&lt;br&gt;   
    
    </summary>
    
    
      <category term="js代码规范" scheme="https://github.com/skoll1/libateer.github.io/tags/js%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>js新特性(主要是5版本)</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-新特性/</id>
    <published>2017-03-09T15:06:25.000Z</published>
    <updated>2017-03-17T05:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>保留字可以做为属性键了，在对象中，点操作符后面可以使用保留字作为非引用属性键。</li>
<li>对象字面量和数组字面量中最后的逗号是合法的。。忠于。</li>
<li>多行字符串：如果在行尾使用反斜杠转移字符，字符串变量可以跨多行。</li>
<li>我被他那一章给骗了，东西全有之前。。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;保留字可以做为属性键了，在对象中，点操作符后面可以使用保留字作为非引用属性键。&lt;/li&gt;
&lt;li&gt;对象字面量和数组字面量中最后的逗号是合法的。。忠于。&lt;/li&gt;
&lt;li&gt;多行字符串：如果在行尾使用反斜杠转移字符，字符串变量可以跨多行。&lt;/li&gt;
&lt;li&gt;我被他那
    
    </summary>
    
      <category term="Code" scheme="https://github.com/skoll1/libateer.github.io/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>JS和unicode</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-unicode/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-1-unicode/</id>
    <published>2017-03-09T13:53:34.000Z</published>
    <updated>2017-03-17T05:49:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>字符和字形：字符相当于拼音，字形就是汉字。字形是语言的基本单位。</li>
<li>雕文：雕文表示字形的具体显示方式。有时，一个字形也可能会有不同的显示方法。这都取决与他的上下文以及其他的一些因素。<br>3.码位：unicode通过一种叫码位的数字来表示字符。马尾的十六进制范围从0X0到0X10ffff.</li>
<li>码元：</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;字符和字形：字符相当于拼音，字形就是汉字。字形是语言的基本单位。&lt;/li&gt;
&lt;li&gt;雕文：雕文表示字形的具体显示方式。有时，一个字形也可能会有不同的显示方法。这都取决与他的上下文以及其他的一些因素。&lt;br&gt;3.码位：unicode通过一种叫码位的数字来表示字符。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动设计-互动精髓</title>
    <link href="https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/skoll1/libateer.github.io/2017/03/09/best-3-移动设计/</id>
    <published>2017-03-09T13:22:10.000Z</published>
    <updated>2017-03-09T13:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>设计师不应该仅仅是专注于项目的创新而不理会新技术的发展，移动社交的精髓是应用会在恰当的时候想用户呈现信息，用户能对其快速感知，并只需作出非常简单的反馈。用户的要求是有活力的，他会要求自己的应用和自己的操作系统融合在一起。</li>
<li>交互设计的主要驱动力在交互工具的发展</li>
<li>你因该设计界面有一定的容错性，避免用户陷入困境，因为计算机执行的代码是准确无误的，但是人无视完美的，所以要注意一下几点：预防数据的丢失，提高操作结果的预见性，允许用户犯错后重试。反复确认按钮，</li>
<li>一句话：用户永远都是对的。</li>
<li>合理的设计程序，及时在不同的界面，操作系统和设备尺寸上面有所不同，用户的体验也是一致的，高效的。交互设计师需要清楚的知道界面和软件之间的差距，从本质上讲，客户花费了酬劳就是要你根据自己的专业知识进行合理的设计决策，从而提供愉悦的，直观的使用体验。</li>
<li>在移动网站阶段，要常访问此类门户网站。</li>
<li>最好先弄秦楚谁是你的而主要客户。针对你的开发项目。你的目标用户可能是特定年龄，性别，有特定爱好的人群。从而从用户的视角去考虑，能够理解问题并找出潜在的痛点。</li>
<li>界面要简单易懂，易于学习，交互方式要明确，直观。</li>
<li>移动应用和传统应用之间不是替代关系，而是互补关系。</li>
<li>尽管你希望自己的应用能解决你想像到的所有问题，但是任何成功的程序都是解决用户的一个问题，并把这个做到最好。</li>
<li>年龄，他们所用的设备。</li>
<li>手机独有的交互设计：移动定位。用户不需要花费时间输入地址和邮件，他可以和容易的找到附近自己需要的东西。</li>
<li>大众化的分格更容易被人接受，让你的设计摆脱地域的限制。</li>
<li>如果你没法提供更多的语言来，那么最好提供更多的图，一图胜千言，好的图有很大意义上的通用性。</li>
<li>简约设计在任何时间，任何东西都是适用的。</li>
<li>谷歌的使命字面意思是整合全球信息，使人人尽享并受益。这一指导思想推进了计算机科学史的重大进步，如果你的应用有个目标或使命。并且比谷歌的文字多，那么你有必要坐下来在换一个更加简洁的目标。</li>
<li>下载量最大的日历，计算机或记事本应用，这类应用时最常见的，可以看他们的应用操作是如何设计的，他们是竞争最激烈的。</li>
<li>如果只是一小撮人在用某个功能的话，那么最好把它藏起来。一旦你的应用发布的话，那么就意味着你哦很难去掉某个功能，那些使用高级功能的人也是最爱惹事的人。</li>
<li>跟随业界领袖的脚步、</li>
<li>a/b测试，设计两种不同的网页设计，看用户喜欢那个就用哪个？</li>
<li>了解用户把时间花在了哪，因为客户永远不知道他们自己喜欢或不喜欢某项引用的原因。数据分析会让你知道这些东西。</li>
<li>维护工作日志，做一个个人的资料库，记录自己的工作遇到的情况。</li>
<li>评估自己的工作。</li>
<li>亚马逊网站</li>
<li>cnn news</li>
<li>flipboard</li>
<li>wolfram|alpha</li>
<li>移动设备任何时候都是要考虑文字输入是个大问题。</li>
<li>手势于鼠标的区别。</li>
<li>在小屏幕中去除不必要的杂乱元素，在大屏幕上突出其控件和增强式导航。</li>
<li>要时刻质疑开发中能否简化界面，设计师非常容易陷入添加功能的的误区。</li>
<li>可以先体验一些没有被优化过的网页，在看现在这些区别。</li>
<li>优雅降级。</li>
<li>减少界面冲突。</li>
<li>在现实世界中，你只有一次机会给别人留下第一印象，在数字世界也是如此。</li>
<li>在这个页面浏览的时候想用到别的程序怎么办？</li>
<li>搭配—比赛—游戏—领券—社交—好的一部分—评论—改进的地方。</li>
<li>你给我一件东西，我会立刻把他的全部额外功能都现出来。扩展，用现在的思想。</li>
<li>用户不是电脑极客；</li>
<li>80、20 80的客户只会用到20的功能，但是为什么游戏的时候我们会用到其他的所有地方呢？</li>
<li>按钮：$(function(){</li>
<li>$(‘input[type=”submit”]’).click(function(){</li>
<li>$(this).animate({</li>
<li>opacity:0.1</li>
<li>},8).animate({</li>
<li>opacity:0.9</li>
<li>},226).animate({</li>
<li>opacity:0.5</li>
<li>},86);</li>
<li>$(‘input[type=”submit”]’).removeClass(‘partial-fade’).animate({</li>
<li>opacity:1</li>
<li>},86);</li>
<li>// 这什么垃圾特效。。。</li>
<li>})</li>
<li>});</li>
<li>input[type=’submit’]{</li>
<li>color:white;</li>
<li>padding: 5px;</li>
<li>width: 68px;</li>
<li>height: 28px;</li>
<li>border-radius: 5px;</li>
<li>border: 1px;</li>
<li>font-weight: bold;</li>
<li>border:1px groove #7a7a7a;</li>
<li>background: linear-gradient(to bottom,#0f97ff 0%,#97d2ff 8%,#0076d1 63%,#005494 100%);</li>
<li>}</li>
<li>input[type=”submit”]:hover{</li>
<li>border:2px groove #7a7a7a;</li>
<li>}</li>
<li>input[type=’submit’].partial-fade{</li>
<li>border-top:1px solid #cff;</li>
<li>border-right:1px solid #ccf;</li>
<li>border-left:1px solid #ccf;</li>
<li>border-bottom: 1px solid #6cF;</li>
<li>box-shadow: 0 0 8px 0px #0f97ff ,inset 0 0 20px rgba(37,141,220,1);</li>
<li>Mask-image：实现字体遮罩。</li>
<li>响应式布局的实现：</li>
<li>Float:max-width:350px float:left;当装不下的时候自动去下一行。</li>
<li>基于相对内编剧的布局控制：comment:padding:0 0 0 10%.给想要排列的所有顺序盒子加上这个东西 </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;设计师不应该仅仅是专注于项目的创新而不理会新技术的发展，移动社交的精髓是应用会在恰当的时候想用户呈现信息，用户能对其快速感知，并只需作出非常简单的反馈。用户的要求是有活力的，他会要求自己的应用和自己的操作系统融合在一起。&lt;/li&gt;
&lt;li&gt;交互设计的主要驱动力在
    
    </summary>
    
    
      <category term="移动设计-互动精髓" scheme="https://github.com/skoll1/libateer.github.io/tags/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E4%BA%92%E5%8A%A8%E7%B2%BE%E9%AB%93/"/>
    
  </entry>
  
</feed>
